[TOC]

# 富聪笔记

# 20170401

pandas dataframe

dataframe.apply()

lambda

secfunc=lambda x: math.floor

dataframe.apply(secfunc)

这样比写循环结构快多了

从mongoDB拉出的时间数据 daatetime 可以直接加减，后 转换为秒，total_sec()







# 20170505

## 桌面远程链接

[win7远程桌面连接设置](https://jingyan.baidu.com/article/49711c612a025cfa451b7c54.html)

win7远程桌面连接[地址][10]

[10]: https://jingyan.baidu.com/article/49711c612a025cfa451b7c54.html	"win7远程桌面连接设置"
![mstsc远程桌面连接](.\imagenote\mstsc远程桌面连接.png)

![远程桌面连接设置](.\imagenote\远程桌面连接.png)





1. 首先要设置好被远程电脑的用户名密码，打开**“控制面板”**

2. 点击“用户账户和家庭安全”

3. 点击“更改密码”

4. 点击“为您的账户创建密码”

5. 输入你要的密码，点击“创建密码”就可以了。

6. 接着打开计算机属性，选择**“远程设置”**

7. 把“允许远程协助连接这台计算机”打钩，下面的“允许运行任意版本远程桌面的计算机连接（较不安全）”选中，其他的不用管它。至此，被远程的计算机已经设置好了，就坐等别人远程就可以了。

8. 先查看被远程的计算机的IP地址（我这里演示的是局域网，注意事项里再说下要注意什么的），我的地址就是172.168.2.101

9. 打开操作电脑的远程程序(`win+R: mstsc`)，填写被远程的IP地址，然后点击“连接”

   ![网络连接详情](.\imagenote\网络连接详情.png)

## markdown的11种基本语法

1. 标题设置（让字体变大，和word的标题意思一样）

2. 块注释（blockquote）:通过在文字开头添加“>”表示块注释。

3. 斜体:将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来

4. 粗体.将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来

5. 无序列表。

   在文字开头添加(`*`, `+`, and `-`)实现无序列表。但是要注意在(`*`, `+`, and `-`)和文字之间需要添加空格。

   （建议：一个文档中只是用一种无序列表的表示方式）

6. 有序列表

   使用数字后面跟上句号。（还要有空格）

7. 链接（Links）。

   Markdown中有两种方式，实现链接，分别为内联方式和引用方式。
   `内联方式：This is an [example link](http://example.com/).`

   `引用方式：I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. `

   ` [1]: http://google.com/        "Google" ` 

   `[2]: http://search.yahoo.com/  "Yahoo Search" `

   `[3]: http://search.msn.com/    "MSN Search"`

8. 图片（Images）。

   图片的处理方式和链接的处理方式，非常的类似。
   `内联方式：``![alt text](/path/to/img.jpg "Title")`

   `引用方式：``![alt text][id] [id]: /path/to/img.jpg "Title"`

9. 代码（HTML中所谓的Code）。

   实现方式有两种：
   第一种：简单文字出现一个代码框。使用`<blockquote>`。（`不是单引号而是左上角的ESC下面~中的`）
   第二种：大片文字需要实现代码框。使用Tab和四个空格。

10. 脚注（footnote）。

  实现方式如下：

  hello[^hello]

[^hello]: hi

11. 下划线。在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题）



## java开发环境搭建完成

spring tool suite



tomcat v7.0 server at localhost

127.0.0.1:8080/bam





![富聪金融业务分析监控系统](.\imagenote\富聪金融业务分析监控系统.PNG)



![富聪金融业务分析监控系统2](.\imagenote\富聪金融业务分析监控系统2.PNG)

### ETL（ Extract-Transform-Load）

#### ETL是什么

ETL是Extract Transform Load三个英文单词的缩写 中文意思就是抽取、转换、加载。说到ETL就必须提到数据仓库。

#### 背景知识

信息是现代企业的重要资源，是企业运用科学管理、决策分析的基础。目前，大多数企业花费大量的资金和时间来构建**联机事务处理OLTP的业务系统**和办公自动化系统（例如电信行业的各种运营支撑系统、购物网站系统），用来记录事务处理的各种相关数据。据统计，数据量每2～3年时间就会成倍增长，这些数据蕴含着巨大的商业价值，而企业所关注的通常只占在总数据量的2%～4%左右。因此，企业仍然没有最大化地利用已存在的数据资源，以致于浪费了更多的时间和资金，也失去制定关键商业决策的最佳契机。

在这个背景下，能够给企业所有级别的决策制定过程提供支持的所有类型数据的战略集合应运而生，他就是**数据仓库**。数据仓库的英文简写是**Data Warehouse**。**数据仓库**就是把**OLTP系统**产生的数据 整合到一起 发掘其中的商业价值和提供决策支持用。**举个电信行业的例子** 电信有系统每天会有客户投诉的信息、宽带群体性障碍、客户号码的停机恢复时间记录等等。这些数据都在各自的生产环境系统里面。**他们每个月会把这些数据整合到一起处理加工到数据仓库里面形成报表** 其中有一个功能是可以对哪些用户有离网销号的倾向做出大概的判断。这就是数据仓库的价值所在。

> #### OLTP(On_line Transaction Processing联机事务处理)，OLAP(On_line Analytical Processing联机分析处理)
>
> OLTP：On_line Transaction Processing **联机事务处理** 
> OLAP：On_line Analytical Processing  **联机分析处理**
> OLTP 顾名思义，以业务处理为主。
>
> OLAP则是专门为支持复杂的分析操作而设计的，侧重于对决策人员和高层管理人员的决策支持，可以应分析人员的要求快速、灵活地进行[大数据](http://lib.csdn.net/base/hadoop)量的复杂查询处理，并以一直直观的形式把查询结果提供。
>
> OLTP与OLAP 的主要区别有以下几点：
>
> 1. 所面向的用户和系统：OLTP是面向**客户**的，由职员或客户进行事务处理或者查询处理。OLAp是向向**市场**的，由经理、主管和分析人员进行数据分析和决策的。
>
> 2. 数据内容：OLTP系统管理当前数据，这些数据通常很琐碎，难以用于决策。OLAP系统管理大量历史数据，提供汇总和聚集机制，并在不同的粒度级别上存储和管理信息，这些特点使得数据适合于决策分析。
>
> 3. [数据库](http://lib.csdn.net/base/mysql)设计：通常，OLTP采用ER模型和面向应用的数据库设计，而OLAP系统通常采用星型模式或雪花模式和面向主题的数据库设计。
>
> 4. 视图：OLTP系统主要关注一个企业或部门的当前数据，而不涉及历史数据或不同组织的数据。与之相反，OLAP系统常常跨越一个企业的数据库模式的多个版本，OLAP系统也处理来自不同组织的信息，由多个数据源集成的信息。
>
> 5. 访问模式：OLTP系统的访问主要由短的原子事务组成，这种系统需要并发控制和恢复机制。而OLAP系统的访问大部份是只读操作，其中大部份是复杂查询。
>
> 6. 度量：OLTP专注于日常时实操作，所以以事务吞吐量为度量，OLAP以查询吞吐量和响应时间来度量。
>
>    | --------------------- | ------------------------------------ | --------------------------------------------------- |
>    | --------------------- | :----------------------------------: | :--------------------------------------: |
>    |                       |                 OLTP                 |                   OLAP                   |
>    | 用户                    |             操作人员,低层管理人员              |               决策人员,高级管理人员                |
>    | 功能                    |                日常操作处理                |                   分析决策                   |
>    | DB 设计                 |                 面向应用                 |                   面向主题                   |
>    | 数据                    |         当前的, 最新的细节的, 二维的分立的          |          历史的, 聚集的, 多维的集成的, 统一的           |
>    | 存取                    |               读/写数十条记录               |                 读上百万条记录                  |
>    | 工作单位                  |                简单的事务                 |                  复杂的查询                   |
>    | 用户数                   |                 上千个                  |                   上百个                    |
>    | DB 大小                 |               100MB-GB               |                 100GB-TB                 |
>
>    | --------------------------------- | ----------------------------------- |
>    | :-------------------------------: | :---------------------------------: |
>    |              OLTP数据               |               OLAP数据                |
>    |               原始数据                |                导出数据                 |
>    |               细节性数据               |              综合性和提炼性数据              |
>    |               当前值数据               |                历史数据                 |
>    |                可更新                |             不可更新，但周期性刷新             |
>    |             一次处理的数据量小             |              一次处理的数据量大              |
>    |             面向应用，事务驱动             |              面向分析，分析驱动              |
>    |           面向操作人员，支持日常操作           |            面向决策人员，支持管理需要            |
>
>    ​

*那么怎么把数据弄到数据仓库里去呢，其中用道德一个技术就是ETL。*

#### 给下ETL的详细解释定义

ETL(Extract-Transform-Load的缩写，即数据抽取、转换、装载的过程)作为DW的核心和灵魂，能够按照统一的规则集成并提高数据的价值，是负责完成**数据从数据源向目标数据仓库转化的过程**，是实施数据仓库的重要步骤。如果说**数据仓库的模型设计是一座大厦的设计蓝图，数据是砖瓦的话，那么ETL就是建设大厦的过程。**在整个项目中最难部分是用户需求分析和模型设计，而ETL规则设计和实施则是工作量最大的，约占整个项目的60%～80%，这是国内外从众多实践中得到的普遍共识。
ETL是数据抽取（Extract）、清洗（Cleaning）、转换（Transform）、装载（Load）的过程。是构建数据仓库的重要一环，用户从数据源抽取出所需的数据，经过数据清洗,最终按照预先定义好的数据仓库模型，将数据加载到数据仓库中去。
于是，企业如何通过各种技术手段，并把数据转换为信息、知识，已经成了提高其核心竞争力的主要瓶颈。而ETL则是主要的一个技术手段。

做数据仓库系统，ETL是关键的一环。说大了，ETL是数据整合解决方案，说小了，就是倒数据的工具。

现在来说说**ETL技术用到的工具，常用的有Informatica、Datastage、Beeload、Kettle等**。目前只用过kettle，所以这里只对kettle做描述。

kettle是一款国外开源的ETL工具，纯[Java](http://lib.csdn.net/base/javase)编写，可以在Window、[Linux](http://lib.csdn.net/base/linux)、Unix上运行，kettle 3版本需要安装 3以上都是绿色版无需安装。

*提醒的是kettle运行 需要机器有JRE环境*

Kettle这个ETL工具集，它允许你管理来自不同[数据库](http://lib.csdn.net/base/mysql)的数据，通过提供一个图形化的用户环境来描述你想做什么。
Kettle中有两种脚本文件，transformation和job，transformation完成针对数据的基础转换，job则完成整个工作流的控制。

**商务智能（BI）**

不同的瞎子对大象的认识不同，因为他们只认识了自己摸到的地方。而企业如果要避免重犯这样的错误，那就离不开商务[智能](http://lib.csdn.net/base/aiplanning)（BI）。专家认为，BI对于企业的重要性就像聪明才智对于个人的重要性。欧美企业的经验也证明，企业避免无知和一知半解危险的有效手段就是商务智能。商务智能旨在充分利用企业在日常经营过程中收集的大量数据和资料，并将它们转化为信息和知识来免除各种无知状态和瞎猜行为。

确切地讲，BI并不是一项新技术，它将数据仓库(DW)、联机分析处理(OLAP)、数据挖掘(DM)等技术与客户关系管理（CRM）等结合起来应用于商业活动实际过程当中，实现了技术服务于决策的目的；Mark Hammond从管理的角度看待BI，认为BI是从“根本上帮助你把公司的运营数据转化成为高价值的可以获取的信息（或者知识），并且在恰当的时间通过恰当的手段把恰当的信息传递给恰当的人”。 

**ETL** 
ETL即数据抽取（Extract）、转换（Transform）、装载（Load）的过程。它是构建数据仓库的重要环节。数据仓库是面向主题的、集成的、稳定的且随时间不断变化的数据集合，用以支持经营管理中的决策制定过程。数据仓库系统中有可能存在着大量的噪声数据,引起的主要原因有：滥用缩写词、惯用语、数据输入错误、重复记录、丢失值、拼写变化等。即便是一个设计和规划良好的[数据库](http://lib.csdn.net/base/mysql)系统，如果其中存在着大量的噪声数据，那么这个系统也是没有任何意义的，因为“垃圾进，垃圾出”（garbage in, garbage out），系统根本就不可能为决策分析系统提供任何支持。为了清除噪声数据，必须在数据库系统中进行数据清洗。目前有不少数据清洗研究和ETL研究，但是如何在ETL过程中进行有效的数据清洗并使这个过程可视化，此方面研究不多。本文主要从两个方面阐述ETL和数据清洗的实现过程：ETL的处理方式[19]和数据清洗的实现方法。 

ETL，是英文Extract-Transform-Load的缩写，即填充、更新数据仓库的数据抽取、转换、装载的过程。这是实现[商业智能](http://www.chinabi.net/)之前的数据采集步骤。这一步骤完成之后，对库中数据的数据挖掘、分析处理才可以进行。

对于ETL而言，“是什么”是很容易理解的，也就是将分散的、不易利用的数据进行整理，变成规则清晰的、易于利用的、（可能同时还是）集中的数据。在ETL过程之外，就可以基于报表分析系统、多维分析系统和数据挖掘系统等，进行进一步的数据分析利用。

这一过程可以通过Hard Codding，即编写程序实现，也可以通过各种ETL工具实现。

当今的数据处理大致可以分成两大类：联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Processing）。OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。 
OLAP是使分析人员、管理人员或执行人员能够从多角度对信息进行快速、一致、交互地存取,从而获得对数据的更深入了解的一类软件技术。OLAP的目标是满足决策支持或者满足在多维环境下特定的查询和报表需求,它的技术核心是"维"这个概念。

@  BI 就是[智能](http://lib.csdn.net/base/aiplanning)决策分析工具。Power-BI 就是一个典型的例子。
@  TL分别是Extract（数据抽取）、 Transform（转换）、 Loading（装载）三个英文单词的首字母缩写。
@  线上分析处理（On-Line Analytical Processing,简称OLAP），是一套以多维度方式分析资料，而能弹性地提供积存(Roll-up)、下钻(Drill-down)、和枢纽分析(pivot)等操作，呈现整合性决策资讯的方法，多用于决策支持系统、商务智能或数据仓库。其主要的功能，在于方便大规模数据分析及统计计算，对决策提供参考和支持。与之相区别的是线上交易处理(OLTP)。

OLAP技术联机分析处理(OLAP)的概念最早是由关系数据库之父E.F.Codd于1993年提出的。当时，Codd认为联机事务处理(OLTP)已不能满足终端用户对数据库查询分析的需要，SQL对[大数据](http://lib.csdn.net/base/hadoop)库进行的简单查询也不能满足用户分析的需求。用户的决策分析需要对关系数据库进行大量计算才能得到结果，而查询的结果并不能满足决策者提出的需求。因此Codd提出了多维数据库和多维分析的概念，即OLAP。

#### 商业智能BI体系结构



![商业智能BI体系结构](.\imagenote\商业智能BI体系结构.jpg)

在此大概用口水话简单叙述一下他们几个概念：

（1）**DB/Database/数据库**——这里一般指的就是OLTP数据库，在线事物数据库，用来支持生产的，比如超市的买卖系统。DB保留的是数据信息的最新状态，只有一个状态！比如，每天早上起床洗脸照镜子，看到的就是当时的状态，至于之前的每天的状态，不会出现的你的眼前，这个眼前就是db。

（2）**DW/Data Warehouse/数据仓库**——这里保存的是DB中的不同时间点的状态，比如，每天早上洗完照镜子时，都拍一张照片，天天这样，这些照片放入到一个相册中，之后就可以查看每一天的状态了，这个相册就是数据仓库，他保存的是数据在不同时间点的状态，对同一个数据信息，保留不同时间点的状态，就便于我们做统计分析了。

（3）**ETL/Extraction-Transformation-Loading**——用于完成DB到DW的数据转存，它将DB中的某一个时间点的状态，“抽取”出来，根据DW的存储模型要求，“转换”一下数据格式，然后再“加载”到DW的一个过程，这里需要强调的是，DB的模型是ER模型，遵从范式化设计原则，而DW的数据模型是雪花型结构或者星型结构，用的是面向主题，面向问题的设计思路，所以DB和DW的模型结构不同，需要进行转换。 
（4）**OLAP——在线分析系统**，简单说就是报表系统，销售报表，统计报表，等等，这个大家都熟悉，当然，OLAP的统计要更复杂更丰富一些，比如切面，钻取等等。 
（5）**DM/Data Mining/数据挖掘**——这个挖掘，不是简单的统计了，他是根据概率论的或者其他的统计学原理，将DW中的大数据量进行分析，找出我们不能直观发现的规律，比如，如果我们每天早上照相，量身材的时候，还记录下头一天吃的东西，黄瓜，猪腿，烤鸭，以及心情，如果记录上10年，形成了3650天的相貌和饮食心情的数据，我们每个人都记录，有20万人记录了，那么，我们也许通过这些记录，可以分析出，身材相貌和饮食的客观规律；再说一个典型的实例，就是英国的超市，在积累了大量数据之后，对数据分析挖掘之后，得到了一个规律：将小孩的尿布和啤酒放在一起，销量会更好——业务专家在得到该结论之后，仔细分析，知道了原因，因为英国男人喜欢看足球的多，老婆把小孩介绍男人看管，小孩尿尿需要尿布，而男人看足球喜欢喝酒，所以两样商品有密切的关系，放在一起销售会更好！

（6）**BI/Business Intelligence/商业智能**——领导，决策者，在获取了OLAP的统计信息，和DM得到的科学规律之后，对生产进行适当的调整，比如，命令超市人员将啤酒喝尿布放在一起销售，这就反作用于DB修改存货数据了——这就是整个BI的作用！

信息技术经过近20年的大力发展，很多行业积累了很多珍贵的数据，真正的大数据时代到来了，也逐渐体现出 DB-ETL-DW-OLAP-DM-BI这条线路的重要性，希望大家能懂得这个大数据时代的价值，把握住机遇，有更加美好的未来！

### eclipse 查看原始类出现The jar file rt.jar has no source attachment

作为一名菜鸟，查看[Java](http://lib.csdn.net/base/javase) 源码非常重要。而在eclipse中查看一个类的源码是非常方便的，直接**按住 ctrl** + **鼠标点击的那个类或方法**，**那么这个类或方法的源码就会出现。**不过在此之前，需要先在eclipse中导入源码 src.zip.

这个源码src.zip不需要下载，只要你安装了jdk，那么在jdk安装的目录下就会有src.zip，无需解压，下面看一下怎么把源码导入eclipse中。

1.进入eclipse界面，依次点击 Window -- Preferences -- Java -- Installed JREs

![Eclipse_javasourcecode1](.\imagenote\Eclipse_javasourcecode1.png)

2.选中 D:\java\lib\rt.jar ，然后选择 Source Attachment

![Eclipse_javasourcecode2](.\imagenote\Eclipse_javasourcecode2.png)

3.选择 External location ，点击 External File 浏览安装jdk的目录，找到src.zip，一次点击ok，finish 即可

![](.\imagenote\Eclipse_javasourcecode3.png)



# 20170509

## 查看电脑硬件配置信息

DirectX诊断工具
win+R-->dxdiag
或者 计算机-->管理-->设备管理器

CPU-Z是一款家喻户晓的CPU检测软件，是检测CPU使用程度最高的一款软件，除了使用Intel或AMD自己的检测软件之外，我们平时使
用最多的此类软件就数它了。
CPU-Z is a freeware that gathers information on some of the main devices of your system.

SPD是内存模组上面的一个可擦写的ROM，里面记录了该内存的许多重要信息，诸如内存的芯片及模组厂商、工作频率、工作电压、速
度、容量、电压与行、列地址带宽等参数。SPD信息一般都是在出厂前，由内存模组制造商根据内存芯片的实际性能写入到ROM芯片中
。



## 用ETL组件实现和sql相比哪个效率高

我现在正在做BI相关的东西。如果ETL和SQL来说，肯定是SQL效率高的多。但是双方各有优势，

先说ETL，ETL主要面向的是建立数据仓库来使用的。ETL更偏向数据清洗，多数据源数据整合，获取增量，转换加载到数据仓库所使用的工具。比如我有两个数据源，一个是数据库的表，另外一个是excel数据，而我需要合并这两个数据，通常这种东西在SQL语句中比较难实现。但是ETL却有很多现成的组件和驱动，几个组件就搞定了。还有比如跨服务器，并且服务器之间不能建立连接的数据源，比如我们公司系统分为一期和二期，存放的数据库是不同的，数据结构也不相同，数据库之间也不能建立连接，这种情况下，ETL就显得尤为重要和突出。通过固定的抽取，转换，加载到数据仓库中，即可很容易。

那么SQL呢？SQL事实上只是固定的脚本语言，但是执行效率高，速度快。不过灵活性不高，很难跨服务器整合数据。所以SQL更适合在固定数据库中执行大范围的查询和数据更改，由于脚本语言可以随便编写，所以在固定数据库中能够实现的功能就相当强大，不像ETL中功能只能受组件限制，组件有什么功能，才能实现什么功能。

所以具体我们在什么时候使用ETL和SQL就很明显了，当我们需要多数据源整合建立数据仓库，并进行数据分析的时候，我们使用ETL。如果是固定单一数据库的数据层次处理，我们就使用SQL。当然，ETL也是离不开SQL的。

## elasticsearch

ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于[云计算](http://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97)中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。



## ETL的实现

ETL的实现有多种方法，常用的有三种。一种是借助ETL工具（如Oracle的 OWB、SQLServer2000的DTS、SQLServer2005的SSIS服务、Informatic等）实现，一种是SQL方式实现，另外一种是ETL工具和SQL相结合。前两种方法各有各的优缺点，借助工具可以快速的建立起ETL工程，屏蔽了复杂的编码任务，提高了速度，降低了难度，但是缺少灵活性。SQL的方法优点是灵活，提高ETL运行效率，但是编码复杂，对技术要求比较高。第三种是综合了前面二种的优点，会极大地提高ETL的开发速度和效率。

通过ETL，我们可以基于源系统中的数据来生成数据仓库。ETL为我们搭建了OLTP系统和OLAP系统之间的桥梁，是数据从源系统流入数据仓库的通道。在数据仓库的项目实施中，它关系到整个项目的数据质量，所以马虎不得，必须将其摆到重要位置，将数据仓库这一大厦的根基筑牢!

ETL的设计分三部分：数据抽取、数据的清洗转换、数据的加载。

在设计ETL的时候我们也是从这三部分出发。

**数据的抽取**是**从各个不同的数据源抽取到ODS（OperationalDataStore，操作型数据存储） 中**——这个过程也可以做一些数据的清洗和转换），在抽取的过程中需要挑选不同的抽取方法，尽可能的提高ETL的运行效率。ETL三个部分中，花费时间最长的是“T”（Transform，清洗、转换）的部分，一般情况下这部分工作量是整个ETL的2/3。数据的加载一般在数据清洗完了之后直接写入DW （DataWarehousing，数据仓库）中去。

ETL的实现有多种方法，常用的有三种。

1. 一种是借助ETL工具（如Oracle的 OWB、SQLServer2000的DTS、SQLServer2005的SSIS服务、Informatic等）实现，
2. 一种是SQL方式实现，
3. 另外一种是ETL工具和SQL相结合。

前两种方法各有各的优缺点，借助工具可以快速的建立起ETL工程，屏蔽了复杂的编码任务，提高了速度，降低了难度，但是缺少灵活性。SQL的方法优点是灵活，提高ETL运行效率，但是编码复杂，对技术要求比较高。第三种是综合了前面二种的优点，会极大地提高ETL的开发速度和效率。



数据抽取（Extract）、转换（Transform）、装载（Load）的过程，它是构建数据仓库的重要环节。







### 一，数据抽取(Extract)

这一部分需要在调研阶段做大量的工作，首先要搞清楚**数据是从几个业务系统中来**,**各个业务系统的数据库服务器运行什么DBMS**，**是否存在手工数据，手工数据量有多大****，**是否存在非结构化的数据等等**，当收集完这些信息之后才可以进行数据抽取的设计。

　　1、对于**与存放DW的数据库系统相同的数据源**处理方法

　　这一类数据源在设计上比较容易。一般情况下，DBMS（SQLServer、Oracle）都会提供**数据库链接功能**，在DW数据库服务器和原业务系统之间建立直接的链接关系就可以写Select语句直接访问。

　　2、对于**与DW数据库系统不同的数据源**的处理方法

　　对于这一类数据源，一般情况下也可以通过ODBC的方式建立数据库链接——如 SQLServer和Oracle之间。**如果不能建立数据库链接，可以有两种方式完成**，**一种是**通过工具将源数据导出成.txt或者是.xls文件，然后再将这些源系统文件导入到ODS中。另外一种方法是通过程序接口来完成。

> 操作数据存储ODS（Operational Data Store）是数据仓库体系结构中的一个可选部分，ODS具备数据仓库的部分特征和[OLTP](http://baike.baidu.com/item/OLTP)系统的部分特征，它是“面向主题的、集成的、当前或接近当前的、不断变化的”数据。是一个面向主题的、集成的、可变的、当前的细节数据集合，用于支持企业对于即时性的、操作性的、集成的全体信息的需求。
>
> ods是短期的实时的数据，供产品或者运营人员日常使用，而数据仓库是供战略决策使用的数据；ods是可以更新的数据，数据仓库是基本不更新的反应历史变化的数据，还有很多，这里就不一一列举了。
>
> 如何能搭建一个体系，既能支持战略决策使用的数据仓库数据，又能兼容业务快速的变化和运营产品人员日常需求的ODS数据哪？
>
> 经过调研，发现大体上有三种解法：
>
> 1、业务数据 － ODS － 数据仓库
>
> ![ODS_DW](.\imagenote\ODS_DW.png)
>
> 优点：这样做的好处是ODS的数据与数据仓库的数据高度统一；开发成本低，至少开发一次并应用到ODS即可；可见ODS是发挥承上启下的作用，调研阿里巴巴的数据部门也是这么实现的。缺点：数据仓库需要的所有数据都需要走ODS，那么ODS的灵活性必然受到影响，甚至不利于扩展、系统的灵活性差.
>
> 2、OB － ODS
>
> 优点：结构简单。一般的初创数据分析团队都是类似的结构，比如我们部门就应该归结到这一范畴
>
> 缺点：这样所有数据都归结到ODS，长期数据决策分析能力差，软硬件成本高，模块划分不清晰，通用性差
>
> 3、数据仓库和ODS并行
>
> 可见这个模型兼顾了上面提高的各自优点，且便于扩展，ODS和数据仓库各做各的，形成优势互补！可以解决现在互联网公司遇到的快速变化、快速开发等特点！特别是对于那些刚刚创建数据团队，数据开发人员紧缺的公司，可以尝试使用这个数据架构解决问题！
>
> ![](.\imagenote\ODS_DW2.png)



　　3、对于文件类型数据源（.txt,.xls），可以培训业务人员利用数据库工具将这些数据导入到指定的数据库，然后从指定的数据库中抽取。或者还可以借助工具实现，如SQLServer2005的SSIS服务的平面数据源和平面目标等组件导入ODS中去。

　　4、增量更新的问题

　　对于数据量大的系统，必须考虑增量抽取。一般情况下，业务系统会记录业务发生的时间，我们可以用来做增量的标志,每次抽取之前首先判断ODS中记录最大的时间，然后根据这个时间去业务系统取大于这个时间所有的记录。利用业务系统的时间戳，一般情况下，业务系统没有或者部分有时间戳。

### 二、数据的清洗转换

　　一般情况下，数据仓库分为ODS、DW两部分。通常的做法是从业务系统到ODS做清洗，将脏数据和不完整数据过滤掉，在从ODS到DW的过程中转换，进行一些业务规则的计算和聚合。

1、数据清洗

　　数据清洗的任务是过滤那些不符合要求的数据，将过滤的结果交给业务主管部门，确认是否过滤掉还是由业务单位修正之后再进行抽取。不符合要求的数据主要是有不完整的数据、错误的数据、重复的数据三大类。

　　（1）不完整的数据：这一类数据主要是一些应该有的信息缺失，如供应商的名称、分公司的名称、客户的区域信息缺失、业务系统中主表与明细表不能匹配等。对于这一类数据过滤出来，按缺失的内容分别写入不同Excel文件向客户提交，要求在规定的时间内补全。补全后才写入数据仓库。

　　（2）错误的数据：这一类错误产生的原因是业务系统不够健全，在接收输入后没有进行判断直接写入后台数据库造成的，比如数值数据输成全角数字字符、字符串数据后面有一个回车操作、日期格式不正确、日期越界等。这一类数据也要分类，对于类似于全角字符、数据前后有不可见字符的问题，只能通过写SQL语句的方式找出来，然后要求客户在业务系统修正之后抽取。日期格式不正确的或者是日期越界的这一类错误会导致ETL运行失败，这一类错误需要去业务系统数据库用SQL的方式挑出来，交给业务主管部门要求限期修正，修正之后再抽取。

　　（3）重复的数据：对于这一类数据——特别是维表中会出现这种情况——将重复数据记录的所有字段导出来，让客户确认并整理。

　　数据清洗是一个反复的过程，不可能在几天内完成，只有不断的发现问题，解决问题。对于是否过滤，是否修正一般要求客户确认，对于过滤掉的数据，写入Excel文件或者将过滤数据写入数据表，在ETL开发的初期可以每天向业务单位发送过滤数据的邮件，促使他们尽快地修正错误,同时也可以做为将来验证数据的依据。数据清洗需要注意的是不要将有用的数据过滤掉，对于每个过滤规则认真进行验证，并要用户确认。

2、数据转换

　　数据转换的任务主要进行不一致的数据转换、数据粒度的转换，以及一些商务规则的计算。

　　（1）不一致数据转换：这个过程是一个整合的过程，将不同业务系统的相同类型的数据统一，比如同一个供应商在结算系统的编码是XX0001,而在CRM中编码是YY0001，这样在抽取过来之后统一转换成一个编码。

　　（2）数据粒度的转换：业务系统一般存储非常明细的数据，而数据仓库中数据是用来分析的，不需要非常明细的数据。一般情况下，会将业务系统数据按照数据仓库粒度进行聚合。

　　（3）商务规则的计算：不同的企业有不同的业务规则、不同的数据指标，这些指标有的时候不是简单的加加减减就能完成，这个时候需要在ETL中将这些数据指标计算好了之后存储在数据仓库中，以供分析使用。



## 网易金融业务分析监控系统sql

navicat是测试数据库

https://www.fc18.com.cn/bam/Baf/BafSqlCommand是生产库

navicat不加分号`；`也可以运行

但是生产库必须要加上分号`；`

`select client.oid,IdNumber from client where IdNumber REGEXP '371323199.*';`



# 20170510



`INNER JOIN`     等价于   `JOIN`
你可以理解为  `JOIN` 　　是  `INNER JOIN`   的缩写。
`LEFT JOIN`  等价于   `LEFT  OUTER   JOIN`
`RIGHT JOIN`  等价于   `RIGHT OUTER   JOIN`

## sql例子-www.fc18.com.cn/bam/Baf/BafSqlCommand

> 注册时间超过3个月 并且 历史投资金额累计超过5万或者现金存款仍大于一万客户名单（姓名，手机号，客户ID）
>

`SELECT c.oid,c.FirstName,sum(ac.CurrentBalance),sum(ar.TransAmount)`
`FROM 	client c`
`JOIN agreement ag ON ag.ClientId = c.oid and ag.AgreementLevel ='Root' and ag.ProductCategoryCode not in ('TYJ','JXQ')`
`JOIN account ac ON ac.AgreementId = ag.oid`
`JOIN agreementrequest ar ON ar.AgreementId = ag.oid AND ar.TransType IN ('Deposit', 'AddDeposit') and ar.TransStatus ='Active'`
`WHERE CURRENT_DATE - date(c.createdOn) >100` 
`GROUP BY c.oid HAVING (sum(ac.CurrentBalance)>=10000) OR (sum(ar.TransAmount)>=50000)` 
`ORDER BY sum(ar.TransAmount);`





## sql语句顺序



SQL 不同于与其他编程语言的最明显特征是处理代码的顺序。在大数编程语言中，代码按编码顺序被处理，但是在SQL语言中，第一个被处理的子句是FROM子句，尽管SELECT语句第一个出现，但是几乎总是最后被处理。

每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者（客户端应用程序或者外部查询）不可用。只是最后一步生成的表才会返回 给调用者。如果没有在查询中指定某一子句，将跳过相应的步骤。

select子句及其顺序**

| 子句       | 说明        | 是否必须使用      |
| -------- | --------- | ----------- |
| select   | 要返回的列或表达式 | 是           |
| from     | 从中检索数据的表  | 仅在从表选择数据时使用 |
| where    | 行级过滤      | 否           |
| group by | 分组说明      | 仅在按组计算聚集时使用 |
| having   | 组级过滤      | 否           |
| order by | 输出排序顺序    | 否           |
| limit    | 要检索的行数    | 否           |
|          |           |             |





> `(8)SELECT (9)DISTINCT  (11)<Top Num> <select list>`
> `(1)FROM [left_table]`
> `(3)<join_type> JOIN <right_table>`
> `(2)ON <join_condition>`
> `(4)WHERE <where_condition>`
> `(5)GROUP BY <group_by_list>`
> `(6)WITH <CUBE | RollUP>`
> `(7)HAVING <having_condition>`
> `(10)ORDER BY <order_by_list>`



**逻辑查询处理阶段简介**

1. **FROM：**对FROM子句中的前两个表执行笛卡尔积（Cartesian product)(交叉联接），生成虚拟表VT1
2. **ON：**对VT1应用ON筛选器。只有那些使<join_condition>为真的行才被插入VT2。
3. **OUTER(JOIN)：**如 果指定了OUTER JOIN（相对于CROSS JOIN 或(INNER JOIN),保留表（preserved table：左外部联接把左表标记为保留表，右外部联接把右表标记为保留表，完全外部联接把两个表都标记为保留表）中未找到匹配的行将作为外部行添加到 VT2,生成VT3.如果FROM子句包含两个以上的表，则对上一个联接生成的结果表和下一个表重复执行步骤1到步骤3，直到处理完所有的表为止。
4. **WHERE：**对VT3应用WHERE筛选器。只有使<where_condition>为true的行才被插入VT4.
5. **GROUP BY：**按GROUP BY子句中的列列表对VT4中的行分组，生成VT5.
6. **CUBE|ROLLUP：**把超组(Suppergroups)插入VT5,生成VT6.
7. **HAVING：**对VT6应用HAVING筛选器。只有使<having_condition>为true的组才会被插入VT7.
8. **SELECT：**处理SELECT列表，产生VT8.
9. **DISTINCT：**将重复的行从VT8中移除，产生VT9.
10. **ORDER BY：**将VT9中的行按ORDER BY 子句中的列列表排序，生成游标（VC10).
11. **TOP：**从VC10的开始处选择指定数量或比例的行，生成表VT11,并返回调用者。



# 20170511



sourcetree：命令行模式，是 sourcetree本身的git，不是 gitbash那个



git账户:shidexiao sswsdx@163.com



sourcetree: 武刚建了分支，我需要先从远程 origin找到 分支 检出（checkout），然后获取分支。



maven：Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。

Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。

spring tool suite:

JAR包：jar包就是别人已经**写好的一些类**，然后**将这些类进行打包**，你可以**将这些jar包引入你的项目中**，然后就可以**直接使用这些jar包中的类和属性以及方法**。
**JAR（Java ARchive）**是**将一系列文件合并到单个压缩文件里，就象Zip那样**。然而，同Java中其他任何东西一样，JAR文件是跨平台的，所以不必关心涉及具体平台的问题。

涉及因特网应用时，JAR文件显得特别有用。在JAR文件之前，Web浏览器必须重复多次请求Web服务器，以便下载完构成一个“程序片”（Applet）的所有文件。除此以外，每个文件都是未经压缩的。但在将所有这些文件合并到一个JAR文件里以后，只需向远程服务器发出一次请求即可。同时，由于采用了压缩技术，所以可在更短的时间里获得全部数据。



# 20170512



内网IP地址 192.~.~.~

公司内网需要使用vpn

艳茹的IP地址是193.168.1.9

内网IP地址只是内部使用，其他内网可能也有相同的IP地址。

外网IP地址

我的公网IP地址（百度到的）58.247.2.58

内网IP地址：192.168.1.206

ping一下




## java变量：成员变量、类变量、局部变量

变量名首字母使用小写，如果由多个单词组成，从第2个单词开始的其他单词的首字母使用大写。

如果局部变量的名字和成员变量的名字相同，要想在该方法中使用成员变量，必须使用关键字`this`

source-->add block comment :ctrl+shift+/

source-->remove block comment: ctrl+shift+/







## 内网IP、外网IP

内网IP地址、外网IP地址这个概念并不是固定的，而是相对的。如果用私有IP、公网IP或者局域网IP、互联网IP来理解就容易多了。

Address Block                    Name                              RFC                       
0.0.0.0/8                        "This host on this network"       [RFC1122], section 3.2.1.3
10.0.0.0/8                       Private-Use                       [RFC1918]                 
100.64.0.0/10                    Shared Address Space              [RFC6598]                 
127.0.0.0/8                      Loopback                          [RFC1122], section 3.2.1.3
169.254.0.0/16                   Link Local                        [RFC3927]                 
172.16.0.0/12                    Private-Use                       [RFC1918]                 
192.0.0.0/24[2]                  IETF Protocol Assignments         [RFC6890], section 2.1    
192.0.0.0/29                     IPv4 Service Continuity Prefix    [RFC7335]                 
192.0.0.8/32                     IPv4 dummy address                [RFC7600]                 
192.0.0.9/32                     Port Control Protocol Anycast     [RFC-ietf-pcp-anycast-08] 
192.0.0.170/32, 192.0.0.171/32   NAT64/DNS64 Discovery             [RFC7050], section 2.2    
192.0.2.0/24                     Documentation (TEST-NET-1)        [RFC5737]                 
192.31.196.0/24                  AS112-v4                          [RFC7535]                 
192.52.193.0/24                  AMT                               [RFC7450]                 
192.88.99.0/24                   Deprecated (6to4 Relay Anycast)   [RFC7526]                
192.168.0.0/16                   Private-Use                       [RFC1918]                 
192.175.48.0/24                  Direct Delegation AS112 Service   [RFC7534]                 
198.18.0.0/15                    Benchmarking                      [RFC2544]                 
198.51.100.0/24                  Documentation (TEST-NET-2)        [RFC5737]                 
203.0.113.0/24                   Documentation (TEST-NET-3)        [RFC5737]                 
240.0.0.0/4                      Reserved                          [RFC1112], section 4      
255.255.255.255/32               Limited Broadcast                 [RFC919], section 7 

如上表，运营商给你的100.64.*.*也是私有地址（因为地主家也没有余量啊，以前大家大家共享一个地址池，有随机的公网地址，现在公网地址更加紧张，运营商只给客户分配私网地址，然后nat后大家共享一个公网地址），《盗梦空间》看过吧，二重梦境，你用路由器上网也就是二重局域网。也就是说：如果内网、外网是指**私有地址与公网地址的话，那么100.64.0.30和192.168.1.101都是内网IP**，你没有外网IP。如果内网、外网是**相对你路由器来讲，那么100.64.0.30是外网IP，192.168.1.101是内网IP**。

问题1：不用家庭路由器，直接电脑分配到100.64.0.30，那么理论上100.64.0.1-100.64.0.254的确可以直接通讯，无需运营商路由。但实际上是通过各种技术做了隔离的。你无法访问他们。

问题2：因为你路由器获取的地址仍然是私网地址，所以你在外部连路由器都无法访问。除非在运营商的设备上做端口映射才能访问到路由器。



## FC ORM API用户手册

随着公司业务增长的和产品开发迭代的需求，现有的api和数据库架构需要迁移到适应水平分库的架构中来。新的ORM API实现的分库的访问，需要开发人员在后续的开发中掌握和使用。

> 对象关系映射（object relation mapping，简称ORM）是一种程序技术，用于实现**面向对象编程语言**里**不同类型系统的数据之间的转换**。
>
> 面向对象是从软件工程基本原则（如耦合、聚合、封装）的基础上发展起来的，
>
>       内聚（本题的聚合）：内聚是指一个模块内部各个部分之间的关联程度
>       耦合：耦合指各个模块之前的关联程度      
>       封装原则：隐藏对象的属性和实现细节，仅对外公开借口，并且控制访问级别
>       在面向对象方法中，用类来实现上面的要求。用类实现封装，用封装来实现高内聚，低耦合。
> 而关系数据库则是从数学理论发展而来的，
>
> > **高内聚低耦合**：其实就是为了更好的代码重用。把握好代码重用这关就好了，其它的概念都是扯淡











# 20170515



`<span>` 在CSS定义中属于一个行内元素,在行内定义一个区域，也就是一行内可以被` <span>` 划分成好几个区域，从而实现某种特定效果。

` <span> `本身没有任何属性。

` <div> `在CSS定义中属于一个块级元素 `<div>` 可以包含段落、标题、表格甚至其它部分。这使DIV便于建立不同集成的类，如章节、摘要或备注。

在页面效果上，使用` <div> `会自动换行，使用 `<span>` 就会保持同行。

span是行内元素；div是块级元素；他们都是容器！

> <p><span>some text.</span>some other text.</p>
> p.tip span {
> font-weight:bold;
> color:#ff9955;
> }
> <p class="tip"><span>提示：</span>... ... ...</p>



使用 <span> 元素对文本中的一部分进行着色：

<p>我的母亲有 <span style="color:blue">蓝色</span> 的眼睛。</p>

## 三层架构

三层架构(3-tier architecture) 通常意义上的三层架构就是将整个业务应用划分为：

1. 界面层（User Interface layer）、
2. 业务逻辑层（Business Logic Layer）、
3. 数据访问层（Data access layer）。



1. 数据访问层：有时候也称为是**持久层**，其功能主要是**负责数据库的访问**，可以访问数据库系统、二进制文件、文本文档或是XML文档。主要看数据层里面有没有包含逻辑处理，实际上它的各个函数主要完成各个对数据文件的操作。而不必管其他操作。
2. 业务逻辑层：它的关注点主要集中在业务规则的制定、业务流程的实现等与业务需求有关的系统设计，也即是说它是与系统所应对的领域（Domain）逻辑有关，很多时候，也将业务逻辑层称为**领域层**。主要负责对数据层的操作。也就是说把一些数据层的操作进行组合。
3. 表示层：主要对用户的请求接受，以及数据的返回，为客户端提供应用程序的访问。

区分层次的目的即为了**高内聚低耦合**的思想。

在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。

微软推荐的分层式结构一般分为三层，从下至上分别为：**数据访问层、业务逻辑层（又或称为领域层）、表示层**。

![](.\imagenote\三层架构.jpg)

![](.\imagenote\三层架构2.jpg)

**持久层Persistence**

持久层只是一个逻辑概念而已，主要任务是负责把数据保存起来，一般是指保存至数据库或者文件，也可以负责完成与之相关的行为。

持久层指的是把数据长期保存起来，如数据库把数据长期保存在硬盘里，XML也可以长期保存数据，还有如果把数据存放到指定文件中，也可以成为持久层。

持久化可以理解为动词。Java中的**Hibernate**做的就是持久化的操作，主要是对数据库底层的OR映射，这样我们就不必关心讨厌的关系映射了，直接操作对象就可以了。

**DAL  Data Access Layer，数据访问层**

**DAL**是三层架构(表现层，业务逻辑层，数据访问层)中的数据访问层，是一个概念或者说是一个方案，它由许多**DAO**(**DAO data access object，数据访问对象**)组成，或者说由**DAO**具体实现，是把和数据库相关的代码封装起来，这样当我们执行分库时，便只用调整**DAO**的代码了，模型根本不用关心它使用的数据是放在A库还是B库。

设计数据访问层接口的目的是让业务逻辑层不去调用具体的数据访问层的实现（不依赖于数据访问层具体的实现技术），这样的好处是，业务逻辑不必管数据访问层具体是什么技术来实现的，接口是不变的。

业务逻辑不必管数据访问层具体是什么技术来实现的，接口是不变的，数据访问层可以用jdbc来实现，也可以用hibernate来实现，而且更换起来不是非常麻烦，这样耦合就降低了.

**DAO data access object，数据访问对象**

**DAO**是一个软件设计的指导原则，在核心[J2EE](http://baike.baidu.com/view/1507.htm)模式中是这样介绍**DAO**模式的：为了建立一个健壮的J2EE应用，应该将所有对数据源的访问操作抽象封装在一个公共API中。用程序设计的语言来说，就是建立一个接口，接口中定义了此[应用程序](http://baike.baidu.com/view/330120.htm)中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口在逻辑上对应这个特定的数据存储。

顾名思义就是与数据库打交道，夹在业务逻辑与数据库资源中间，是**DAL**的具体实现。

简单的说 **dao**层 就是对数据库中数据的增删改查等操作封装在专门的类里面，在业务逻辑层中如果要访问数据的时候，直接调用该**dao**类（包括了如何访问数据库和数据的增删改查等等代码），就可以返回数据，而不需要再在业务逻辑层中写这些代码。



## MVC架构

MVC（模型Model-视图View-控制器Controller）是一种架构模式，可以用它来创建在域对象和UI表示层对象之间的区分。

同样是架构级别的，相同的地方在于他们都有一个表现层，但是他们不同的地方在于其他的两个层。

在三层架构中没有定义Controller的概念。这是最不同的地方。而MVC也没有把业务的逻辑访问看成两个层，这是采用三层架构或MVC搭建程序最主要的区别。当然了。在三层中也提到了Model，但是三层架构中Model的概念与MVC中Model的概念是不一样的，“三层”中典型的Model层是以实体类构成的，而MVC里，则是由业务逻辑与访问数据组成的。

![](.\imagenote\MVC1.jpg)

![](.\imagenote\MVC2.jpg)

**模型 Model**

模型是MVC中的概念，指的是读取数据和改变数据的操作（业务逻辑）。一开始我们直接把和数据库相关的代码放在模型里(sql直接写在代码中)，这样就会导致以后的维护相当麻烦。业务逻辑的修改都需要开发者重新写sql，如果项目需要分库，需要将sql语句抽出来，放到单独的一层。这一层就是**DAL**(数据访问层Data Access Layer)。









## ORM框架



ORM也是一种对数据库访问的封装，然而ORM不像**DAO**(data access object，数据访问对象)只是一种软件设计的指导原则，强调的是系统应该层次分明，更像是一种工具，有着成熟的产品，比如JAVA界非常有名的**Hibernate**，以及很多PHP框架里自带的ORM库。他们的好处在于能将你程序中的数据对象自动地转化为关系型数据库中对应的表和列，数据对象间的引用也可以通过这个工具转化为表之间的JOIN。使用ORM的好处就是使得你的开发几乎不用接触到SQL语句。创建一张表，声明一个对应的类，然后你就只用和这个类的实例进行交互了，至于这个对象里的数据该怎么存储又该怎么获取，通通不用关心。

![](.\imagenote\ORM.jpg)

**Hibernate**是全自动ORM框架，而**Mybatis**是半自动的。

1. hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。
2. 而mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理..

hibernate数据库移植性远大于mybatis。 hibernate通过它强大的映射结构和hql语言，大大降低了对象与数据库（oracle、mysql等）的耦合性，而mybatis由于需要手写sql，因此与数据库的耦合性直接取决于[程序](http://www.xuebuyuan.com/)员写sql的方法，如果sql不具通用性而用了很多某数据库特性的sql语句的话，移植性也会随之降低很多，成本很高。

系统数据处理量巨大，性能要求极为苛刻，这往往意味着我们必须通过经过高度优化的sql语句（或存储过程）才能达到系统性能设计指标，在这种情况下Mybatis会有更好的可控性和表现，可以进行细粒度的优化。





## DUBBO

DUBBO是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，是阿里巴巴SOA服务化治理方案的核心框架，每天为2,000+个服务提供3,000,000,000+次访问量支持，并被广泛应用于阿里巴巴集团的各成员站点。

随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。

![](.\imagenote\dubbo-architecture-roadmap.jpg)

- 单一应用架构
  - 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。
  - 此时，用于简化增删改查工作量的 **数据访问框架(ORM)** 是关键。
- 垂直应用架构
  - 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。
  - 此时，用于加速前端页面开发的 **Web框架(MVC)** 是关键。
- 分布式服务架构
  - 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。
  - 此时，用于提高业务复用及整合的 **分布式服务框架(RPC)** 是关键。
- 流动计算架构
  - 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。
  - 此时，用于提高机器利用率的 **资源调度和治理中心(SOA)** 是关键。





# 20170516

### 基本语法

#### java三目运算符---条件运算符（?:）

条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。

**variable x = (expression) ? value if true : value if false**

> variable x = (expression) ? value if true : value if false
>
> 这里expression是判断语句（例如：null==sobject）
>
> public class Test {
>    public static void main(String args[]){
> ​      int a , b;
> ​      a = 10;
> ​      // 如果 a 等于 1 成立，则设置 b 为 20，否则为 30
> ​      b = (a == 1) ? 20 : 30;
> ​      System.out.println( "Value of b is : " +  b );
>
> ​      // 如果 a 等于 10 成立，则设置 b 为 20，否则为 30
> ​      b = (a == 10) ? 20 : 30;
> ​      System.out.println( "Value of b is : " + b );
>    }
> }



#### 编写Java程序时，应注意以下几点：

- **大小写敏感**：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。
- **类名**：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。
- **方法名**：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。
- **源文件名**：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。
- **主方法入口**：所有的Java 程序由**public static void main(String []args)**方法开始执行。

#### Java 对象和类

Java作为一种面向对象语言。支持以下基本概念：

- 多态
- 继承
- 封装
- 抽象
- 类
- 对象
- 实例
- 方法
- 重载

#### 构造方法

##### java的构造函数其实很简单。
一个类 被实例化 也就是被new的时候 最先执行的是 构造函数，如果你有留心。你会发现很多类里面根本没有写构造函数。
在java类中，如果不显示声明构造函数，JVM 会给该类一个默认的构造函数。
一个类 可以有多个构造函数。
构造函数的主要作用
	一是用来实例化该类。
	二是 让该类实例化的时候执行哪些方法，初始化哪些属性。
当一个类声明了构造函数以后，JVM 是不会再给该类分配默认的构造函数。
比如一个实体类
	public class entity{
	  	private int id;
	  	private String userName;
	  	get...set..方法
	}
如果这样写该类就是默认的构造函数。该类实例化的时候 id 和 username 就是默认值 即 id=0,username=null.
如果在里面加入这样一个方法
	public entity(int id,String userName){
	 	调用get..set..
	}
如果这样写 该类实例化的时候 必须给出 id  和username参数。 JVM不会再给这个类默认构造函数
你也可以理解成 在没有给构造函数的时候 JVM 给你的类加了一个这样的函数
    public entity(){
    	this.id=0;
    	this.userName=null;
    }
其实构造函数是用来对一个类以及变量进行实例化。
##### 一个简单的类，一共有四个构造方法
构造方法，在new对象的时候就会自己调用，也是对象的初始方法，如果你自己不写构造方法默认的会自动加上一个无参的构造。如果不存在构造方法那也就创建不了类的实例。
    public class Test {
    private String name;
    private String sex;
    private String age;
    public Test(){
    super();
    }
    public Test(String name){
    this.name=name;
    }
    public Test(String name,String sex){
    this.name=name;
    this.sex=sex;
    }
    public Test(String name,String sex,String age){
    this.name=name;
    this.sex=sex;
    this.age=age;
    }
    }
上面写了一个简单的类，一共有四个构造方法，这样你就有四种方法构造类实例（对象）
    new Test();
    new Test("张三");
    new Test("张三","男");
    new Test("张三","男","16");
有了构造，也就相应提供了初始方法

##### 每个类都有构造方法。
每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。
在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。
> `public class Puppy{`
> ​    public Puppy(){
> ​    }
>
> ​    public Puppy(String name){
> ​        // 这个构造器仅有一个参数：name
> ​    }
> `}`

#### java语法--java修饰符
##### 访问控制修饰符
Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java支持4种不同的访问权限。
1. 默认的，也称为 **default**，在同一包内可见，不使用任何修饰符。
2. 私有的，以 **private** 修饰符指定，在同一类内可见。
3. 共有的，以 **public** 修饰符指定，对所有类可见。
4. 受保护的，以 **protected** 修饰符指定，对同一包内的类和所有子类可见。

##### 非访问修饰符

为了实现一些其他的功能，Java 也提供了许多非访问修饰符。

1. static 修饰符，用来创建类方法和类变量。
   **静态变量：**
   static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。
   静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。
   **静态方法：**
   static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。
2. final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。final用于常量的声明，规范要求常量的变量名是大写的。
   **final 变量：**
   final 变量能被显式地初始化并且只能初始化一次。
   **final 方法：**
   类中的 final 方法可以被子类继承，但是不能被子类修改。
   **final 类：**
   final 类不能被继承，没有类能够继承 final 类的任何特性。
3. abstract 修饰符，用来创建抽象类和抽象方法。
4. synchronized 和 volatile 修饰符，主要用于线程的编程。
#### java语法--java变量类型
Java语言支持的变量类型有：
成员变量：类变量、实例变量
- 类变量：（也称为静态变量）独立于方法之外的变量，用 static 修饰。
- 实例变量：（也称为成员变量）独立于方法之外的变量，不过没有 static 修饰。
- 局部变量：类的方法中的变量。

> `package com.test;`
> `//LOL里面的英雄类`
> `public class Hero {`
> ​	`int age;//成员变量`
> ​	`String name;//成员变量`
> ​	`static int age1;//类变量（静态变量）`
> ​	`static String name2;//类变量（静态变量）`
> ​	`public void run(){`
> ​		`String name3;//局部变量`
> ​		`int age3;//局部变量`
> ​	`}`
> `}`



### Java面向对象

我们可以把JAVA中的类分为以下三种：
- 类：使用class定义且不含有抽象方法的类。
- 抽象类：使用abstract class定义的类，它可以含有，也可以不含有抽象方法。
- 接口：使用interface定义的类。
  继承规律
- 类可以继承（extends）类，可以继承（extends）抽象类，可以继承（implements）接口。
- 抽象类可以继承（extends）类，可以继承（extends）抽象类，可以继承（implements）接口。
- 接口只能继承（extends）接口。
  一个普通类继承一个接口后，必须实现这个接口中定义的所有方法，否则就只能被定义为抽象类。
  我在这里之所以没有对implements关键字使用“实现”这种说法是因为从概念上来说它也是表示一种继承关系，而且**对于抽象类implements接口**的情况下，它并不是一定要实现这个接口定义的任何方法，因此使用继承的说法更为合理一些。
- 类和抽象类都只能最多继承一个类，或者最多继承一个抽象类，并且这两种情况是互斥的，也就是说它们要么继承一个类，要么继承一个抽象类。
- 类、抽象类和接口在继承接口时，不受数量的约束，理论上可以继承无限多个接口。当然，对于类来说，它必须实现**它所继承的所有接口**中定义的全部方法。
- 抽象类继承抽象类，或者实现接口时，可以部分、全部或者完全不实现父类抽象类的抽象（abstract）方法，或者父类接口中定义的接口。
- 类继承抽象类，或者实现接口时，必须全部实现父类抽象类的全部抽象（abstract）方法，或者父类接口中定义的全部接口。
#### Java继承（inheritance）

简单的说，继承就是在一个现有类型的基础上，通过**增加新的方法或者重定义已有方法**（下面会讲到，这种方式叫重写）的方式，产生一个新的类型。
继承是面向对象的三个基本特征--**封装、继承、多态**的其中之一，我们在使用JAVA时编写的每一个类都是在继承，
因为在JAVA语言中，**java.lang.Object类**是所有类最根本的基类（或者叫父类、超类），如果我们新定义的一个类没有明确地指定继承自哪个基类，那么JAVA就会默认为它是继承自Object类的。

继承给我们的编程带来的好处就是**对原有类的复用（重用）**。**就像模块的复用一样**，**类的复用**可以提高我们的开发效率，实际上，**模块的复用是大量类的复用叠加后的效果。**除了继承之外，我们还可以使用组合的方式来复用类。所谓组合就是把原有类定义为新类的一个属性，通过在新类中调用原有类的方法来实现复用。如果新定义的类型与原有类型之间不存在被包含的关系，也就是说，从抽象概念上来讲，新定义类型所代表的事物并不是原有类型所代表事物的一种，比如黄种人是人类的一种，它们之间存在包含与被包含的关系，那么这时组合就是实现复用更好的选择。下面这个例子就是组合方式的一个简单示例：


#### Java 重写Override/重载Overload

重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。**即外壳不变，核心重写！**

重载和重写都是针对方法的概念，在弄清楚这两个概念之前，我们先来了解一下什么叫方法的型构（英文名是signature，有的译作“签名”，虽然它被使用的较为广泛，但是这个翻译不准确的）。型构就是指方法的组成结构，具体包括方法的名称和参数，涵盖参数的数量、类型以及出现的顺序，但是不包括方法的返回值类型，访问权限修饰符，以及abstract、static、final等修饰符。比如下面两个就是具有相同型构的方法：

Java代码
public void method(int i, String s) {   
​    // do something   
}   

public String method(int i, String s) {   
​    // do something   
}

而这两个就是具有不同型构的方法：
Java代码
public void method(int i, String s) {   
​    // do something   
}   

public void method(String s, int i) {   
​    // do something   
}

- 重写，英文名是overriding，是指在继承情况下，子类中定义了与其基类中方法具有**相同型构**的新方法，就叫做子类把基类的方法重写了。这是实现**多态**必须的步骤。
- 重载，英文名是overloading，是指在同一个类中定义了一个以上具有相同名称，但是**型构不同**的方法。在同一个类中，是不允许定义多于一个的具有相同型构的方法的。

我们来考虑一个有趣的问题：构造器可以被重载吗？答案当然是可以的，我们在实际的编程中也经常这么做。实际上构造器也是一个方法，构造器名就是方法名，构造器参数就是方法参数，而它的返回值就是新创建的类的实例。但是构造器却不可以被子类重写，因为子类无法定义与基类具有相同型构的构造器。

#### Java 多态（Polymorphism）



#### Java 抽象类（abstract class）

在Java语言中使用abstract class来定义抽象类。



#### Java 封装（Encapsulation）

实现Java封装的步骤:

1. 修改属性的可见性来限制对属性的访问（一般限制为private），例如：

   public class Person {
   ​    private String name;
   ​    private int age;
   }

   这段代码中，将 **name** 和 **age** 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。

2. 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如：

public class Person{
​    private String name;
​    private int age;
​    public int getAge(){
​      return age;
​    }
​    public String getName(){
​      return name;
​    }
​    public void setAge(int age){
​      this.age = age;
​    }
​    public void setName(String name){
​      this.name = name;
​    }
}
以上实例中public方法是外部类访问该类成员变量的入口。
通常情况下，这些方法被称为getter和setter方法。
因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。

    public class RunEncap{
    public static void main(String args[]){
        EncapTest encap = new EncapTest();
        encap.setName("James");
        encap.setAge(20);
        encap.setIdNum("12343ms"); 
        System.out.print("Name : " + encap.getName()+ 
                               " Age : "+ encap.getAge());
      }

#### Java接口（Interface）



#### Java 包（package）

ava 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。

### Java 高级教程



#### Java数据结构

Java工具包提供了强大的数据结构。在Java中的数据结构主要包括以下几种接口和类：

- 枚举（Enumeration）：枚举（Enumeration）接口虽然它本身不属于数据结构,但它在其他数据结构的范畴里应用很广。 枚举（The Enumeration）接口定义了一种从数据结构中取回连续元素的方式。

- 位集合（BitSet）：

- 向量（Vector）：向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。和数组一样，Vector对象的元素也能通过索引访问。使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。

- 栈（Stack）：栈（Stack）实现了一个后进先出（LIFO）的数据结构。

- 字典（Dictionary）：字典（Dictionary） 类是一个抽象类，它定义了键映射到值的数据结构。由于Dictionary类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现。

- 哈希表（Hashtable）：Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。

- 属性（Properties）：Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。

  Properties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。

以上这些类是传统遗留的，在Java2中引入了一种新的框架-集合框架(Collection)，我们后面再讨论。

哈希方法在“键- 值对”的存储位置与它的键之间建立一个确定的对应函数关系 hash() ，使得每一个键与结构中的一个唯一的存储位置相对应：存储位置=hash( 键 )

在搜索时，首先对键进行hash 运算，把求得的值当做“键 - 值对”的存储位置，在结构中按照此位置取“键 - 值对”，若键相等，则表示搜索成功。在存储“键 - 值对”的时候，依照相同的 **hash 函数**计算存储位置，并按此位置存放，这种方法就叫做**哈希方法，也叫做散列方法**。
**在哈希方法中使用的转换函数 hash 被称作哈希函数 ( 或者散列函数 ) 。按照此算法构造出来的表叫做哈希表 ( 或者散列表 ) 。**
哈希函数建立了从“键- 值对”到哈希表地址集合的一个映射，有了哈希函数，我们就可以根据键来确定“键 - 值对”在哈希表中的位置的地址。使用这种方法由于不必进行多次键的比较，所以其搜索速度非常快，很多系统都使用这种方法进行数据的组织和检索。

dictionary 跟 map 其实是同一个东西，只是在不同场合叫法不同。
dictionary 的中文是字典，map 在中文是映射，也有地图的意思。查字典，查地图，都是通过某个信息，去找到另一个信息。比如通过单词的拼写找到单词的具体含义。
类比查字典过程，单词的拼写为 key, 单词的具体含义为 value。dictionary 就是通过key，找到value，有时也将 dictionary 说成是 key-value 结构。只要达到查找目的，都可以叫做 dictionary。具体怎么找，可以有不同实现。
比如，最简单是将 key，value 放在一起，线性排。
>k1, k2, k3, k4, k4 ....
>v1, v2, v3, v4, v5 ....

当需要从 key 找到对应的 value 时，就从头到尾遍历过去。依次判断 k1, k2, k3, k4 是不是等于key, 当等于的时候，就找到 key 的具体位置，从而也就找到了value。
但这样从头到尾遍历，速度就太慢了，时间复杂度为 O(N)。N为数据的大小。
为了快速从key找到value。dictionary(或者说map)的通常有两种实现方式。
二叉树哈希(hash)表二叉树查找的时间复杂度为 O(logN)，哈希表的时间复杂度大致为 O(1)。
二叉树也分红黑树，AVL树等。
哈希表的速度很快，很多语言内置的 dictionary 都使用哈希表来实现，但它通常会浪费一些存储空间。
这部分有兴趣去看数据结构的书。
hash_map 其实就是使用 hash 表实现的 map。
注意，二叉树，哈希表仅仅是 dictionary 的实现方式，不能说 hash 就等于 dictionary，实现方式可以有多种多样。比如上面线性存储的实现，可以调整一下。当数据都放进来之后，先根据 key 来排序，再使用二分查找，就可以很快速地从 key 找到 value, 这种实现简单快速，并省内存，有时会比 hash 的实现更好。适合于一些数据不会经常变动的情况。
C++ 11 的标准库中有个 unordered_map，就是采用哈希表使用的 map。在C++ 11之前，没有标准的哈希实现，很多第三方库实现了哈希字典，基本都叫做 hash_map, 并应用广泛。所以C++ 11的实现就不能叫hash_map了，因为会造成很多现存的程序名字冲突。哈希实现的字典是无序，也就取了个不算太好的名字，unordered_map。

#### Java集合框架

Java提供了一套比较完整的容器类，基本类型是：List、Set、Queue、Map，这些对象类型称为集合类。


```
  package java.lang;
  import java.util.Iterator;
  public interface Iterable<T> {
      /**
       * Returns an iterator over a set of elements of type T.
       *
       * @return an Iterator.
       */
      Iterator<T> iterator();
  }
```

```
package java.util;
public interface Collection<E> extends Iterable<E> {
    // Query Operations
    int size();
    boolean isEmpty();
    boolean contains(Object o);
    Iterator<E> iterator();
    Object[] toArray();
    <T> T[] toArray(T[] a);
    boolean add(E e);
    boolean remove(Object o);
    boolean containsAll(Collection<?> c);
    boolean addAll(Collection<? extends E> c);
    boolean removeAll(Collection<?> c);
    boolean retainAll(Collection<?> c);
    void clear();
    boolean equals(Object o);
    int hashCode();
}
```
```
package java.util;
public interface List<E> extends Collection<E> {
int size();
boolean isEmpty();
boolean contains(Object o);
Iterator<E> iterator();
....
List<E> subList(int fromIndex, int toIndex);
}
```





#### Java泛型

Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。
泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。

> 假定我们有这样一个需求：写一个排序方法，能够对整形数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？
> 答案是可以使用 **Java 泛型**。
> 使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。

#####**泛型方法**
你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。
下面是定义泛型方法的规则：
所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的<E>）。
每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。
类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。
泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等）。
```
public class GenericMethodTest
{
   // 泛型方法 printArray                         
   public static < E > void printArray( E[] inputArray )
   {
      // 输出数组元素            
         for ( E element : inputArray ){        
            System.out.printf( "%s ", element );
         }
         System.out.println();
    }
     public static void main( String args[] )
    {
        // 创建不同类型数组： Integer, Double 和 Character
        Integer[] intArray = { 1, 2, 3, 4, 5 };
        Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 };
        Character[] charArray = { 'H', 'E', 'L', 'L', 'O' };
        System.out.println( "整型数组元素为:" );
        printArray( intArray  ); // 传递一个整型数组
        System.out.println( "\n双精度型数组元素为:" );
        printArray( doubleArray ); // 传递一个双精度型数组
        System.out.println( "\n字符型数组元素为:" );
        printArray( charArray ); // 传递一个字符型数组
    } 
}

```
有界的类型参数:
可能有时候，你会想限制那些被允许传递到一个类型参数的类型种类范围。例如，一个操作数字的方法可能只希望接受Number或者Number子类的实例。这就是有界类型参数的目的。
要声明一个有界的类型参数，首先列出类型参数的名称，后跟extends关键字，最后紧跟它的上界。
下面的例子演示了"extends"如何使用在一般意义上的意思"extends"（类）或者"implements"（接口）。该例子中的泛型方法返回三个可比较对象的最大值。
```
public class MaximumTest
{
   // 比较三个值并返回最大值
   public static <T extends Comparable<T>> T maximum(T x, T y, T z)
   {                     
      T max = x; // 假设x是初始最大值
      if ( y.compareTo( max ) > 0 ){
         max = y; //y 更大
      }
      if ( z.compareTo( max ) > 0 ){
         max = z; // 现在 z 更大           
      }
      return max; // 返回最大对象
   }
   public static void main( String args[] )
   {
      System.out.printf( "%d, %d 和 %d 中最大的数为 %d\n\n",3, 4, 5, maximum( 3, 4, 5 ) ); 
      System.out.printf( "%.1f, %.1f 和 %.1f 中最大的数为 %.1f\n\n",6.6, 8.8, 7.7, maximum( 6.6, 8.8, 7.7 ) ); 
      System.out.printf( "%s, %s 和 %s 中最大的数为 %s\n","pear","apple", "orange", maximum( "pear", "apple", "orange" ));
   }
}
```
#####**泛型类**
泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。
和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。
```
public class Box<T> {
  private T t
  public void add(T t) {
    this.t = t;
  }
   public T get() {
    return t;
  }
   public static void main(String[] args) {
    Box<Integer> integerBox = new Box<Integer>();
    Box<String> stringBox = new Box<String>();
    integerBox.add(new Integer(10));
    stringBox.add(new String("菜鸟教程"));
    System.out.printf("整型值为 :%d\n\n", integerBox.get());
    System.out.printf("字符串为 :%s\n", stringBox.get());
  }
}
```
**类型通配符**
1、类型通配符一般是使用?代替具体的类型参数。例如 List<?> 在逻辑上是List<String>,List<Integer> 等所有List<具体类型实参>的父类。




## Baf-mysql.properties

Baf-mysql.properties 放置配置文件 与 xml文件关联。  （ctrl+shift+R：Baf-mysql.properties ）

bam 是一个项目的数据库：172.16.1.72:3306
> `database.schema=bam`
> `database.username=bam`
> `database.password=YJkkYRrPRqYJ`

sia9是farms项目的数据库：172.16.1.114:3306

> `database.farmsro.username=root`
> `database.farmsro.password=Hubin123`
> `database.farmsro.schema=sia9`

主表 分表 到李晗那边问一下 哪些是主表分表。
bam里边的表 不在 frams的分库分表计划里，都不属于分表。



# 20170519



## 对照着前面的java语法，在修改bam改造代码时，看了bam开发空间里的代码

	java.lang.Object
​	
	public interface Serializable {}
​	 
	public interface BObject extends Serializable {
	public Long getOid();
	public void setOid(Long oid);
	public boolean isNewObject();
	public boolean isNewObject();
	public void setNewObject(boolean newObject);
	public Map<String, Object> getBmfProperties();
	public void setBmfProperties(Map<String, Object> bmfProperties);
	public Object getBmfProperty(String property);
	public void setBmfProperty(String property, Object object);
	public String getBmfTitle();
	public void setBmfTitle(String title);
	public BObject getBeforeImage();
	public void setBeforeImage(BObject beforeImage);
	public Object getProperty(String p);
	public void setProperty(String p, Object v);
	public Long getBafTenantId();
	public void setBafTenantId(Long bafTenantId);
	public abstract boolean isActive();
	public abstract void setActive(boolean active);
	public abstract Date getCreatedOn();
	public abstract void setCreatedOn(Date created);
	public abstract BmfUser getCreatedBy();
	public abstract void setCreatedBy(BmfUser createdBy);
	public abstract Date getUpdatedOn();
	public abstract void setUpdatedOn(Date updated);
	public abstract BmfUser getUpdatedBy();
	public abstract void setUpdatedBy(BmfUser updatedBy);	
	public Long getCreatedById();
	public void setCreatedById(Long createdById);
	public Long getUpdatedById();
	public void setUpdatedById(Long updatedById);
	public Date getDeletedOn();
	public void setDeletedOn(Date deletedOn);
	public BmfUser getDeletedBy();
	public void setDeletedBy(BmfUser deletedBy);
	public abstract BmfUser getOwnedBy();
	public abstract void setOwnedBy(BmfUser owner);
	public void sendStateEvent(String event);
	}


	public interface SObject extends BObject {
	public String getUid();
	public void initOid();
	public void initOid(Long newOid);
	public Long getAid();
	.......
	}


	public interface TObject {
	SObject getSObject();
	void setSObject(SObject sobj);

}

## 鲲总、春茂、小刚开会讨论汽车爬虫



春茂跟小刚说了hadoop

春茂让小刚设计一下表格

鲲总等让爬一下汽车品牌--车标--

图片先扒下来

春茂说了后面可能会买

春茂用的网易汽车做参考。



## bam改造

```
public interface TObject {
	SObject getSObject();	
	void setSObject(SObject sobj);
}
```





1，搜索bmfAggrManager（菜单栏-->Seaarch--file search)，找到这些需要改写的地方
2，类似`Long fcCompanyId = bmfAggrManager.findOne("PasCompany", ImmutableMap.of("Code", "NFS")).getOid();`
（  在findone()函数上，鼠标点在上面，出现SObject，表明此函数返回的是SObject函数   ）
3，
`OrmUtilities.modifyBegin();`
`OrmUtilities.modifyEnd();`
在这两行代码之间改

4，两种方式
优先：
次要：
@Autowired 表示实例化，有这个就不需要 `new ***()`等

> @Autowired
> private BmfOrmAggrManager bmfOrmAggrManager;
> ClientOrmService clientOrmService = AiafContext.getBean(ClientOrmService.class);//TableNameOrmService表名后面加OrmService，监测是否存在

```
		优先
        
            OrmUtilities.modifyBegin();
     //	    SecurityUser user = bmfAggrManager.findOne(SecurityUser.class, ImmutableMap.of("ClinetId", clientId, "Mobile", mobile));
     //	    SecurityUser user = bmfAggrManager.findOne(SecurityUser.class, ImmutableMap.of("Mobile", mobile));
            SecurityUserOrmService securityUserOrmService = AiafContext.getBean(SecurityUserOrmService.class);
            SecurityUser user = securityUserOrmService.findOneByMobile(mobile);
            SecurityUser user = securityUserOrmService.findOneByClientId_Mobile(clientId, mobile);//如果ImmutableMap.of后有两个键值对。
            OrmUtilities.modifyEnd();
            
            -------------------------
            @Autowired
		   private SecurityUserOrmService securityUserOrmService
            OrmUtilities.modifyBegin();bmf
     //	    SecurityUser user = bmfAggrManager.findOne(SecurityUser.class, ImmutableMap.of("Mobile", mobile));
            
            SecurityUser user = securityUserOrmService.findOneByMobile(mobile);
            OrmUtilities.modifyEnd();
```

```
次要
@Autowired
private BmfOrmAggrManager bmfOrmAggrManager;
OrmUtilities.modifyBegin();
SObject prevTransFact = bmfAggrManager.findOne("FCTransFact", ImmutableMap.of("ReferenceDate", refDate.minusDays(1).toDate()));

SObject prevTransFact = bmfOrmAggrManager.findOne("FCTransFact", ImmutableMap.of("ReferenceDate", refDate.minusDays(1).toDate()));//次要
OrmUtilities.modifyEnd();
```

@Autowired
OrmUtilities.modifyBegin();
SecurityUser user = bmfAggrManager.findOne(SecurityUser.class, ImmutableMap.of("Mobile", mobile));
private ClientOrmService clientOrmService; //优先
OrmUtilities.modifyBegin();
OrmUtilities.modifyEnd();



@Autowired

private BmfOrmAggrManager bmfOrmAggrManager;



bmfOrmAggrManager
5,对于find()方法：查看分表，如果是分表，在方法的第一个参数加clientId
对于save()方法：分表与主表均要添加第一个参数，分表是clientId的变量，主表是`0L`。

6，如果未在**TableOrmCategory**中的分表里，且没有**优先**级接口（ctrl+shift+T //查找TableNameOrmService：表名后面加OrmService，监测是否存在（法一：ctrl+shift+T ，法二：TableNameOrmService，鼠标放上看有没有，import）），去询问李晗是不是分表。

7，根据ImmutableMap.of（）中的键值对确定
次要的那个原语句 
放一个文件中，一起发给唐超凡

save的那种需要 立即给唐超凡

AccountEntry  accountEntry;
AccountOrmService accountO	rmService = AiafContext.getBean(AccountOrmService.class);
Account account = accountOrmService.findOneByParentId(accountEntry.getParentId());
accountEntryOrmService.save(account.getClientId(), accountEntry);
accountOrmService.save(account);

```
   
   bmfOrmAggrManager.save(clientId, sobject);.save(fcTransFact);
    AccountOrmService accountOrmService = AiafContext.getBean(AccountOrmService.class);
    accountOrmService.save(account);       }
    
```



## bam改造新进展





DocItemServiceImpl.java
	public DocumentItem findDocItem(String code, DocItemStatusEnum status) {
	//默认查找富聪平台或者companyId为空的模板
		OrmUtilities.modifyBegin();
		//		Long fcCompanyId = bmfAggrManager.findOne("PasCompany", ImmutableMap.of("Code", "NFS")).getOid();
	//		PasCompanyOrmService pasCompanyOrmService = AiafContext.getBean(PasCompanyOrmService.class);
		PasCompany pasCompanyEntity = pasCompanyOrmService.findOneByCode("NFS");
		Long fcCompanyId = null;
		if(pasCompanyEntity != null)
			fcCompanyId = pasCompanyEntity.getSObject().getOid();
		OrmUtilities.modifyEnd();
		/** select * from DocumentItem where Code = ? and (CompanyID is null or CompanyID = ?) and Status = ? 
		 *  原sql语句  现因无CompanyID字段改成 select * from DocumentItem where Code = ? and Status = ?   */
		OrmUtilities.modifyBegin();
		//		DocumentItem documentItems = bmfAggrManager.findOneBySql("select * from DocumentItem where Code = ? and Status = ?", DocumentItem.class, code, status.getValue());
		DocumentItem documentItems = documentItemOrmService.findOneByCode_Status(code, status.getValue());
		OrmUtilities.modifyEnd();
		
		return documentItems;
	}



​	JobNotRunListener.java



			OrmUtilities.modifyBegin();
			//find AlertMethod
	//		Long alertMethodOid = getTableReconOid("AlertMethod", ImmutableMap.of("AlertMethod", AlertMethodEnum.SMS.getValue()));
			SObject sObject=bmfOrmAggrManager.findOne("AlertMethod", ImmutableMap.of("AlertMethod", AlertMethodEnum.SMS.getValue()));
			Long alertMethodOid=null;
			alertMethodOid=(sObject == null)? null : sObject.getOid();
			OrmUtilities.modifyEnd();
			
	private Long getTableReconOid(String table, Map<String, String> paramsMap) {
		SObject sObject = bmfAggrManager.findOne(table, paramsMap);
		return null == sObject ? null : sObject.getOid();
	}
​		

# 20170522



## CRUD
CRUD是指在做计算处理时的增加(Create)、读取查询(Retrieve)、更新(Update)和删除(Delete)几个单词的首字母简写。
主要被用在描述软件系统中数据库或者持久层的基本操作功能。
In computing, CRUD is an acronym for create, retrieve, update, and delete. It is used to refer to the basic functions of a database or persistence layer in a software system.
C reate new records
R etrieve existing records
U pdate existing records
D elete existing records.





## 大O记法

C++的大O记法是算法的时间复杂度表达公式。简单的说大O记法可以告诉你**一个算法耗费的时间长度**同**算法所处理的数据量大小**的关系。大O记法只是一个概念性的或定性的记号，不能通过它来真正计算一个算法所耗费的精确时长。

O(1) 算法只花费一个单位时间长度的时间。同所处理的数据量大小没有关系（常量时间）。
​       “一个单位时间长度”没有定义为1秒，1天，还是1微妙，完全随意指定。大约同处理一个数据项的时长相同。
​       考虑一个数组，按照数组下标的到一个元素的引用
​       int arr[100];
​       int x = arr[88]; //这个算法就是O(1)的
​       O(1)是最爽的，哪怕有1亿条数据还是1条数据，算法所费时间是常量。
O(N) 算法只花费N个单位时间长度的时间。数据量大小同算法所花费时长成正比例
​       考虑一个list链表
​       list.remove( 88 ); //把第88个元素删除。这个算法就是O(N)的
​       O(N)是最不爽的，假设有1亿条数据，算法就要花费1亿个时间单位的时长。
O(logN) 算法只花费logN个单位时间长度的时间。
​         logN是取对数，可以简单的理解为取以2为底数，N的对数。例如log65536=16 (因为2^16=65536)
​         对数是把一个天文数字般的整数映射成一个小小的整数的数学工具。
​         考虑一个已排序的数组，用“折半法”查找，算法的时间特性就是O(logN)的。
​         O(log(一个亿))约等于19个单位时间的时长。
​     O(logN)也不一定是以2为底的，也可能是以3为底的，这都无所谓。
算法在应用于局部小数据量时，可能因为内存的申请，释放，初始化等原因，观察者发现不符合大O记法表示的特性。
但是在长期的运行，经过大数据量的考验后，那些干扰因素逐渐沦为次要因素，观察者可以发现算法的却符合某种自己固有的时间特性。

## 红黑树（Red Black Tree）
红黑树是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。
1972年由Rudolf Bayer发明，当时被称为平衡二叉树（symmetric binary B-trees).
红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。
它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。

 

# 20170523



## git--gitbash中运行git log之后怎样终止这个命令

ctrl+c不管用
ctrl++z不管用

需要输入q键

## Git diff、log、reset



### git远程仓库版本回退方法

如果提交了一个错误的版本，怎么回退版本？
如果提交了一个错误的版本到远程分支，怎么回退远程分支版本？
如果提交了一个错误的版本到公共远程分支，又该怎么回退版本？
#### 本地分支版本回退的方法
- `HEAD`指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令`git reset --hard commit_id`。
- 穿梭前，用`git log`可以查看提交历史，以便确定要回退到哪个版本。
- 要重返未来，用`git reflog`查看命令历史，以便确定要回到未来的哪个版本。
  如果你在本地做了错误提交，那么回退版本的方法很简单 
  先用下面命令找到要回退的版本的commit id：```git reflog ```
  接着回退版本:```git reset --hard Obfafd```
  `0bfafd`就是你要回退的版本的commit id的前面几位
#### 自己的远程分支版本回退的方法
如果你的错误提交已经推送到自己的远程分支了，那么就需要回滚远程分支了。 
首先要回退本地分支：
> git reflog
> git reset --hard Obfafd
> 紧接着强制推送到远程分支：
> git push -f
> **注意：本地分支回滚后，版本将落后远程分支，必须使用强制推送覆盖远程分支，否则无法推送到远程分支**
#### 公共远程分支版本回退的问题
> A1–A2–B1
> 方法一：像自己的远程分支回退一样操作，但是这需要队友自己手动更改自己的本地分支
> 方法二：
> 使用git reset回退公共远程分支的版本后，需要其他所有人手动用远程master分支覆盖本地master分支，显然，这不是优雅的回退方法，下面我们使用另个一个命令来回退版本：
> git revert HEAD                     //撤销最近一次提交
> git revert HEAD~1                   //撤销上上次的提交，注意：数字从0开始
> git revert 0ffaacc                  //撤销0ffaacc这次提交
> git revert 命令意思是撤销某次提交。它会产生一个新的提交，虽然代码回退了，但是版本依然是向前的，所以，当你用revert回退之后，所有人pull之后，他们的代码也自动的回退了。 

#### 错的太远了直接将代码全部删掉，用正确代码替代

简单粗暴的办法，直接从那个错误的提交的前一次拉取一份代码放到其他目录，然后将master代码全部删除，把那份新代码方进去，然后提交，果然简单粗暴啊，虽然这种方法不入流，但是，实践中发现很好使啊，所以，实践是检验真理的唯一标准。遇到问题还是要灵活应对。 

### git diff

diff里面a表示前面那个变量，b表示第二个变量

HEAD     commit版本
Index     staged版本

a、查看尚未暂存的文件更新了哪些部分，不加参数直接输入
​    git diff
此命令比较的是工作目录(Working tree)和暂存区域快照(index)之间的差异
也就是修改之后还没有暂存起来的变化内容。

b、查看已经暂存起来的文件(staged)和上次提交时的快照之间(HEAD)的差异
​    git diff --cached
​    git diff --staged
显示的是下一次commit时会提交到HEAD的内容(不带-a情况下)


c、显示工作版本(Working tree)和HEAD的差别
​    git diff HEAD


d、直接将两个分支上最新的提交做diff
​    git diff topic master 或 git diff topic..master

e、输出自topic和master分别开发以来，master分支上的changed。
​    git diff topic...master
Changes that occurred on the master branch since when the topic
 branch was started off it
f、查看简单的diff结果，可以加上--stat参数
​    git diff --stat

g、查看当前目录和另外一个分支的差别
​    git diff test
显示当前目录和另一个叫'test'分支的差别
​    git diff HEAD -- ./lib
显示当前目录下的lib目录和上次提交之间的差别（更准确的说是在当前分支下）

h、比较上次提交commit和上上次提交
​    git diff HEAD^ HEAD

i、比较两个历史版本之间的差异
​    git diff SHA1 SHA2



## carCrawler

163car:`48 *48`, `64*64`, `128*128`

autohome:`50*50`

xcar:`160*120`

audi: ` 82*70`



### 爬到图片的URL，如何下载到本地？

方法一：

> ```
> for i in imgurl:
> 	content=urllib2.urlopen(i).read()
> 	with open("F:\\DownLoad\123.png",'wb') as f:
> 		f.write(content)
> ```

方法二：

> ```
> for i in iimgurl:
> 	name=1
> 	//llib.urlretrieve(i,u'C:\python 爬虫\picture\123.png')
> 	urllib.urlretrieve(i,u'C:\python 爬虫\picture\%s.ng'%name)
> ```





# 20170524





## python 抓取网易汽车上的汽车LOGO





## python图像处理库PIL（Python Imaging Library）
PIL已经是Python平台事实上的图像处理库了。PIL功能非常强大，但API却非常简单易用。
The Python Imaging Library (PIL) adds image processing capabilities to your Python interpreter. 
This library supports many file formats, and provides powerful image processing and graphics capabilities.


Pillow由PIL而来，所以该导入该库使用import PIL
Pillow 是 PIL的对Python3支持的另外一个分支，当然他对Python2也兼容，由于PIL安装起来比较烦，而使用pip可以很轻松的安装Pillow，所以我选择Pillow使用，但是其核心还是PIL库的。


Pillow 是 PIL 的替代版本，PIL 软件包提供了基本的图像处理功能，如：改变图像大小，旋转图像，图像格式转换，色场空间转换，图像增强，直方图处理，插值和滤波等等。
Pillow 为了解决 PIL 的两个问题：
1. 不兼容 setuptools 
2. 报告的问题太多，而更新太慢 




pillow中所有的图片处理方法都是基于Image.transform（）函数的，rotate等函数是一些常规的封装罢了，学会使用它才是正统。

`Image.transform(size, method, data=None, resample=0, fill=1)`

改变一张图片，这个方法会根据给定的尺寸生成一张与原图同样mode的图片，并根据给定的变化，从原图生的一个副本。说白了呢就是生成一张变换后的新图片。

这样介绍，这个函数是不是感觉很简单，分分钟都能实现，我也是这样觉得的，其实。

在介绍参数之前，我们默认已经打开了该图片：

from PIL import Image
img = Image.open("img/lyc.jpg")

下面说下这个函数的参数：

- size：尺寸，接受一个二值元组，格式：(width, height)。这个参数可以用来做缩放处理，比如原图(300, 300)大小，你可以指定新图片大小为(50, 50)
- data：这个参数是必须的，否则会报：ValueError异常。这个参数用于指定methond指定的变换方式说需要的额外的数据，这个会在下面说method参数时顺带说了。
- method：变换的方式，该值是给定，你只能从以下几个值当中选一个：
- Image.EXTENT（cut out a rectangular subregion[ 切出一个矩形区域 ]）：
- 该参数的data接受一个四值list，格式如：( x1, y1, x2, y2)，表示矩阵的起始点(x1, y1)，(x2, y2)。这个点坐标不要求一定要在图形大小表示的范围内，超过也可以，不过超过的部分默认使用黑色填充。

> `#`矩形剪切
>
> img.transform((100,100),Image.EXTENT ,[100,100,400,400]).show()



## bam改造测试

采用了这个版本 `<aiaf.version>6.5.64-SNAPSHOT</aiaf.version>`

http://127.0.0.1:8080/bam/
后加
/Baf/BafSqlCommand
Baf/BafConsole
bam项目默认bam库



`http://127.0.0.1:8080/bam/Baf/BafConsole`

```
import com.mdiaf.batch.domain.ClientInfo;
import com.mdiaf.batch.internal.ClientMapItemProcessor;  
ClientInfo client  = new ClientInfo();
client.setMobile("1221212");
client.setOid("27137");

// return client;

ClientMapItemProcessor cl = new ClientMapItemProcessor();
cl.process(client);
```

有些是通过 @auto 注入的 

也需要 通过类似 ClientInfo client  = new ClientInfo(); new进来



```
import com.mdiaf.batch.domain.ClientInfo;
import com.mdiaf.batch.internal.ClientMapItemProcessor;

ClientInfo client = new ClientInfo();
ClientMapItemProcessor cl = new ClientMapItemProcessor();

cl.process(client);
```



# 20170525





## spring eclipse

使用 Eclipse，Eclipse 是基于Java的可扩展平台，所以安装Eclipse前需要确保你的电脑已安装JDK。

第一次打开ZEclipse需要设置工作环境，可以指定工作目录或者使用默认的C盘工作环境。

创建一个项目：选择File--New--java Project

在项目基础上，new--class

![](.\imagenote\spring-eclipse.png)

![](.\imagenote\spring-eclipse-1.png)

maven项目右上角有个J是什么意思

大写的J表示的是项目为普通的java工程，S表示此项目使用了Spring框架

工程--项目--文件夹、文件









### Eclipse 修改字符集

默认情况下 Eclipse 字符集为 GBK，但现在很多项目采用的是 UTF-8，这是我们就需要设置我们的 Eclipse 开发环境字符集为 UTF-8， 设置步骤如下：

在菜单栏选择** Window -> Preferences -> General -> Workspace -> Text file encoding**，在 Text file encoding 中点击 Other，选择 UTF-8。











## 编码encoding

**ASCII**

在计算机内部，所有的信息最终都表示为一个**二进制的字符串**。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出**256种状态**，这被称为一个**字节**（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到11111111。
上个世纪60年代，美国制定了**一套字符编码**，对**英语字符与二进制位之间的关系**，做了统一规定。这被称为**ASCII码**，一直沿用至今。
ASCII码一共规定了**128个字符的编码**，比如**空格"SPACE"是32（二进制00100000）**，大写的**字母A是65（二进制01000001）**。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。

**Unicode**

世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。
可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。
Unicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字"严"。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。

**Unicode的问题**

Unicode只是一个符号集，它只规定了符号的**二进制代码**，却没有规定**这个二进制代码应该如何存储**。
比如，汉字"严"的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。
这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。
它们造成的结果是：
1）出现了Unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示Unicode。
2）Unicode在很长一段时间内无法推广，直到互联网的出现。

**UTF-8**

互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种Unicode的实现方式。其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。
UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。
UTF-8的编码规则很简单，只有二条：
1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。
2）对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。
下表总结了编码规则，字母x表示可用编码的位。

Unicode符号范围 | UTF-8编码方式
(十六进制) | （二进制）
--------------------+---------------------------------------------
0000 0000-0000 007F | 0xxxxxxx
0000 0080-0000 07FF | 110xxxxx 10xxxxxx
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

已知"严"的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此"严"的UTF-8编码需要三个字节，即格式是"1110xxxx 10xxxxxx 10xxxxxx"。然后，从"严"的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，"严"的UTF-8编码是"11100100 10111000 10100101"，转换成十六进制就是E4B8A5。



## python与编码

python在安装时，默认的编码是ascii，当程序中出现非ascii编码时，python的处理常常会报这样的错UnicodeDecodeError: 'ascii' codec can't decode byte 0x?? in position 1: ordinal not in range(128)，python没办法处理非ascii编码的，此时需要自己设置将python的默认编码，一般设置为utf8的编码格式。

查询系统默认编码可以在解释器中输入以下命令：sys.getdefaultencoding()

设置默认编码时使用：sys.setdefaultencoding('utf8')

可能会报AttributeError: 'module' object has no attribute 'setdefaultencoding'的错误，执行reload(sys)，在执行以上命令就可以顺利通过。

此时在执行sys.getdefaultencoding()就会发现编码已经被设置为utf8的了，但是在解释器里修改的编码只能保证当次有效，在重启解释器后，会发现，编码又被重置为默认的ascii了，那么有没有办法一次性修改程序或系统的默认编码呢。

有2种方法设置python的默认编码：

一个解决的方案在程序中加入以下代码：

> import sys   
> reload(sys)   
> sys.setdefaultencoding('utf8')   

另一个方案是在python的Lib\site-packages文件夹下新建一个**sitecustomize.py**，内容为：

> **\# encoding=utf8**   
> **import sys**   
> **reload(sys)**   
> **sys.setdefaultencoding('utf8')**   

此时重启python解释器，执行sys.getdefaultencoding()，发现编码已经被设置为utf8的了，多次重启之后，效果相同，这是因为系统在python启动的时候，自行调用该文件，设置系统的默认编码，而不需要每次都手动的加上解决代码，属于一劳永逸的解决方法。

另外有一种解决方案是在程序中所有涉及到编码的地方，强制编码为utf8，即**添加代码encode("utf8")**，这种方法并不推荐使用，因为一旦少写一个地方，将会导致大量的错误报告，我曾经遇到这种情况，错误日志压缩之后尚有70多K，全都是这一个问题，让人有很崩溃的感觉。





decode('utf-8')的作用是将utf8编码的字符串解码为unicode，而unicode是python最接受的字符串编码格式，不会因为各个工具库对字符编码处理不好而带来问题。

coding:utf-8的作用是指定当前这个python代码文件里面所有字符串的编码

python 3版本已经将默认编码格式ASCII改了

1. 保存文件时是否必要encode为utf-8

   这个两种都可以，纯粹看你的希望以哪种编码存储文件，以及那种编码后续处理更方便。 只不过write unicode字符串时，最好使用codes.open来打开文件并设置编码。

2. 源代码编码定义（# -*-coding:utf-8 -*-）的作用

   告诉python编译器如何解码代码文件，但并不能保证文件的实际编码一定与之匹配。
   实际文件的编码还是由编辑器决定的（有些编辑器可能会识别# -*-coding:utf-8 -*-，并进行相应的编码存储）。

   举个例子，我的vim的fileencoding设置为utf-8，但py文件编码设置为ascii（-*- coding:ascii -*-）。
   这时我的py文件的实际编码为utf-8，但python编译器会按ascii来解析源文件，如果遇到非ascii字符就会抛异常:
   SyntaxError: 'ascii' codec can't decode byte 0xe4 in position 5: ordinal not in range(128)

`encode`和`decode`提供 str 和 unicode 这两种的类型的互相转化。

- encode 把 unicode 转化成 str(byte string)
- decode 把 str(byte string) 转化成 unicode

Python获取系统默认字符编码的方法,涉及Python中sys模块getdefaultencoding方法的使用技巧

在Python代码中，普通字符串的编码方式与程序源文件编码方式一致的，而很多IDE在默认情况下，将程序源文件按照系统默认字符编码来保存的。

下面给出用Python获取系统默认编码的例子：

> ```
> #!/usr/bin/env python
> #coding=utf-8
> """
>   获取系统默认编码
> """
> import sys
> print sys.getdefaultencoding()
> ```





在 python 源代码文件中，**如果你有用到非ASCII字符，则需要在文件头部进行字符编码的声明**，声明如下：`# code :  UTF-8`

因为python 只检查 #、coding 和编码字符串，所以你可能回见到下面的声明方式，这是有些人为了美观等原因才这样写的：`# -*- coding:UTF-8-*-`

**常见编码介绍：**

> - ******GB2312编码：适用于汉字处理、汉字通信等系统之间的信息交换**
> - **GBK编码：是汉字编码标准之一，是在 GB2312-80 标准基础上的内码扩展规范，使用了双字节编码**
> - **ASCII编码：是对英语字符和二进制之间的关系做的统一规定**
> - **Unicode编码：这是一种世界上所有字符的编码。当然了它没有规定的存储方式。**
> - **UTF-8编码：是 Unicode Transformation Format - 8 bit 的缩写， UTF-8 是 Unicode 的一种实现方式。它是可变长的编码方式，可以使用 1~4 个字节表示一个字符，可根据不同的符号而变化字节长度。**



**编码转换：**

Python内部的字符串一般都是 Unicode编码。**代码中字符串的默认编码与代码文件本身的编码是一致的。**所以要做一些编码转换通常是要以Unicode作为中间编码进行转换的，即先将其他编码的字符串解码（decode）成 Unicode，再从 Unicode编码（encode）成另一种编码。

> - **decode **的作用是将其他编码的字符串转换成 Unicode 编码，eg name.decode(“GB2312”)，表示将GB2312编码的字符串name转换成Unicode编码
> - **encode **的作用是将Unicode编码转换成其他编码的字符串，eg name.encode(”GB2312“)，表示将GB2312编码的字符串name转换成GB2312编码

所以在进行编码转换的时候必须先知道 name 是那种编码，然后 decode 成 Unicode 编码，最后载 encode 成需要编码的编码。当然了，如果 name 已经就是 Unicode 编码了，那么就不需要进行 decode 进行解码转换了，直接用 encode 就可以编码成你所需要的编码。**值得注意的是：对 Unicode 进行编码和对 str 进行编码都是错误的。**

具体的说就是：如果在UTF-8文件中，则这个字符串就是 UTF-8编码的。它的编码取决于当前的文本编码。当然了，GB2312文本的编码就是GB2312。**要在同一个文本中进行两种编码的输出等操作就必须进行编码的转换**，先用decode将文本原来的编码转换成Unicode，再用encode将编码转换成需要转换成的编码。

eg：
由于内置函数 open() 打开文件时，read() 读取的是 str，读取后需要使用正确的编码格式进行 decode()。write() 写入时，如果参数是 Unicode，则需要使用你希望写入的编码进行 encode()，如果是其他编码格式的 str，则需要先用该 str 的编码进行 decode()，转成 Unicode 后再使用写入的编码进行 encode()。如果直接将 Unicode 作为参数传入 write() ，python 将先使用源代码文件声明的字符编码进行编码然后写入。

```
# coding: UTF-8
 
fp1 = open('test.txt', 'r')
info1 = fp1.read()
# 已知是 GBK 编码，解码成 Unicode
tmp = info1.decode('GBK')
 
fp2 = open('test.txt', 'w')
# 编码成 UTF-8 编码的 str
info2 = tmp.encode('UTF-8')
fp2.write(info2)
fp2.close()
```

**获取编码的方式：**判断是 s 字符串否为Unicode，如果是返回True，不是返回False ：`isinstance(s, unicode)`

下面代码可以获取系统默认编码：

```
#!/usr/bin/env python
#coding=utf-8
import sys
print sys.getdefaultencoding()
```

> 命令行控制台



![控制台编](.\imagenote\控制台编码.png)

## 

## python encode decode在 **codec**模块中

在Python中，可以对String调用decode和encode方法来实现转码。

比如，若要将某个String对象s从gbk内码转换为UTF-8，可以如下操作 
s.decode('gbk').encode('utf-8′) 
可是，在实际开发中，我发现，这种办法经常会出现异常： 
UnicodeDecodeError: ‘gbk' codec can't decode bytes in position 30664-30665: illegal multibyte sequence 
这 是因为遇到了非法字符——尤其是在某些用C/C++编写的程序中，全角空格往往有多种不同的实现方式，比如\xa3\xa0，或者\xa4\x57，这些 字符，看起来都是全角空格，但它们并不是“合法”的全角空格（真正的全角空格是\xa1\xa1），因此在转码的过程中出现了异常。 
这样的问题很让人头疼，因为只要字符串中出现了一个非法字符，整个字符串——有时候，就是整篇文章——就都无法转码。 

解决办法： 
s.decode('gbk', ‘ignore').encode('utf-8′) 
因为decode的函数原型是decode([encoding], [errors='strict'])，可以用第二个参数控制错误处理的策略，默认的参数就是strict，代表遇到非法字符时抛出异常； 
如果设置为ignore，则会忽略非法字符； 
如果设置为replace，则会用?取代非法字符； 
如果设置为xmlcharrefreplace，则使用XML的字符引用。 









































除了写网站代码的（因为可以自己再代码中指定编码格式），其他程序员在写代码之前都应该首先把项目的编码格式选择好，看到CSDN论坛上有些网友说“写代码不用utf-8编码的程序员不是好程序员”，一般来说大家都会选择utf-8这个编码方式（不要问我为什么），但是常常中国程序员使用的很多集成编辑环境大部分默认的编码方式是GBK或者GB2312，所以新建工程就需要注意了。



解决的办法就是在数据转换的两边需要转码，如果用的是XML传输数据，那么在服务器端打包推送数据之前需要转换为utf-8，经过网络传输到达客户端之后在读XML数据之前，又转换为utf-8。







# 20170601



## bam改造

先通过SourceTree：获取--拉取

有冲突 找到冲突文件 发现 是武刚的，武刚让丢弃

重新拉取，没有冲突，build之后 发现有错误 主要是pom错误，通过 maven--update之后可以build没有错误，再通过 tomcat server运行 可以登录 `http://127.0.0.1:8080/bam/Baf/BafConsole`



http://127.0.0.1:8080/bam/Baf/BafConsole

script language/Console：

Lanuage：Groovy与sigar（system info query）

一个开源工具包 SIGAR - System Information Gatherer And Reporter，即 系统信息收集和报告。





















## python 工厂函数

《head first python》
> 工厂函数：用于创建某种类型的新的数据项。例如，“set()” 就是一个工厂函数。因为它会创建一个新的集合。
> 在真实世界中，工厂会生产产品，这个概念因此而得名。







## Eclipse中ctrl+shift+r与ctrl+shift+t的区别

eclipse中的两个常用的快捷键可以大大提升查找文件的效率,分别是:

1. **ctrl+shift+r** : open resource, 打开资源. 
   它可以打开当前eclipse的工作区中所有(打开的)工程中所有类型的文件,但只限手动编写的文件,不含工程中引用到的jar包中的类、接口；
2. **ctrl+shift+t** : open type, 打开类型. 
   它可以打开当前eclipse的工作区中所有(打开的)工程中所有**java文件**,包括jar包中的类和接口.






## 共享盘、数据库主机密码

共享盘`\\172.16.1.119`

Baf-mysql.properties 放置配置文件 与 xml文件关联。  （ctrl+shift+R：Baf-mysql.properties ）





# 20170602

## Python Pandas ValueError Arrays Must be All Same Length

you can do this to avoid that error

```
a = {'Links' : lines ,'Titles' : titles , 'Singers': finalsingers , 'Albums':finalalbums , 'Years' : years}
df = pd.DataFrame.from_dict(a, orient='index')
df.transpose()
```



## 网易汽车Logo与品牌、车系爬取



问题：遇到 存到csv文件乱码问题，后来发现问题出在pycharm平台用的default encoding for  properties files 是 gbk，而变成用的是 utf-8. 



## bam改造 遗漏项



```
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:8:import org.springframework.jdbc.core.JdbcTemplate;
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:17:       private JdbcTemplate jdbcTemplateFarmsRO;
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:20:       private JdbcTemplate jdbcTemplateBssRO;
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:31:                       dataList = jdbcTemplateBssRO.queryForList(sql, queryParameter);
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:50:                       dataList = jdbcTemplateBssRO.queryForList(querySql, queryParameter);
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:67:                       dataList = jdbcTemplateFarmsRO.queryForList(sql, queryParameter);
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:86:                       dataList = jdbcTemplateFarmsRO.queryForList(querySql, queryParameter);
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:101:                      dataList = jdbcTemplateBssRO.queryForList(querySql, queryParameter);
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:117:                      dataList = jdbcTemplateBssRO.queryForList(querySql, queryParameter);
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:132:                      dataList = jdbcTemplateFarmsRO.queryForList(querySql, queryParameter);
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:148:                      dataList = jdbcTemplateFarmsRO.queryForList(querySql, queryParameter);
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:166:                      dataList = jdbcTemplateFarmsRO.queryForList(querySql, queryParameter);


./bam-core/src/main/java/com/mdiaf/report/yqstatistics/ReportHelperManagerImpl.java:11:import org.springframework.jdbc.core.JdbcTemplate;
./bam-core/src/main/java/com/mdiaf/report/yqstatistics/ReportHelperManagerImpl.java:29: private JdbcTemplate jdbcTemplateFarmsRO;
./bam-core/src/main/java/com/mdiaf/report/yqstatistics/ReportHelperManagerImpl.java:41:                 dataList = jdbcTemplateFarmsRO.queryForList(sql, queryParameter);
./bam-core/src/main/java/com/mdiaf/report/yqstatistics/ReportHelperManagerImpl.java:59:                 dataList = jdbcTemplateFarmsRO.queryForList(querySql, queryParameter);
./bam-core/src/main/java/com/mdiaf/report/yqstatistics/ReportHelperManagerImpl.java:76:                 dataList = jdbcTemplateFarmsRO.queryForList(querySql, queryParameter);
./bam-core/src/main/java/com/mdiaf/report/yqstatistics/ReportHelperManagerImpl.java:246:                        dataList = jdbcTemplateFarmsRO.queryForList(sql, queryParameter);
```



# 20170605



sourceTree：zxcv

launch server:启动服务器

JDBC API是一个Java   API

## 打字空格 会把后边的字 覆盖掉 原因是按了insert键

原因：在打字时，不小心按到了Insert键。
Insert键：插入
功能：单击后，Windows系统默认是插入，意思是不影响后面的字符。Insert键的意思是插入覆盖，当按下Insert键后再输入，会覆盖掉光标以后的内容，再按下Insert键后还原为插入。
解决方法：按一下键盘上的Insert键就可以了，就是Delete上边那个键。

这是因为在WORD中编辑文本时开启了“改写”模式。
在WORD中编辑文本时有两种模式，一种为“插入”模式，一种为“改写”模式，当“改写“模式开启时，就会出现这种情况。
如果想避免这种情况，可以将当前编辑模式切换至”插入“模式，在”改写“与”插入“模式之间切换，最简单快捷的方法是按键盘上的“Insert”键进行切换。



## excel正则表达式

在 Excel 中，使用 Alt+F11 快捷键打开 VBA 项目窗口，在左侧的工作表名称上点右键，选择查看代码，即可出出现右侧的代码编辑窗口

在代码窗口中输入以下代码：  根据实际需要替换相应参数，点击 运行即可得到效果。

```
Private Sub RegExp_Replace()
    Dim RegExp As Object
    Dim SearchRange As Range, Cell As Range
    '此处定义正则表达式
    Set RegExp = CreateObject("vbscript.regexp")
    RegExp.Pattern = "[0-9]{5}"
    '此处指定查找范围
    Set SearchRange = ActiveSheet.Range("A1:A99")
    '遍历查找范围内的单元格
    For Each Cell In SearchRange
        Set Matches = RegExp.Execute(Cell.Value)
        If Matches.Count >= 1 Then
            Set Match = Matches(0)
            Cell.Value = RegExp.Replace(Cell.Value, "")
        End If
    Next
End Sub
```

合并两个表格，内容也合并： 只需使用 `&` 连接两个表格即可。

excel 同时显示多个窗口： 文件--->选项-->高级-->显示：勾选“在任务栏中显示所有窗口"  这个是管用的（但是不知道是否与我之前修改注册表有关”）

同时发现csv文件是不可以多窗口显示的。

## JDBC、JDBCTemplate

JDBC API是一个Java API可以访问任何类型的数据库的数据，尤其是存储在关系数据库中的数据。

JDBC（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。

有了JDBC，向各种关系数据发送SQL语句就是一件很容易的事。换言之，有了JDBC API，就不必为访问Sybase数据库专门写一个程序，为访问Oracle数据库又专门写一个程序，或为访问Informix数据库又编写另一个程序等等，程序员只需用JDBC API写一个程序就够了，它可向相应数据库发送SQL调用。同时，将Java语言和JDBC结合起来使程序员不必为不同的平台编写不同的应用程序，只须写一遍程序就可以让它在任何平台上运行，这也是Java语言“编写一次，处处运行”的优势。

简单地说，JDBC 可做三件事：与数据库建立连接、发送 操作数据库的语句并处理结果。下列代码段给出了以上三步的基本示例：

```
Connection con = DriverManager.getConnection("jdbc:odbc:wombat","login","password");
Statement stmt = con.createStatement();
ResultSet rs = stmt.executeQuery("SELECT a, b, c FROM Table1");
while (rs.next()) {
	int x = rs.getInt("a");
	String s = rs.getString("b");
	float f = rs.getFloat("c");
}
```



建立一个JDBC应用程序，本教程中以Java连接MySQL为一个示例，分六个步骤进行：



# 20170606



## JAVA文档

JAVA_API_1.7中文.chm
Spring Framework 开发者手册.chm
spring300_CN.chm
spring_framework-4-reference.epub



## eclipse快捷键

一个Eclipse骨灰级开发者总结了他认为最有用但又不太为人所知的快捷键组合。通过这些组合可以更加容易的浏览源代码，使得整体的开发效率和质量得到提升。

**1. ctrl+shift+r：打开资源**

这可能是所有快捷键组合中最省时间的了。这组快捷键可以让你打开你的工作区中任何一个文件，而你只需要按下文件名或mask名中的前几个字母，比如applic*.xml。美中不足的是这组快捷键并非在所有视图下都能用。

**2. ctrl+o：快速outline**

​    如果想要查看当前类的方法或某个特定方法，但又不想把代码拉上拉下，也不想使用查找功能的话，就用ctrl+o吧。它可以列出当前类中的所有方法及属性，你只需输入你想要查询的方法名，点击enter就能够直接跳转至你想去的位置。

**3. ctrl+e：快速转换编辑器**

​    这组快捷键将帮助你在打开的编辑器之间浏览。使用ctrl+page down或ctrl+page up可以浏览前后的选项卡，但是在很多文件打开的状态下，ctrl+e会更加有效率。

## sql语句中as的用法

在我的数据库中有user这个表，正常来说，想查询该表，那么sql语句如下`select * from user`

作为一个开发人员来说，自然是能看得懂的，但是假如，数据库不是你自己设计的，或者说给别人看，自然是需要很多的时间来理解和熟悉，那么as的作用就提现出来了。

```
select
     username as 账号 ,
     password as 密码,
     mingzi as 名字,
    zhengjianhao as 证件号,
    dianhua as 电话,
    zhuceriqi as 注册日期,
    zhuangtai as 状态,
    quanxian as 权限,
    shengyutianshu as 剩余天数
     from user
```

as是别名关键词，一般我们这么使用：

select 字段 as 别名

select 字段 别名

select 别名=字段

在sqlserver 中这三中显示结果一模一样，但是不推荐后两种写法，只推荐第一种写法。



## spring系统 工程问题

ctrl+左键 - 功能突然消失，解决方案：很可能你打开的文件不对，例如bam\bam-api, bam\bam-application, bam\bam-core, bam\bam-domain等而不是直接bam-api, bam-application。



## bam改造

分库 分表的sharding-key问题，是在文件中查找的，并不是在TableOrmCategory.class中， TableOrmCategory.class中没有shadingkey的分表指的是 在这个表格中没有shardingkey字段，但是可以从其他字段找其他表中推出shardingkey

shardingkey是一个确定表放在哪一个分库中国的键。



## java的循环语句

for(初始化; 布尔表达式; 更新) {
​    //代码语句
}

Java5 引入了一种主要用于数组的增强型 for 循环。
Java 增强 for 循环语法格式如下:

for(声明语句 : 表达式)
{
   //代码句子
}



## java V类型

```
Map.class
package java.util;
public interface Map<K,V> {
int size();
boolean isEmpty();
boolean containsKey(Object key);
boolean containsValue(Object value);
V get(Object key);
V put(K key, V value);	//这里的返回类型指的是V Value这个V类型
V put(K key, V value);	//这里的返回类型指的是V Value这个V类型
V remove(Object key);	//这里的返回类型指的是V Value这个V类型
void putAll(Map<? extends K, ? extends V> m);
void clear();
Set<K> keySet();
Collection<V> values();
Set<Map.Entry<K, V>> entrySet();
interface Entry<K,V> {
	K getKey();
	V getValue();
	V setValue(V value);
	boolean equals(Object o);
	int hashCode();
	}
boolean equals(Object o);
int hashCode();
}

```

在一般情况下返回类型要么是**范型**，要么就是**引用类型**、**基础类型**之类的数据。但是这些类型都是确切的返回类型，如果我想返回我传入的任意类型值，这个时候这些都做不到。

那怎么办呢，java已经考虑到这一点了，就是通过 <V> V 实现的。下面来看具体的案例介绍：



# 20170607



## bam改造

@Autowired 表示实例化，有这个就不需要 new ***()等
 @Autowired
private SecurityUserOrmService securityUserOrmService

SecurityUserOrmService securityUserOrmService = AiafContext.getBean(SecurityUserOrmService.class);

```

String FNDSql = "SELECT sum(n.price * m.currentShare) AS FNDBalance FROM 
( SELECT fa.assetNumber AS providerProductCode, ap.price, max(ap.startDate) AS startDate "
			+ "FROM financialasset fa INNER JOIN assetprice ap ON ap.parentId = fa.oid AND ap.priceType = 'fundNavVal' GROUP BY fa.oid ) n "
			+ "JOIN 
( SELECT sum(a.currentShare) currentShare, p.ProviderProductCode 
			FROM account a JOIN client c ON a.ClientId = c.oid "
			+ "JOIN agreement ag ON a.AgreementId = ag.oid JOIN productoffering p ON a.ProductOfferingId = p.oid "
			+ "WHERE ag.ProductCategoryCode NOT IN ('GAS') AND ag. STATUS IN ( 'Payed', 'Active', 'Active_Pending', 'Cancelled_Pending', 'PartCancelled_Pending' ) AND p.FinancialAssetType = 'Fund' "
			+ "AND p.ProviderProductCode <> '000719' GROUP BY p.ProviderProductCode ) m ON n.providerProductCode = m.providerProductCode;";
```

```
String sql_faap = "SELECT fa.assetNumber AS providerProductCode, ap.price, max(ap.startDate) AS startDate "
				+ "FROM financialasset fa INNER JOIN assetprice ap ON ap.parentId = fa.oid AND ap.priceType = 'fundNavVal' GROUP BY fa.oid";
List<Map<String, Object>> faapMapList = bmfOrmAggrManager.queryForList(sql_faap);

String sql_po = "SELECT * from ProductOffering p where p.FinancialAssetType = 'Fund' AND p.ProviderProductCode <> '000719' GROUP BY p.ProviderProductCode";
List<ProductOffering> productOfferingList = bmfOrmAggrManager.findAllTObjectBySql(sql_po, ProductOffering.class);
```

SQL语句里的问号？代表 参数的意思，也就是需要从外部传入参数。

```
String sql = "select c.oid as clientId, c.firstname as clientName, pr.ordernumber as orderNumber, " //
				+ " DATE_FORMAT(pr.starttime,'%Y%m%d') transactionDate, DATE_FORMAT(pr.starttime,'%H%i%s') transactionTime, " //
				+ " ce.AccountNumber as accountNumber, pr.orderamount as transAmount from paymentrequest pr " //
				+ " left join client c on pr.clientid=c.oid left join clientexternalaccount ce on ce.clientid=c.oid and ce.MerId=? " // 这里的  ？代表参数
				+ " left join agreementrequest ar on pr.agreementrequestid=ar.oid left join productoffering po on ar.targetproductofferingid=po.oid " //ProductOffering zhubiao
				+ " left join productprovider pp on po.ProductProviderId=pp.oid " // productprovider zhubiao
				+ " where pr.businesstype IN ('26','22') and pr.paymentstatus IN ('Active', 'Payed') and pp.MerchantCode=? and pr.starttime >= ? and pr.starttime < ? ";//这里的  ？代表参数
```

# [SQL中的多表查询，以及JOIN的顺序重要么](http://www.cnblogs.com/aguncn/p/6072606.html)



## ArrayList list = new ArrayList() 和List<String> list = new ArrayList<String>() 的区别

第一种形式用当前类作为引用类型，那么可以访问到ArrayList这个类中的所有公用方法。

第二种形式，用ArrayList实现的接口List作为引用类型，那么通过list引用可以访问到接口中定义的方法。也就是说ArrayList这个类实现了List接口，除了要必须实现接口List中声明的方法外，还可以实现额外的一些方法。但是，第二种形式就无法调用的List接口以外的方法。
使用上，设计模式中有：“代码尽量依赖于抽象，不依赖于具体”。

第一种形式就是依赖具体，第二种形式就是依赖于抽象。

因为List是接口。代码依赖于抽象的好处是，代码可以方便替换。例如，代码List list = new ArrayList();下面通过list来操作集合。代码编写后发现集合使用的不准确，应该使用LinkedList，那么只要修改一行代码List list = new LinkedList();就可以，这行以后的代码不需要修改，因为List接口保证了调用的都是接口中的方法，而ArrayList与LinkedList都实现了List接口。而如果当时用ArrayList list = new ArrayList()这种形式的话，那么list访问到的就可能是ArrayList里独有的方法而非List接口中的方法。这样替换成LinkedList的时候就有可能需要修改很多的代码。

ArrayList() 是ArrayList.java的构造方法

## java泛型



```
GenericTest.java
import java.util.List;
import java.util.ArrayList;
public class GenericTest {

    public static void main(String[] args) {
        List list = new ArrayList();
        list.add("qqyumidi");
        list.add("corn");
        list.add(100);

        for (int i = 0; i < list.size(); i++) {
            String name = (String) list.get(i); // 1
            System.out.println("name:" + name);
        }
    }
}
```

命令行编译： javac  GenericTest.java 	// 生成GenericTest.class文件，这里有提示：注: GenericTest.java使用了未经检查或不安全的操作。注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。

```
在jdk1.5后Java加入的泛型--用来对源代码的安全性检查
其中List和Vector类是有泛型的 当然指定List的类型也可以但是编译器会给警告提示你
解决办法：
1、给List和Vector都加上泛型
2、使用jdk1.4的便有一环境
List list = new Vector();改成List<Object> list = new Vector<Object>();
因为你没有指定类型，给你的警告，其实不影响运行的！
```

java GenericTest



```
public class GenericTest {
    public static void main(String[] args) {
        /*
        List list = new ArrayList();
        list.add("qqyumidi");
        list.add("corn");
        list.add(100);
        */
        List<String> list = new ArrayList<String>();
        list.add("qqyumidi");
        list.add("corn");
        //list.add(100);   // 1  提示编译错误
        for (int i = 0; i < list.size(); i++) {
            String name = list.get(i); // 2
            System.out.println("name:" + name);
        }
    }
}
```



 select * from a left join b on a.abid = b.baid left join  c  on c.cbid = b.bcid 
顺序是先a,b组合成一个虚拟表，然后虚拟表再和C表关联

```
String sql = "select c.oid as clientId, c.firstname as clientName, pr.ordernumber as orderNumber, " //
				+ " DATE_FORMAT(pr.starttime,'%Y%m%d') transactionDate, DATE_FORMAT(pr.starttime,'%H%i%s') transactionTime, " //
				+ " ce.AccountNumber as accountNumber, pr.orderamount as transAmount from paymentrequest pr " //
				+ " left join client c on pr.clientid=c.oid left join clientexternalaccount ce on ce.clientid=c.oid and ce.MerId=? " //
				+ " left join agreementrequest ar on pr.agreementrequestid=ar.oid left join productoffering po on ar.targetproductofferingid=po.oid " //ProductOffering zhubiao
				+ " left join productprovider pp on po.ProductProviderId=pp.oid " // productprovider zhubiao
				+ " where pr.businesstype IN ('26','22') and pr.paymentstatus IN ('Active', 'Payed') and pp.MerchantCode=? and pr.starttime >= ? and pr.starttime < ? ";
```

## SQL中的多表查询，以及JOIN的顺序重要么

一般来说，JOIN的顺序不重要，除非你要自己定制driving table。





## java泛型：？T K E V 代表的意思

平时看java源代码的时候，如果碰到泛型的话，我想? T K V E这些是经常出现的，但是有时想不起来代表什么意思，今天整理下： 

？ 表示不确定的java类型。 
T  表示java类型。 
K V 分别代表java键值中的Key Value。 
E 代表Element。 

Object跟这些东西代表的java类型有啥区别呢？ 
Object是所有类的根类，是具体的一个类，使用的时候可能是需要类型强制转换的，但是用T ？等这些的话，在实际用之前类型就已经确定了，不需要强制转换。



# 2017608



## 泛型：List<Map<String, Object>> 与 map<string，list>

Java语言是强类型（strongly typed）语言，意思是每个变量和每个表达式都有一个在编译时，就确定的额理性，所以，所有的变量必须显式声明类型，也就是说，所有的变量必须先声明，后使用。类型限制了一个变量能被赋的值，限制了一个表达式可以产生的值，限制了在这些值上可以进行的操作，并确定了这些操作的含义。

> 强-弱、静态-动态。 上面提到的强类型应该就是静态类型。java是弱类型（自动类型转换）与强制类型转换对应。

Java语言支持的类型分为两类：基本类型（primitive Type）和引用类型（Reference Type）

基本类型：Boolean类型和数值类型。数值类型有整数类型和浮点类型。整数类型包括byte、short、int、long、char，浮点类型包括float和double。

引用类型包括：类、接口和数组类型，还有一种特殊的null类型。

所谓**引用类型**就是对一个对象的引用，对象包括实例和数组两种。实际上**引用类型变量**就是一个**指针**，只是Java语言不再使用指针这个说法。

## JAVA数组类型

python类中的`__init__()`方法相当于java中的构造函数
python和java均可以省略构造函数。
在java类中，如果不显示声明构造函数，JVM 会给该类一个默认的构造函数。
一个类 可以有多个构造函数。
构造函数的主要作用
Java的数组要求所有的数组元素具有相同的数据类型。即一个数组里只能存储一种数据类型，而不能存储多种数据类型的数据。
一旦数组的初始化完成，数组在内存中所占的空间将被固定下来，因此数组的长度讲不可改变。
int[]是一种数据类型， 使用int[]类型来定义变量、进行类型转换时与使用其他普通类型没有任何区别。int[]类型是一种引用类型，创建int[]类型的对象也就是创建数组，需要使用创建数组的语法。

```
type[] arrayname
type arrayname[]
```


## 文件编码格式转换（utf-8、gbk）

使用notepad++打开文件： 格式-->转为***编码格式-->保存。

也有一些批量文件编码转换器，例如： 批量文件GBK-UTF8编码转换器.exe。

## Spring中的RowMapper接口作用

用来把数据库中的列字段和java bean中属性对应上，这样就可以赋值了。	
就像JDBC中的bean.setName(rs.getString("name")); 
Spring把这段代码抽象出来写成RowMapper。

RowMapper可以将数据中的每一行封装成用户定义的类，在数据库查询中，如果返回的类型是用户自定义的类型则需要包装，如果是Java自定义的类型，如：String则不需要，Spring最新的类SimpleJdbcTemplate使用更加简单了。    



# 20170609



## pycharm改变主题theme，以及字体颜色等

pycharm--->file--->settings： 

- Editor-->Colors&Fonts--->选择python，然后又可以点击具体的字体更改其颜色。
- Appearance&Behavior--->appearance可以找到UI Options：theme，override default fonts by （not recommended）：




更改STS的主题改了很久，没搞出啥来。

下一个改这个：

./bam-application/src/main/java/com/mdiaf/recon/service/RYBJobServiceImpl.java:106:             List<Map<String,Object>> RYBSurrenderList = jdbcTemplate.queryForList(sql, startDateString,endDateString);

# 20170611

首先shardingkey

不允许全表查询的，效率太低。

mysql下出现Unknown column 'id' in 'on clause'的解决方法：

原因：

MySQL5.0 Bug, 要把联合的表用括号包含起来才行:

Sql代码  
SELECT (c.id, a.id, b.id) FROM A a, B b LEFT JOIN C c ON c.a_id = a.a_id AND c.b_id = b.b_id  
这句话执行应该是没有错误的,但是Mysql 5 下执行则会出错。

因为mysql下有这样一个BUG,要把联合的表用括号包含起来才行：

Sql代码  
SELECT (c.id, a.id, b.id) FROM (A a, B b) LEFT JOIN C c ON c.a_id = a.a_id AND c.b_id = b.b_id  

