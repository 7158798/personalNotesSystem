[TOC]

# 富聪笔记

# 20170401

pandas dataframe

dataframe.apply()

lambda

secfunc=lambda x: math.floor

dataframe.apply(secfunc)

这样比写循环结构快多了

从mongoDB拉出的时间数据 daatetime 可以直接加减，后 转换为秒，total_sec()







# 20170505

## 桌面远程链接

[win7远程桌面连接设置](https://jingyan.baidu.com/article/49711c612a025cfa451b7c54.html)

win7远程桌面连接[地址][10]

[10]: https://jingyan.baidu.com/article/49711c612a025cfa451b7c54.html	"win7远程桌面连接设置"
![mstsc远程桌面连接](.\imagenote\mstsc远程桌面连接.png)

![远程桌面连接设置](.\imagenote\远程桌面连接.png)





1. 首先要设置好被远程电脑的用户名密码，打开**“控制面板”**

2. 点击“用户账户和家庭安全”

3. 点击“更改密码”

4. 点击“为您的账户创建密码”

5. 输入你要的密码，点击“创建密码”就可以了。

6. 接着打开计算机属性，选择**“远程设置”**

7. 把“允许远程协助连接这台计算机”打钩，下面的“允许运行任意版本远程桌面的计算机连接（较不安全）”选中，其他的不用管它。至此，被远程的计算机已经设置好了，就坐等别人远程就可以了。

8. 先查看被远程的计算机的IP地址（我这里演示的是局域网，注意事项里再说下要注意什么的），我的地址就是172.168.2.101

9. 打开操作电脑的远程程序(`win+R: mstsc`)，填写被远程的IP地址，然后点击“连接”

   ![网络连接详情](.\imagenote\网络连接详情.png)

## markdown的11种基本语法

1. 标题设置（让字体变大，和word的标题意思一样）

2. 块注释（blockquote）:通过在文字开头添加“>”表示块注释。

3. 斜体:将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来

4. 粗体.将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来

5. 无序列表。

   在文字开头添加(`*`, `+`, and `-`)实现无序列表。但是要注意在(`*`, `+`, and `-`)和文字之间需要添加空格。

   （建议：一个文档中只是用一种无序列表的表示方式）

6. 有序列表

   使用数字后面跟上句号。（还要有空格）

7. 链接（Links）。

   Markdown中有两种方式，实现链接，分别为内联方式和引用方式。
   `内联方式：This is an [example link](http://example.com/).`

   `引用方式：I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. `

   ` [1]: http://google.com/        "Google" ` 

   `[2]: http://search.yahoo.com/  "Yahoo Search" `

   `[3]: http://search.msn.com/    "MSN Search"`

8. 图片（Images）。

   图片的处理方式和链接的处理方式，非常的类似。
   `内联方式：``![alt text](/path/to/img.jpg "Title")`

   `引用方式：``![alt text][id] [id]: /path/to/img.jpg "Title"`

9. 代码（HTML中所谓的Code）。

   实现方式有两种：
   第一种：简单文字出现一个代码框。使用`<blockquote>`。（`不是单引号而是左上角的ESC下面~中的`）
   第二种：大片文字需要实现代码框。使用Tab和四个空格。

10. 脚注（footnote）。

  实现方式如下：

  hello[^hello]

[^hello]: hi

11. 下划线。在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题）



## java开发环境搭建完成

spring tool suite



tomcat v7.0 server at localhost

127.0.0.1:8080/bam





![富聪金融业务分析监控系统](.\imagenote\富聪金融业务分析监控系统.PNG)



![富聪金融业务分析监控系统2](.\imagenote\富聪金融业务分析监控系统2.PNG)

### ETL（ Extract-Transform-Load）

#### ETL是什么

ETL是Extract Transform Load三个英文单词的缩写 中文意思就是抽取、转换、加载。说到ETL就必须提到数据仓库。

#### 背景知识

信息是现代企业的重要资源，是企业运用科学管理、决策分析的基础。目前，大多数企业花费大量的资金和时间来构建**联机事务处理OLTP的业务系统**和办公自动化系统（例如电信行业的各种运营支撑系统、购物网站系统），用来记录事务处理的各种相关数据。据统计，数据量每2～3年时间就会成倍增长，这些数据蕴含着巨大的商业价值，而企业所关注的通常只占在总数据量的2%～4%左右。因此，企业仍然没有最大化地利用已存在的数据资源，以致于浪费了更多的时间和资金，也失去制定关键商业决策的最佳契机。

在这个背景下，能够给企业所有级别的决策制定过程提供支持的所有类型数据的战略集合应运而生，他就是**数据仓库**。数据仓库的英文简写是**Data Warehouse**。**数据仓库**就是把**OLTP系统**产生的数据 整合到一起 发掘其中的商业价值和提供决策支持用。**举个电信行业的例子** 电信有系统每天会有客户投诉的信息、宽带群体性障碍、客户号码的停机恢复时间记录等等。这些数据都在各自的生产环境系统里面。**他们每个月会把这些数据整合到一起处理加工到数据仓库里面形成报表** 其中有一个功能是可以对哪些用户有离网销号的倾向做出大概的判断。这就是数据仓库的价值所在。

> #### OLTP(On_line Transaction Processing联机事务处理)，OLAP(On_line Analytical Processing联机分析处理)
>
> OLTP：On_line Transaction Processing **联机事务处理** 
> OLAP：On_line Analytical Processing  **联机分析处理**
> OLTP 顾名思义，以业务处理为主。
>
> OLAP则是专门为支持复杂的分析操作而设计的，侧重于对决策人员和高层管理人员的决策支持，可以应分析人员的要求快速、灵活地进行[大数据](http://lib.csdn.net/base/hadoop)量的复杂查询处理，并以一直直观的形式把查询结果提供。
>
> OLTP与OLAP 的主要区别有以下几点：
>
> 1. 所面向的用户和系统：OLTP是面向**客户**的，由职员或客户进行事务处理或者查询处理。OLAp是向向**市场**的，由经理、主管和分析人员进行数据分析和决策的。
>
> 2. 数据内容：OLTP系统管理当前数据，这些数据通常很琐碎，难以用于决策。OLAP系统管理大量历史数据，提供汇总和聚集机制，并在不同的粒度级别上存储和管理信息，这些特点使得数据适合于决策分析。
>
> 3. [数据库](http://lib.csdn.net/base/mysql)设计：通常，OLTP采用ER模型和面向应用的数据库设计，而OLAP系统通常采用星型模式或雪花模式和面向主题的数据库设计。
>
> 4. 视图：OLTP系统主要关注一个企业或部门的当前数据，而不涉及历史数据或不同组织的数据。与之相反，OLAP系统常常跨越一个企业的数据库模式的多个版本，OLAP系统也处理来自不同组织的信息，由多个数据源集成的信息。
>
> 5. 访问模式：OLTP系统的访问主要由短的原子事务组成，这种系统需要并发控制和恢复机制。而OLAP系统的访问大部份是只读操作，其中大部份是复杂查询。
>
> 6. 度量：OLTP专注于日常时实操作，所以以事务吞吐量为度量，OLAP以查询吞吐量和响应时间来度量。
>
>    | --------------------- | ------------------------------------ | --------------------------------------------------- |
>    | --------------------- | :----------------------------------: | :--------------------------------------: |
>    |                       |                 OLTP                 |                   OLAP                   |
>    | 用户                    |             操作人员,低层管理人员              |               决策人员,高级管理人员                |
>    | 功能                    |                日常操作处理                |                   分析决策                   |
>    | DB 设计                 |                 面向应用                 |                   面向主题                   |
>    | 数据                    |         当前的, 最新的细节的, 二维的分立的          |          历史的, 聚集的, 多维的集成的, 统一的           |
>    | 存取                    |               读/写数十条记录               |                 读上百万条记录                  |
>    | 工作单位                  |                简单的事务                 |                  复杂的查询                   |
>    | 用户数                   |                 上千个                  |                   上百个                    |
>    | DB 大小                 |               100MB-GB               |                 100GB-TB                 |
>
>    | --------------------------------- | ----------------------------------- |
>    | :-------------------------------: | :---------------------------------: |
>    |              OLTP数据               |               OLAP数据                |
>    |               原始数据                |                导出数据                 |
>    |               细节性数据               |              综合性和提炼性数据              |
>    |               当前值数据               |                历史数据                 |
>    |                可更新                |             不可更新，但周期性刷新             |
>    |             一次处理的数据量小             |              一次处理的数据量大              |
>    |             面向应用，事务驱动             |              面向分析，分析驱动              |
>    |           面向操作人员，支持日常操作           |            面向决策人员，支持管理需要            |
>
>    ​

*那么怎么把数据弄到数据仓库里去呢，其中用道德一个技术就是ETL。*

#### 给下ETL的详细解释定义

ETL(Extract-Transform-Load的缩写，即数据抽取、转换、装载的过程)作为DW的核心和灵魂，能够按照统一的规则集成并提高数据的价值，是负责完成**数据从数据源向目标数据仓库转化的过程**，是实施数据仓库的重要步骤。如果说**数据仓库的模型设计是一座大厦的设计蓝图，数据是砖瓦的话，那么ETL就是建设大厦的过程。**在整个项目中最难部分是用户需求分析和模型设计，而ETL规则设计和实施则是工作量最大的，约占整个项目的60%～80%，这是国内外从众多实践中得到的普遍共识。
ETL是数据抽取（Extract）、清洗（Cleaning）、转换（Transform）、装载（Load）的过程。是构建数据仓库的重要一环，用户从数据源抽取出所需的数据，经过数据清洗,最终按照预先定义好的数据仓库模型，将数据加载到数据仓库中去。
于是，企业如何通过各种技术手段，并把数据转换为信息、知识，已经成了提高其核心竞争力的主要瓶颈。而ETL则是主要的一个技术手段。

做数据仓库系统，ETL是关键的一环。说大了，ETL是数据整合解决方案，说小了，就是倒数据的工具。

现在来说说**ETL技术用到的工具，常用的有Informatica、Datastage、Beeload、Kettle等**。目前只用过kettle，所以这里只对kettle做描述。

kettle是一款国外开源的ETL工具，纯[Java](http://lib.csdn.net/base/javase)编写，可以在Window、[Linux](http://lib.csdn.net/base/linux)、Unix上运行，kettle 3版本需要安装 3以上都是绿色版无需安装。

*提醒的是kettle运行 需要机器有JRE环境*

Kettle这个ETL工具集，它允许你管理来自不同[数据库](http://lib.csdn.net/base/mysql)的数据，通过提供一个图形化的用户环境来描述你想做什么。
Kettle中有两种脚本文件，transformation和job，transformation完成针对数据的基础转换，job则完成整个工作流的控制。

**商务智能（BI）**

不同的瞎子对大象的认识不同，因为他们只认识了自己摸到的地方。而企业如果要避免重犯这样的错误，那就离不开商务[智能](http://lib.csdn.net/base/aiplanning)（BI）。专家认为，BI对于企业的重要性就像聪明才智对于个人的重要性。欧美企业的经验也证明，企业避免无知和一知半解危险的有效手段就是商务智能。商务智能旨在充分利用企业在日常经营过程中收集的大量数据和资料，并将它们转化为信息和知识来免除各种无知状态和瞎猜行为。

确切地讲，BI并不是一项新技术，它将数据仓库(DW)、联机分析处理(OLAP)、数据挖掘(DM)等技术与客户关系管理（CRM）等结合起来应用于商业活动实际过程当中，实现了技术服务于决策的目的；Mark Hammond从管理的角度看待BI，认为BI是从“根本上帮助你把公司的运营数据转化成为高价值的可以获取的信息（或者知识），并且在恰当的时间通过恰当的手段把恰当的信息传递给恰当的人”。 

**ETL** 
ETL即数据抽取（Extract）、转换（Transform）、装载（Load）的过程。它是构建数据仓库的重要环节。数据仓库是面向主题的、集成的、稳定的且随时间不断变化的数据集合，用以支持经营管理中的决策制定过程。数据仓库系统中有可能存在着大量的噪声数据,引起的主要原因有：滥用缩写词、惯用语、数据输入错误、重复记录、丢失值、拼写变化等。即便是一个设计和规划良好的[数据库](http://lib.csdn.net/base/mysql)系统，如果其中存在着大量的噪声数据，那么这个系统也是没有任何意义的，因为“垃圾进，垃圾出”（garbage in, garbage out），系统根本就不可能为决策分析系统提供任何支持。为了清除噪声数据，必须在数据库系统中进行数据清洗。目前有不少数据清洗研究和ETL研究，但是如何在ETL过程中进行有效的数据清洗并使这个过程可视化，此方面研究不多。本文主要从两个方面阐述ETL和数据清洗的实现过程：ETL的处理方式[19]和数据清洗的实现方法。 

ETL，是英文Extract-Transform-Load的缩写，即填充、更新数据仓库的数据抽取、转换、装载的过程。这是实现[商业智能](http://www.chinabi.net/)之前的数据采集步骤。这一步骤完成之后，对库中数据的数据挖掘、分析处理才可以进行。

对于ETL而言，“是什么”是很容易理解的，也就是将分散的、不易利用的数据进行整理，变成规则清晰的、易于利用的、（可能同时还是）集中的数据。在ETL过程之外，就可以基于报表分析系统、多维分析系统和数据挖掘系统等，进行进一步的数据分析利用。

这一过程可以通过Hard Codding，即编写程序实现，也可以通过各种ETL工具实现。

当今的数据处理大致可以分成两大类：联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Processing）。OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。 
OLAP是使分析人员、管理人员或执行人员能够从多角度对信息进行快速、一致、交互地存取,从而获得对数据的更深入了解的一类软件技术。OLAP的目标是满足决策支持或者满足在多维环境下特定的查询和报表需求,它的技术核心是"维"这个概念。

@  BI 就是[智能](http://lib.csdn.net/base/aiplanning)决策分析工具。Power-BI 就是一个典型的例子。
@  TL分别是Extract（数据抽取）、 Transform（转换）、 Loading（装载）三个英文单词的首字母缩写。
@  线上分析处理（On-Line Analytical Processing,简称OLAP），是一套以多维度方式分析资料，而能弹性地提供积存(Roll-up)、下钻(Drill-down)、和枢纽分析(pivot)等操作，呈现整合性决策资讯的方法，多用于决策支持系统、商务智能或数据仓库。其主要的功能，在于方便大规模数据分析及统计计算，对决策提供参考和支持。与之相区别的是线上交易处理(OLTP)。

OLAP技术联机分析处理(OLAP)的概念最早是由关系数据库之父E.F.Codd于1993年提出的。当时，Codd认为联机事务处理(OLTP)已不能满足终端用户对数据库查询分析的需要，SQL对[大数据](http://lib.csdn.net/base/hadoop)库进行的简单查询也不能满足用户分析的需求。用户的决策分析需要对关系数据库进行大量计算才能得到结果，而查询的结果并不能满足决策者提出的需求。因此Codd提出了多维数据库和多维分析的概念，即OLAP。

#### 商业智能BI体系结构



![商业智能BI体系结构](.\imagenote\商业智能BI体系结构.jpg)

在此大概用口水话简单叙述一下他们几个概念：

（1）**DB/Database/数据库**——这里一般指的就是OLTP数据库，在线事物数据库，用来支持生产的，比如超市的买卖系统。DB保留的是数据信息的最新状态，只有一个状态！比如，每天早上起床洗脸照镜子，看到的就是当时的状态，至于之前的每天的状态，不会出现的你的眼前，这个眼前就是db。

（2）**DW/Data Warehouse/数据仓库**——这里保存的是DB中的不同时间点的状态，比如，每天早上洗完照镜子时，都拍一张照片，天天这样，这些照片放入到一个相册中，之后就可以查看每一天的状态了，这个相册就是数据仓库，他保存的是数据在不同时间点的状态，对同一个数据信息，保留不同时间点的状态，就便于我们做统计分析了。

（3）**ETL/Extraction-Transformation-Loading**——用于完成DB到DW的数据转存，它将DB中的某一个时间点的状态，“抽取”出来，根据DW的存储模型要求，“转换”一下数据格式，然后再“加载”到DW的一个过程，这里需要强调的是，DB的模型是ER模型，遵从范式化设计原则，而DW的数据模型是雪花型结构或者星型结构，用的是面向主题，面向问题的设计思路，所以DB和DW的模型结构不同，需要进行转换。 
（4）**OLAP——在线分析系统**，简单说就是报表系统，销售报表，统计报表，等等，这个大家都熟悉，当然，OLAP的统计要更复杂更丰富一些，比如切面，钻取等等。 
（5）**DM/Data Mining/数据挖掘**——这个挖掘，不是简单的统计了，他是根据概率论的或者其他的统计学原理，将DW中的大数据量进行分析，找出我们不能直观发现的规律，比如，如果我们每天早上照相，量身材的时候，还记录下头一天吃的东西，黄瓜，猪腿，烤鸭，以及心情，如果记录上10年，形成了3650天的相貌和饮食心情的数据，我们每个人都记录，有20万人记录了，那么，我们也许通过这些记录，可以分析出，身材相貌和饮食的客观规律；再说一个典型的实例，就是英国的超市，在积累了大量数据之后，对数据分析挖掘之后，得到了一个规律：将小孩的尿布和啤酒放在一起，销量会更好——业务专家在得到该结论之后，仔细分析，知道了原因，因为英国男人喜欢看足球的多，老婆把小孩介绍男人看管，小孩尿尿需要尿布，而男人看足球喜欢喝酒，所以两样商品有密切的关系，放在一起销售会更好！

（6）**BI/Business Intelligence/商业智能**——领导，决策者，在获取了OLAP的统计信息，和DM得到的科学规律之后，对生产进行适当的调整，比如，命令超市人员将啤酒喝尿布放在一起销售，这就反作用于DB修改存货数据了——这就是整个BI的作用！

信息技术经过近20年的大力发展，很多行业积累了很多珍贵的数据，真正的大数据时代到来了，也逐渐体现出 DB-ETL-DW-OLAP-DM-BI这条线路的重要性，希望大家能懂得这个大数据时代的价值，把握住机遇，有更加美好的未来！

### eclipse 查看原始类出现The jar file rt.jar has no source attachment

作为一名菜鸟，查看[Java](http://lib.csdn.net/base/javase) 源码非常重要。而在eclipse中查看一个类的源码是非常方便的，直接**按住 ctrl** + **鼠标点击的那个类或方法**，**那么这个类或方法的源码就会出现。**不过在此之前，需要先在eclipse中导入源码 src.zip.

这个源码src.zip不需要下载，只要你安装了jdk，那么在jdk安装的目录下就会有src.zip，无需解压，下面看一下怎么把源码导入eclipse中。

1.进入eclipse界面，依次点击 Window -- Preferences -- Java -- Installed JREs

![Eclipse_javasourcecode1](.\imagenote\Eclipse_javasourcecode1.png)

2.选中 D:\java\lib\rt.jar ，然后选择 Source Attachment

![Eclipse_javasourcecode2](.\imagenote\Eclipse_javasourcecode2.png)

3.选择 External location ，点击 External File 浏览安装jdk的目录，找到src.zip，一次点击ok，finish 即可

![](.\imagenote\Eclipse_javasourcecode3.png)



# 20170509

## 查看电脑硬件配置信息

DirectX诊断工具
win+R-->dxdiag
或者 计算机-->管理-->设备管理器

CPU-Z是一款家喻户晓的CPU检测软件，是检测CPU使用程度最高的一款软件，除了使用Intel或AMD自己的检测软件之外，我们平时使
用最多的此类软件就数它了。
CPU-Z is a freeware that gathers information on some of the main devices of your system.

SPD是内存模组上面的一个可擦写的ROM，里面记录了该内存的许多重要信息，诸如内存的芯片及模组厂商、工作频率、工作电压、速
度、容量、电压与行、列地址带宽等参数。SPD信息一般都是在出厂前，由内存模组制造商根据内存芯片的实际性能写入到ROM芯片中
。



## 用ETL组件实现和sql相比哪个效率高

我现在正在做BI相关的东西。如果ETL和SQL来说，肯定是SQL效率高的多。但是双方各有优势，

先说ETL，ETL主要面向的是建立数据仓库来使用的。ETL更偏向数据清洗，多数据源数据整合，获取增量，转换加载到数据仓库所使用的工具。比如我有两个数据源，一个是数据库的表，另外一个是excel数据，而我需要合并这两个数据，通常这种东西在SQL语句中比较难实现。但是ETL却有很多现成的组件和驱动，几个组件就搞定了。还有比如跨服务器，并且服务器之间不能建立连接的数据源，比如我们公司系统分为一期和二期，存放的数据库是不同的，数据结构也不相同，数据库之间也不能建立连接，这种情况下，ETL就显得尤为重要和突出。通过固定的抽取，转换，加载到数据仓库中，即可很容易。

那么SQL呢？SQL事实上只是固定的脚本语言，但是执行效率高，速度快。不过灵活性不高，很难跨服务器整合数据。所以SQL更适合在固定数据库中执行大范围的查询和数据更改，由于脚本语言可以随便编写，所以在固定数据库中能够实现的功能就相当强大，不像ETL中功能只能受组件限制，组件有什么功能，才能实现什么功能。

所以具体我们在什么时候使用ETL和SQL就很明显了，当我们需要多数据源整合建立数据仓库，并进行数据分析的时候，我们使用ETL。如果是固定单一数据库的数据层次处理，我们就使用SQL。当然，ETL也是离不开SQL的。

## elasticsearch

ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于[云计算](http://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97)中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。



## ETL的实现

ETL的实现有多种方法，常用的有三种。一种是借助ETL工具（如Oracle的 OWB、SQLServer2000的DTS、SQLServer2005的SSIS服务、Informatic等）实现，一种是SQL方式实现，另外一种是ETL工具和SQL相结合。前两种方法各有各的优缺点，借助工具可以快速的建立起ETL工程，屏蔽了复杂的编码任务，提高了速度，降低了难度，但是缺少灵活性。SQL的方法优点是灵活，提高ETL运行效率，但是编码复杂，对技术要求比较高。第三种是综合了前面二种的优点，会极大地提高ETL的开发速度和效率。

通过ETL，我们可以基于源系统中的数据来生成数据仓库。ETL为我们搭建了OLTP系统和OLAP系统之间的桥梁，是数据从源系统流入数据仓库的通道。在数据仓库的项目实施中，它关系到整个项目的数据质量，所以马虎不得，必须将其摆到重要位置，将数据仓库这一大厦的根基筑牢!

ETL的设计分三部分：数据抽取、数据的清洗转换、数据的加载。

在设计ETL的时候我们也是从这三部分出发。

**数据的抽取**是**从各个不同的数据源抽取到ODS（OperationalDataStore，操作型数据存储） 中**——这个过程也可以做一些数据的清洗和转换），在抽取的过程中需要挑选不同的抽取方法，尽可能的提高ETL的运行效率。ETL三个部分中，花费时间最长的是“T”（Transform，清洗、转换）的部分，一般情况下这部分工作量是整个ETL的2/3。数据的加载一般在数据清洗完了之后直接写入DW （DataWarehousing，数据仓库）中去。

ETL的实现有多种方法，常用的有三种。

1. 一种是借助ETL工具（如Oracle的 OWB、SQLServer2000的DTS、SQLServer2005的SSIS服务、Informatic等）实现，
2. 一种是SQL方式实现，
3. 另外一种是ETL工具和SQL相结合。

前两种方法各有各的优缺点，借助工具可以快速的建立起ETL工程，屏蔽了复杂的编码任务，提高了速度，降低了难度，但是缺少灵活性。SQL的方法优点是灵活，提高ETL运行效率，但是编码复杂，对技术要求比较高。第三种是综合了前面二种的优点，会极大地提高ETL的开发速度和效率。



数据抽取（Extract）、转换（Transform）、装载（Load）的过程，它是构建数据仓库的重要环节。







### 一，数据抽取(Extract)

这一部分需要在调研阶段做大量的工作，首先要搞清楚**数据是从几个业务系统中来**,**各个业务系统的数据库服务器运行什么DBMS**，**是否存在手工数据，手工数据量有多大****，**是否存在非结构化的数据等等**，当收集完这些信息之后才可以进行数据抽取的设计。

　　1、对于**与存放DW的数据库系统相同的数据源**处理方法

　　这一类数据源在设计上比较容易。一般情况下，DBMS（SQLServer、Oracle）都会提供**数据库链接功能**，在DW数据库服务器和原业务系统之间建立直接的链接关系就可以写Select语句直接访问。

　　2、对于**与DW数据库系统不同的数据源**的处理方法

　　对于这一类数据源，一般情况下也可以通过ODBC的方式建立数据库链接——如 SQLServer和Oracle之间。**如果不能建立数据库链接，可以有两种方式完成**，**一种是**通过工具将源数据导出成.txt或者是.xls文件，然后再将这些源系统文件导入到ODS中。另外一种方法是通过程序接口来完成。

> 操作数据存储ODS（Operational Data Store）是数据仓库体系结构中的一个可选部分，ODS具备数据仓库的部分特征和[OLTP](http://baike.baidu.com/item/OLTP)系统的部分特征，它是“面向主题的、集成的、当前或接近当前的、不断变化的”数据。是一个面向主题的、集成的、可变的、当前的细节数据集合，用于支持企业对于即时性的、操作性的、集成的全体信息的需求。
>
> ods是短期的实时的数据，供产品或者运营人员日常使用，而数据仓库是供战略决策使用的数据；ods是可以更新的数据，数据仓库是基本不更新的反应历史变化的数据，还有很多，这里就不一一列举了。
>
> 如何能搭建一个体系，既能支持战略决策使用的数据仓库数据，又能兼容业务快速的变化和运营产品人员日常需求的ODS数据哪？
>
> 经过调研，发现大体上有三种解法：
>
> 1、业务数据 － ODS － 数据仓库
>
> ![ODS_DW](.\imagenote\ODS_DW.png)
>
> 优点：这样做的好处是ODS的数据与数据仓库的数据高度统一；开发成本低，至少开发一次并应用到ODS即可；可见ODS是发挥承上启下的作用，调研阿里巴巴的数据部门也是这么实现的。缺点：数据仓库需要的所有数据都需要走ODS，那么ODS的灵活性必然受到影响，甚至不利于扩展、系统的灵活性差.
>
> 2、OB － ODS
>
> 优点：结构简单。一般的初创数据分析团队都是类似的结构，比如我们部门就应该归结到这一范畴
>
> 缺点：这样所有数据都归结到ODS，长期数据决策分析能力差，软硬件成本高，模块划分不清晰，通用性差
>
> 3、数据仓库和ODS并行
>
> 可见这个模型兼顾了上面提高的各自优点，且便于扩展，ODS和数据仓库各做各的，形成优势互补！可以解决现在互联网公司遇到的快速变化、快速开发等特点！特别是对于那些刚刚创建数据团队，数据开发人员紧缺的公司，可以尝试使用这个数据架构解决问题！
>
> ![](.\imagenote\ODS_DW2.png)



　　3、对于文件类型数据源（.txt,.xls），可以培训业务人员利用数据库工具将这些数据导入到指定的数据库，然后从指定的数据库中抽取。或者还可以借助工具实现，如SQLServer2005的SSIS服务的平面数据源和平面目标等组件导入ODS中去。

　　4、增量更新的问题

　　对于数据量大的系统，必须考虑增量抽取。一般情况下，业务系统会记录业务发生的时间，我们可以用来做增量的标志,每次抽取之前首先判断ODS中记录最大的时间，然后根据这个时间去业务系统取大于这个时间所有的记录。利用业务系统的时间戳，一般情况下，业务系统没有或者部分有时间戳。

### 二、数据的清洗转换

　　一般情况下，数据仓库分为ODS、DW两部分。通常的做法是从业务系统到ODS做清洗，将脏数据和不完整数据过滤掉，在从ODS到DW的过程中转换，进行一些业务规则的计算和聚合。

1、数据清洗

　　数据清洗的任务是过滤那些不符合要求的数据，将过滤的结果交给业务主管部门，确认是否过滤掉还是由业务单位修正之后再进行抽取。不符合要求的数据主要是有不完整的数据、错误的数据、重复的数据三大类。

　　（1）不完整的数据：这一类数据主要是一些应该有的信息缺失，如供应商的名称、分公司的名称、客户的区域信息缺失、业务系统中主表与明细表不能匹配等。对于这一类数据过滤出来，按缺失的内容分别写入不同Excel文件向客户提交，要求在规定的时间内补全。补全后才写入数据仓库。

　　（2）错误的数据：这一类错误产生的原因是业务系统不够健全，在接收输入后没有进行判断直接写入后台数据库造成的，比如数值数据输成全角数字字符、字符串数据后面有一个回车操作、日期格式不正确、日期越界等。这一类数据也要分类，对于类似于全角字符、数据前后有不可见字符的问题，只能通过写SQL语句的方式找出来，然后要求客户在业务系统修正之后抽取。日期格式不正确的或者是日期越界的这一类错误会导致ETL运行失败，这一类错误需要去业务系统数据库用SQL的方式挑出来，交给业务主管部门要求限期修正，修正之后再抽取。

　　（3）重复的数据：对于这一类数据——特别是维表中会出现这种情况——将重复数据记录的所有字段导出来，让客户确认并整理。

　　数据清洗是一个反复的过程，不可能在几天内完成，只有不断的发现问题，解决问题。对于是否过滤，是否修正一般要求客户确认，对于过滤掉的数据，写入Excel文件或者将过滤数据写入数据表，在ETL开发的初期可以每天向业务单位发送过滤数据的邮件，促使他们尽快地修正错误,同时也可以做为将来验证数据的依据。数据清洗需要注意的是不要将有用的数据过滤掉，对于每个过滤规则认真进行验证，并要用户确认。

2、数据转换

　　数据转换的任务主要进行不一致的数据转换、数据粒度的转换，以及一些商务规则的计算。

　　（1）不一致数据转换：这个过程是一个整合的过程，将不同业务系统的相同类型的数据统一，比如同一个供应商在结算系统的编码是XX0001,而在CRM中编码是YY0001，这样在抽取过来之后统一转换成一个编码。

　　（2）数据粒度的转换：业务系统一般存储非常明细的数据，而数据仓库中数据是用来分析的，不需要非常明细的数据。一般情况下，会将业务系统数据按照数据仓库粒度进行聚合。

　　（3）商务规则的计算：不同的企业有不同的业务规则、不同的数据指标，这些指标有的时候不是简单的加加减减就能完成，这个时候需要在ETL中将这些数据指标计算好了之后存储在数据仓库中，以供分析使用。



## 网易金融业务分析监控系统sql

navicat是测试数据库

https://www.fc18.com.cn/bam/Baf/BafSqlCommand是生产库

navicat不加分号`；`也可以运行

但是生产库必须要加上分号`；`

`select client.oid,IdNumber from client where IdNumber REGEXP '371323199.*';`



# 20170510



`INNER JOIN`     等价于   `JOIN`
你可以理解为  `JOIN` 　　是  `INNER JOIN`   的缩写。
`LEFT JOIN`  等价于   `LEFT  OUTER   JOIN`
`RIGHT JOIN`  等价于   `RIGHT OUTER   JOIN`

## sql例子-www.fc18.com.cn/bam/Baf/BafSqlCommand

> 注册时间超过3个月 并且 历史投资金额累计超过5万或者现金存款仍大于一万客户名单（姓名，手机号，客户ID）
>

`SELECT c.oid,c.FirstName,sum(ac.CurrentBalance),sum(ar.TransAmount)`
`FROM 	client c`
`JOIN agreement ag ON ag.ClientId = c.oid and ag.AgreementLevel ='Root' and ag.ProductCategoryCode not in ('TYJ','JXQ')`
`JOIN account ac ON ac.AgreementId = ag.oid`
`JOIN agreementrequest ar ON ar.AgreementId = ag.oid AND ar.TransType IN ('Deposit', 'AddDeposit') and ar.TransStatus ='Active'`
`WHERE CURRENT_DATE - date(c.createdOn) >100` 
`GROUP BY c.oid HAVING (sum(ac.CurrentBalance)>=10000) OR (sum(ar.TransAmount)>=50000)` 
`ORDER BY sum(ar.TransAmount);`





## sql语句顺序



SQL 不同于与其他编程语言的最明显特征是处理代码的顺序。在大数编程语言中，代码按编码顺序被处理，但是在SQL语言中，第一个被处理的子句是FROM子句，尽管SELECT语句第一个出现，但是几乎总是最后被处理。

每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者（客户端应用程序或者外部查询）不可用。只是最后一步生成的表才会返回 给调用者。如果没有在查询中指定某一子句，将跳过相应的步骤。

select子句及其顺序**

| 子句       | 说明        | 是否必须使用      |
| -------- | --------- | ----------- |
| select   | 要返回的列或表达式 | 是           |
| from     | 从中检索数据的表  | 仅在从表选择数据时使用 |
| where    | 行级过滤      | 否           |
| group by | 分组说明      | 仅在按组计算聚集时使用 |
| having   | 组级过滤      | 否           |
| order by | 输出排序顺序    | 否           |
| limit    | 要检索的行数    | 否           |
|          |           |             |





> `(8)SELECT (9)DISTINCT  (11)<Top Num> <select list>`
> `(1)FROM [left_table]`
> `(3)<join_type> JOIN <right_table>`
> `(2)ON <join_condition>`
> `(4)WHERE <where_condition>`
> `(5)GROUP BY <group_by_list>`
> `(6)WITH <CUBE | RollUP>`
> `(7)HAVING <having_condition>`
> `(10)ORDER BY <order_by_list>`



**逻辑查询处理阶段简介**

1. **FROM：**对FROM子句中的前两个表执行笛卡尔积（Cartesian product)(交叉联接），生成虚拟表VT1
2. **ON：**对VT1应用ON筛选器。只有那些使<join_condition>为真的行才被插入VT2。
3. **OUTER(JOIN)：**如 果指定了OUTER JOIN（相对于CROSS JOIN 或(INNER JOIN),保留表（preserved table：左外部联接把左表标记为保留表，右外部联接把右表标记为保留表，完全外部联接把两个表都标记为保留表）中未找到匹配的行将作为外部行添加到 VT2,生成VT3.如果FROM子句包含两个以上的表，则对上一个联接生成的结果表和下一个表重复执行步骤1到步骤3，直到处理完所有的表为止。
4. **WHERE：**对VT3应用WHERE筛选器。只有使<where_condition>为true的行才被插入VT4.
5. **GROUP BY：**按GROUP BY子句中的列列表对VT4中的行分组，生成VT5.
6. **CUBE|ROLLUP：**把超组(Suppergroups)插入VT5,生成VT6.
7. **HAVING：**对VT6应用HAVING筛选器。只有使<having_condition>为true的组才会被插入VT7.
8. **SELECT：**处理SELECT列表，产生VT8.
9. **DISTINCT：**将重复的行从VT8中移除，产生VT9.
10. **ORDER BY：**将VT9中的行按ORDER BY 子句中的列列表排序，生成游标（VC10).
11. **TOP：**从VC10的开始处选择指定数量或比例的行，生成表VT11,并返回调用者。



# 20170511



sourcetree：命令行模式，是 sourcetree本身的git，不是 gitbash那个



git账户:shidexiao sswsdx@163.com

密码：zxcv1234



sourcetree: 武刚建了分支，我需要先从远程 origin找到 分支 检出（checkout），然后获取分支。



maven：Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。

Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。

spring tool suite:

JAR包：jar包就是别人已经**写好的一些类**，然后**将这些类进行打包**，你可以**将这些jar包引入你的项目中**，然后就可以**直接使用这些jar包中的类和属性以及方法**。
**JAR（Java ARchive）**是**将一系列文件合并到单个压缩文件里，就象Zip那样**。然而，同Java中其他任何东西一样，JAR文件是跨平台的，所以不必关心涉及具体平台的问题。

涉及因特网应用时，JAR文件显得特别有用。在JAR文件之前，Web浏览器必须重复多次请求Web服务器，以便下载完构成一个“程序片”（Applet）的所有文件。除此以外，每个文件都是未经压缩的。但在将所有这些文件合并到一个JAR文件里以后，只需向远程服务器发出一次请求即可。同时，由于采用了压缩技术，所以可在更短的时间里获得全部数据。



# 20170512



内网IP地址 192.~.~.~

公司内网需要使用vpn

艳茹的IP地址是193.168.1.9

内网IP地址只是内部使用，其他内网可能也有相同的IP地址。

外网IP地址

我的公网IP地址（百度到的）58.247.2.58

内网IP地址：192.168.1.206

ping一下




## java变量：成员变量、类变量、局部变量

变量名首字母使用小写，如果由多个单词组成，从第2个单词开始的其他单词的首字母使用大写。

如果局部变量的名字和成员变量的名字相同，要想在该方法中使用成员变量，必须使用关键字`this`

source-->add block comment :ctrl+shift+/

source-->remove block comment: ctrl+shift+/







## 内网IP、外网IP

内网IP地址、外网IP地址这个概念并不是固定的，而是相对的。如果用私有IP、公网IP或者局域网IP、互联网IP来理解就容易多了。

Address Block                    Name                              RFC                       
0.0.0.0/8                        "This host on this network"       [RFC1122], section 3.2.1.3
10.0.0.0/8                       Private-Use                       [RFC1918]                 
100.64.0.0/10                    Shared Address Space              [RFC6598]                 
127.0.0.0/8                      Loopback                          [RFC1122], section 3.2.1.3
169.254.0.0/16                   Link Local                        [RFC3927]                 
172.16.0.0/12                    Private-Use                       [RFC1918]                 
192.0.0.0/24[2]                  IETF Protocol Assignments         [RFC6890], section 2.1    
192.0.0.0/29                     IPv4 Service Continuity Prefix    [RFC7335]                 
192.0.0.8/32                     IPv4 dummy address                [RFC7600]                 
192.0.0.9/32                     Port Control Protocol Anycast     [RFC-ietf-pcp-anycast-08] 
192.0.0.170/32, 192.0.0.171/32   NAT64/DNS64 Discovery             [RFC7050], section 2.2    
192.0.2.0/24                     Documentation (TEST-NET-1)        [RFC5737]                 
192.31.196.0/24                  AS112-v4                          [RFC7535]                 
192.52.193.0/24                  AMT                               [RFC7450]                 
192.88.99.0/24                   Deprecated (6to4 Relay Anycast)   [RFC7526]                
192.168.0.0/16                   Private-Use                       [RFC1918]                 
192.175.48.0/24                  Direct Delegation AS112 Service   [RFC7534]                 
198.18.0.0/15                    Benchmarking                      [RFC2544]                 
198.51.100.0/24                  Documentation (TEST-NET-2)        [RFC5737]                 
203.0.113.0/24                   Documentation (TEST-NET-3)        [RFC5737]                 
240.0.0.0/4                      Reserved                          [RFC1112], section 4      
255.255.255.255/32               Limited Broadcast                 [RFC919], section 7 

如上表，运营商给你的100.64.*.*也是私有地址（因为地主家也没有余量啊，以前大家大家共享一个地址池，有随机的公网地址，现在公网地址更加紧张，运营商只给客户分配私网地址，然后nat后大家共享一个公网地址），《盗梦空间》看过吧，二重梦境，你用路由器上网也就是二重局域网。也就是说：如果内网、外网是指**私有地址与公网地址的话，那么100.64.0.30和192.168.1.101都是内网IP**，你没有外网IP。如果内网、外网是**相对你路由器来讲，那么100.64.0.30是外网IP，192.168.1.101是内网IP**。

问题1：不用家庭路由器，直接电脑分配到100.64.0.30，那么理论上100.64.0.1-100.64.0.254的确可以直接通讯，无需运营商路由。但实际上是通过各种技术做了隔离的。你无法访问他们。

问题2：因为你路由器获取的地址仍然是私网地址，所以你在外部连路由器都无法访问。除非在运营商的设备上做端口映射才能访问到路由器。



## FC ORM API用户手册

随着公司业务增长的和产品开发迭代的需求，现有的api和数据库架构需要迁移到适应水平分库的架构中来。新的ORM API实现的分库的访问，需要开发人员在后续的开发中掌握和使用。

> 对象关系映射（object relation mapping，简称ORM）是一种程序技术，用于实现**面向对象编程语言**里**不同类型系统的数据之间的转换**。
>
> 面向对象是从软件工程基本原则（如耦合、聚合、封装）的基础上发展起来的，
>
>       内聚（本题的聚合）：内聚是指一个模块内部各个部分之间的关联程度
>       耦合：耦合指各个模块之前的关联程度      
>       封装原则：隐藏对象的属性和实现细节，仅对外公开借口，并且控制访问级别
>       在面向对象方法中，用类来实现上面的要求。用类实现封装，用封装来实现高内聚，低耦合。
> 而关系数据库则是从数学理论发展而来的，
>
> > **高内聚低耦合**：其实就是为了更好的代码重用。把握好代码重用这关就好了，其它的概念都是扯淡











# 20170515



`<span>` 在CSS定义中属于一个行内元素,在行内定义一个区域，也就是一行内可以被` <span>` 划分成好几个区域，从而实现某种特定效果。

` <span> `本身没有任何属性。

` <div> `在CSS定义中属于一个块级元素 `<div>` 可以包含段落、标题、表格甚至其它部分。这使DIV便于建立不同集成的类，如章节、摘要或备注。

在页面效果上，使用` <div> `会自动换行，使用 `<span>` 就会保持同行。

span是行内元素；div是块级元素；他们都是容器！

> <p><span>some text.</span>some other text.</p>
> p.tip span {
> font-weight:bold;
> color:#ff9955;
> }
> <p class="tip"><span>提示：</span>... ... ...</p>



使用 <span> 元素对文本中的一部分进行着色：

<p>我的母亲有 <span style="color:blue">蓝色</span> 的眼睛。</p>

## 三层架构

三层架构(3-tier architecture) 通常意义上的三层架构就是将整个业务应用划分为：

1. 界面层（User Interface layer）、
2. 业务逻辑层（Business Logic Layer）、
3. 数据访问层（Data access layer）。



1. 数据访问层：有时候也称为是**持久层**，其功能主要是**负责数据库的访问**，可以访问数据库系统、二进制文件、文本文档或是XML文档。主要看数据层里面有没有包含逻辑处理，实际上它的各个函数主要完成各个对数据文件的操作。而不必管其他操作。
2. 业务逻辑层：它的关注点主要集中在业务规则的制定、业务流程的实现等与业务需求有关的系统设计，也即是说它是与系统所应对的领域（Domain）逻辑有关，很多时候，也将业务逻辑层称为**领域层**。主要负责对数据层的操作。也就是说把一些数据层的操作进行组合。
3. 表示层：主要对用户的请求接受，以及数据的返回，为客户端提供应用程序的访问。

区分层次的目的即为了**高内聚低耦合**的思想。

在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。

微软推荐的分层式结构一般分为三层，从下至上分别为：**数据访问层、业务逻辑层（又或称为领域层）、表示层**。

![](.\imagenote\三层架构.jpg)

![](.\imagenote\三层架构2.jpg)

**持久层Persistence**

持久层只是一个逻辑概念而已，主要任务是负责把数据保存起来，一般是指保存至数据库或者文件，也可以负责完成与之相关的行为。

持久层指的是把数据长期保存起来，如数据库把数据长期保存在硬盘里，XML也可以长期保存数据，还有如果把数据存放到指定文件中，也可以成为持久层。

持久化可以理解为动词。Java中的**Hibernate**做的就是持久化的操作，主要是对数据库底层的OR映射，这样我们就不必关心讨厌的关系映射了，直接操作对象就可以了。

**DAL  Data Access Layer，数据访问层**

**DAL**是三层架构(表现层，业务逻辑层，数据访问层)中的数据访问层，是一个概念或者说是一个方案，它由许多**DAO**(**DAO data access object，数据访问对象**)组成，或者说由**DAO**具体实现，是把和数据库相关的代码封装起来，这样当我们执行分库时，便只用调整**DAO**的代码了，模型根本不用关心它使用的数据是放在A库还是B库。

设计数据访问层接口的目的是让业务逻辑层不去调用具体的数据访问层的实现（不依赖于数据访问层具体的实现技术），这样的好处是，业务逻辑不必管数据访问层具体是什么技术来实现的，接口是不变的。

业务逻辑不必管数据访问层具体是什么技术来实现的，接口是不变的，数据访问层可以用jdbc来实现，也可以用hibernate来实现，而且更换起来不是非常麻烦，这样耦合就降低了.

**DAO data access object，数据访问对象**

**DAO**是一个软件设计的指导原则，在核心[J2EE](http://baike.baidu.com/view/1507.htm)模式中是这样介绍**DAO**模式的：为了建立一个健壮的J2EE应用，应该将所有对数据源的访问操作抽象封装在一个公共API中。用程序设计的语言来说，就是建立一个接口，接口中定义了此[应用程序](http://baike.baidu.com/view/330120.htm)中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口在逻辑上对应这个特定的数据存储。

顾名思义就是与数据库打交道，夹在业务逻辑与数据库资源中间，是**DAL**的具体实现。

简单的说 **dao**层 就是对数据库中数据的增删改查等操作封装在专门的类里面，在业务逻辑层中如果要访问数据的时候，直接调用该**dao**类（包括了如何访问数据库和数据的增删改查等等代码），就可以返回数据，而不需要再在业务逻辑层中写这些代码。



## MVC架构

MVC（模型Model-视图View-控制器Controller）是一种架构模式，可以用它来创建在域对象和UI表示层对象之间的区分。

同样是架构级别的，相同的地方在于他们都有一个表现层，但是他们不同的地方在于其他的两个层。

在三层架构中没有定义Controller的概念。这是最不同的地方。而MVC也没有把业务的逻辑访问看成两个层，这是采用三层架构或MVC搭建程序最主要的区别。当然了。在三层中也提到了Model，但是三层架构中Model的概念与MVC中Model的概念是不一样的，“三层”中典型的Model层是以实体类构成的，而MVC里，则是由业务逻辑与访问数据组成的。

![](.\imagenote\MVC1.jpg)

![](.\imagenote\MVC2.jpg)

**模型 Model**

模型是MVC中的概念，指的是读取数据和改变数据的操作（业务逻辑）。一开始我们直接把和数据库相关的代码放在模型里(sql直接写在代码中)，这样就会导致以后的维护相当麻烦。业务逻辑的修改都需要开发者重新写sql，如果项目需要分库，需要将sql语句抽出来，放到单独的一层。这一层就是**DAL**(数据访问层Data Access Layer)。









## ORM框架



ORM也是一种对数据库访问的封装，然而ORM不像**DAO**(data access object，数据访问对象)只是一种软件设计的指导原则，强调的是系统应该层次分明，更像是一种工具，有着成熟的产品，比如JAVA界非常有名的**Hibernate**，以及很多PHP框架里自带的ORM库。他们的好处在于能将你程序中的数据对象自动地转化为关系型数据库中对应的表和列，数据对象间的引用也可以通过这个工具转化为表之间的JOIN。使用ORM的好处就是使得你的开发几乎不用接触到SQL语句。创建一张表，声明一个对应的类，然后你就只用和这个类的实例进行交互了，至于这个对象里的数据该怎么存储又该怎么获取，通通不用关心。

![](.\imagenote\ORM.jpg)

**Hibernate**是全自动ORM框架，而**Mybatis**是半自动的。

1. hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。
2. 而mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理..

hibernate数据库移植性远大于mybatis。 hibernate通过它强大的映射结构和hql语言，大大降低了对象与数据库（oracle、mysql等）的耦合性，而mybatis由于需要手写sql，因此与数据库的耦合性直接取决于[程序](http://www.xuebuyuan.com/)员写sql的方法，如果sql不具通用性而用了很多某数据库特性的sql语句的话，移植性也会随之降低很多，成本很高。

系统数据处理量巨大，性能要求极为苛刻，这往往意味着我们必须通过经过高度优化的sql语句（或存储过程）才能达到系统性能设计指标，在这种情况下Mybatis会有更好的可控性和表现，可以进行细粒度的优化。





## DUBBO

DUBBO是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，是阿里巴巴SOA服务化治理方案的核心框架，每天为2,000+个服务提供3,000,000,000+次访问量支持，并被广泛应用于阿里巴巴集团的各成员站点。

随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。

![](.\imagenote\dubbo-architecture-roadmap.jpg)

- 单一应用架构
  - 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。
  - 此时，用于简化增删改查工作量的 **数据访问框架(ORM)** 是关键。
- 垂直应用架构
  - 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。
  - 此时，用于加速前端页面开发的 **Web框架(MVC)** 是关键。
- 分布式服务架构
  - 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。
  - 此时，用于提高业务复用及整合的 **分布式服务框架(RPC)** 是关键。
- 流动计算架构
  - 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。
  - 此时，用于提高机器利用率的 **资源调度和治理中心(SOA)** 是关键。





# 20170516

### 基本语法

#### java三目运算符---条件运算符（?:）

条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。

**variable x = (expression) ? value if true : value if false**

> variable x = (expression) ? value if true : value if false
>
> 这里expression是判断语句（例如：null==sobject）
>
> public class Test {
>    public static void main(String args[]){
> ​      int a , b;
> ​      a = 10;
> ​      // 如果 a 等于 1 成立，则设置 b 为 20，否则为 30
> ​      b = (a == 1) ? 20 : 30;
> ​      System.out.println( "Value of b is : " +  b );
>
> ​      // 如果 a 等于 10 成立，则设置 b 为 20，否则为 30
> ​      b = (a == 10) ? 20 : 30;
> ​      System.out.println( "Value of b is : " + b );
>    }
> }



#### 编写Java程序时，应注意以下几点：

- **大小写敏感**：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。
- **类名**：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。
- **方法名**：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。
- **源文件名**：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。
- **主方法入口**：所有的Java 程序由**public static void main(String []args)**方法开始执行。

#### Java 对象和类

Java作为一种面向对象语言。支持以下基本概念：

- 多态
- 继承
- 封装
- 抽象
- 类
- 对象
- 实例
- 方法
- 重载

#### 构造方法

##### java的构造函数其实很简单。
一个类 被实例化 也就是被new的时候 最先执行的是 构造函数，如果你有留心。你会发现很多类里面根本没有写构造函数。
在java类中，如果不显示声明构造函数，JVM 会给该类一个默认的构造函数。
一个类 可以有多个构造函数。
构造函数的主要作用
	一是用来实例化该类。
	二是 让该类实例化的时候执行哪些方法，初始化哪些属性。
当一个类声明了构造函数以后，JVM 是不会再给该类分配默认的构造函数。
比如一个实体类
	public class entity{
	  	private int id;
	  	private String userName;
	  	get...set..方法
	}
如果这样写该类就是默认的构造函数。该类实例化的时候 id 和 username 就是默认值 即 id=0,username=null.
如果在里面加入这样一个方法
	public entity(int id,String userName){
	 	调用get..set..
	}
如果这样写 该类实例化的时候 必须给出 id  和username参数。 JVM不会再给这个类默认构造函数
你也可以理解成 在没有给构造函数的时候 JVM 给你的类加了一个这样的函数
    public entity(){
    	this.id=0;
    	this.userName=null;
    }
其实构造函数是用来对一个类以及变量进行实例化。
##### 一个简单的类，一共有四个构造方法
构造方法，在new对象的时候就会自己调用，也是对象的初始方法，如果你自己不写构造方法默认的会自动加上一个无参的构造。如果不存在构造方法那也就创建不了类的实例。
    public class Test {
    private String name;
    private String sex;
    private String age;
    public Test(){
    super();
    }
    public Test(String name){
    this.name=name;
    }
    public Test(String name,String sex){
    this.name=name;
    this.sex=sex;
    }
    public Test(String name,String sex,String age){
    this.name=name;
    this.sex=sex;
    this.age=age;
    }
    }
上面写了一个简单的类，一共有四个构造方法，这样你就有四种方法构造类实例（对象）
    new Test();
    new Test("张三");
    new Test("张三","男");
    new Test("张三","男","16");
有了构造，也就相应提供了初始方法

##### 每个类都有构造方法。
每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。
在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。
> `public class Puppy{`
> ​    public Puppy(){
> ​    }
>
> ​    public Puppy(String name){
> ​        // 这个构造器仅有一个参数：name
> ​    }
> `}`

#### java语法--java修饰符
##### 访问控制修饰符
Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java支持4种不同的访问权限。
1. 默认的，也称为 **default**，在同一包内可见，不使用任何修饰符。
2. 私有的，以 **private** 修饰符指定，在同一类内可见。
3. 共有的，以 **public** 修饰符指定，对所有类可见。
4. 受保护的，以 **protected** 修饰符指定，对同一包内的类和所有子类可见。

##### 非访问修饰符

为了实现一些其他的功能，Java 也提供了许多非访问修饰符。

1. static 修饰符，用来创建类方法和类变量。
   **静态变量：**
   static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。
   静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。
   **静态方法：**
   static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。
2. final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。final用于常量的声明，规范要求常量的变量名是大写的。
   **final 变量：**
   final 变量能被显式地初始化并且只能初始化一次。
   **final 方法：**
   类中的 final 方法可以被子类继承，但是不能被子类修改。
   **final 类：**
   final 类不能被继承，没有类能够继承 final 类的任何特性。
3. abstract 修饰符，用来创建抽象类和抽象方法。
4. synchronized 和 volatile 修饰符，主要用于线程的编程。
#### java语法--java变量类型
Java语言支持的变量类型有：
成员变量：类变量、实例变量
- 类变量：（也称为静态变量）独立于方法之外的变量，用 static 修饰。
- 实例变量：（也称为成员变量）独立于方法之外的变量，不过没有 static 修饰。
- 局部变量：类的方法中的变量。

> `package com.test;`
> `//LOL里面的英雄类`
> `public class Hero {`
> ​	`int age;//成员变量`
> ​	`String name;//成员变量`
> ​	`static int age1;//类变量（静态变量）`
> ​	`static String name2;//类变量（静态变量）`
> ​	`public void run(){`
> ​		`String name3;//局部变量`
> ​		`int age3;//局部变量`
> ​	`}`
> `}`



### Java面向对象

我们可以把JAVA中的类分为以下三种：
- 类：使用class定义且不含有抽象方法的类。
- 抽象类：使用abstract class定义的类，它可以含有，也可以不含有抽象方法。
- 接口：使用interface定义的类。
  继承规律
- 类可以继承（extends）类，可以继承（extends）抽象类，可以继承（implements）接口。
- 抽象类可以继承（extends）类，可以继承（extends）抽象类，可以继承（implements）接口。
- 接口只能继承（extends）接口。
  一个普通类继承一个接口后，必须实现这个接口中定义的所有方法，否则就只能被定义为抽象类。
  我在这里之所以没有对implements关键字使用“实现”这种说法是因为从概念上来说它也是表示一种继承关系，而且**对于抽象类implements接口**的情况下，它并不是一定要实现这个接口定义的任何方法，因此使用继承的说法更为合理一些。
- 类和抽象类都只能最多继承一个类，或者最多继承一个抽象类，并且这两种情况是互斥的，也就是说它们要么继承一个类，要么继承一个抽象类。
- 类、抽象类和接口在继承接口时，不受数量的约束，理论上可以继承无限多个接口。当然，对于类来说，它必须实现**它所继承的所有接口**中定义的全部方法。
- 抽象类继承抽象类，或者实现接口时，可以部分、全部或者完全不实现父类抽象类的抽象（abstract）方法，或者父类接口中定义的接口。
- 类继承抽象类，或者实现接口时，必须全部实现父类抽象类的全部抽象（abstract）方法，或者父类接口中定义的全部接口。
#### Java继承（inheritance）

简单的说，继承就是在一个现有类型的基础上，通过**增加新的方法或者重定义已有方法**（下面会讲到，这种方式叫重写）的方式，产生一个新的类型。
继承是面向对象的三个基本特征--**封装、继承、多态**的其中之一，我们在使用JAVA时编写的每一个类都是在继承，
因为在JAVA语言中，**java.lang.Object类**是所有类最根本的基类（或者叫父类、超类），如果我们新定义的一个类没有明确地指定继承自哪个基类，那么JAVA就会默认为它是继承自Object类的。

继承给我们的编程带来的好处就是**对原有类的复用（重用）**。**就像模块的复用一样**，**类的复用**可以提高我们的开发效率，实际上，**模块的复用是大量类的复用叠加后的效果。**除了继承之外，我们还可以使用组合的方式来复用类。所谓组合就是把原有类定义为新类的一个属性，通过在新类中调用原有类的方法来实现复用。如果新定义的类型与原有类型之间不存在被包含的关系，也就是说，从抽象概念上来讲，新定义类型所代表的事物并不是原有类型所代表事物的一种，比如黄种人是人类的一种，它们之间存在包含与被包含的关系，那么这时组合就是实现复用更好的选择。下面这个例子就是组合方式的一个简单示例：


#### Java 重写Override/重载Overload

重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。**即外壳不变，核心重写！**

重载和重写都是针对方法的概念，在弄清楚这两个概念之前，我们先来了解一下什么叫方法的型构（英文名是signature，有的译作“签名”，虽然它被使用的较为广泛，但是这个翻译不准确的）。型构就是指方法的组成结构，具体包括方法的名称和参数，涵盖参数的数量、类型以及出现的顺序，但是不包括方法的返回值类型，访问权限修饰符，以及abstract、static、final等修饰符。比如下面两个就是具有相同型构的方法：

Java代码
public void method(int i, String s) {   
​    // do something   
}   

public String method(int i, String s) {   
​    // do something   
}

而这两个就是具有不同型构的方法：
Java代码
public void method(int i, String s) {   
​    // do something   
}   

public void method(String s, int i) {   
​    // do something   
}

- 重写，英文名是overriding，是指在继承情况下，子类中定义了与其基类中方法具有**相同型构**的新方法，就叫做子类把基类的方法重写了。这是实现**多态**必须的步骤。
- 重载，英文名是overloading，是指在同一个类中定义了一个以上具有相同名称，但是**型构不同**的方法。在同一个类中，是不允许定义多于一个的具有相同型构的方法的。

我们来考虑一个有趣的问题：构造器可以被重载吗？答案当然是可以的，我们在实际的编程中也经常这么做。实际上构造器也是一个方法，构造器名就是方法名，构造器参数就是方法参数，而它的返回值就是新创建的类的实例。但是构造器却不可以被子类重写，因为子类无法定义与基类具有相同型构的构造器。

#### Java 多态（Polymorphism）



#### Java 抽象类（abstract class）

在Java语言中使用abstract class来定义抽象类。



#### Java 封装（Encapsulation）

实现Java封装的步骤:

1. 修改属性的可见性来限制对属性的访问（一般限制为private），例如：

   public class Person {
   ​    private String name;
   ​    private int age;
   }

   这段代码中，将 **name** 和 **age** 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。

2. 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如：

public class Person{
​    private String name;
​    private int age;
​    public int getAge(){
​      return age;
​    }
​    public String getName(){
​      return name;
​    }
​    public void setAge(int age){
​      this.age = age;
​    }
​    public void setName(String name){
​      this.name = name;
​    }
}
以上实例中public方法是外部类访问该类成员变量的入口。
通常情况下，这些方法被称为getter和setter方法。
因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。

    public class RunEncap{
    public static void main(String args[]){
        EncapTest encap = new EncapTest();
        encap.setName("James");
        encap.setAge(20);
        encap.setIdNum("12343ms"); 
        System.out.print("Name : " + encap.getName()+ 
                               " Age : "+ encap.getAge());
      }

#### Java接口（Interface）



#### Java 包（package）

ava 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。

### Java 高级教程



#### Java数据结构

Java工具包提供了强大的数据结构。在Java中的数据结构主要包括以下几种接口和类：

- 枚举（Enumeration）：枚举（Enumeration）接口虽然它本身不属于数据结构,但它在其他数据结构的范畴里应用很广。 枚举（The Enumeration）接口定义了一种从数据结构中取回连续元素的方式。

- 位集合（BitSet）：

- 向量（Vector）：向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。和数组一样，Vector对象的元素也能通过索引访问。使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。

- 栈（Stack）：栈（Stack）实现了一个后进先出（LIFO）的数据结构。

- 字典（Dictionary）：字典（Dictionary） 类是一个抽象类，它定义了键映射到值的数据结构。由于Dictionary类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现。

- 哈希表（Hashtable）：Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。

- 属性（Properties）：Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。

  Properties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。

以上这些类是传统遗留的，在Java2中引入了一种新的框架-集合框架(Collection)，我们后面再讨论。

哈希方法在“键- 值对”的存储位置与它的键之间建立一个确定的对应函数关系 hash() ，使得每一个键与结构中的一个唯一的存储位置相对应：存储位置=hash( 键 )

在搜索时，首先对键进行hash 运算，把求得的值当做“键 - 值对”的存储位置，在结构中按照此位置取“键 - 值对”，若键相等，则表示搜索成功。在存储“键 - 值对”的时候，依照相同的 **hash 函数**计算存储位置，并按此位置存放，这种方法就叫做**哈希方法，也叫做散列方法**。
**在哈希方法中使用的转换函数 hash 被称作哈希函数 ( 或者散列函数 ) 。按照此算法构造出来的表叫做哈希表 ( 或者散列表 ) 。**
哈希函数建立了从“键- 值对”到哈希表地址集合的一个映射，有了哈希函数，我们就可以根据键来确定“键 - 值对”在哈希表中的位置的地址。使用这种方法由于不必进行多次键的比较，所以其搜索速度非常快，很多系统都使用这种方法进行数据的组织和检索。

dictionary 跟 map 其实是同一个东西，只是在不同场合叫法不同。
dictionary 的中文是字典，map 在中文是映射，也有地图的意思。查字典，查地图，都是通过某个信息，去找到另一个信息。比如通过单词的拼写找到单词的具体含义。
类比查字典过程，单词的拼写为 key, 单词的具体含义为 value。dictionary 就是通过key，找到value，有时也将 dictionary 说成是 key-value 结构。只要达到查找目的，都可以叫做 dictionary。具体怎么找，可以有不同实现。
比如，最简单是将 key，value 放在一起，线性排。
>k1, k2, k3, k4, k4 ....
>v1, v2, v3, v4, v5 ....

当需要从 key 找到对应的 value 时，就从头到尾遍历过去。依次判断 k1, k2, k3, k4 是不是等于key, 当等于的时候，就找到 key 的具体位置，从而也就找到了value。
但这样从头到尾遍历，速度就太慢了，时间复杂度为 O(N)。N为数据的大小。
为了快速从key找到value。dictionary(或者说map)的通常有两种实现方式。
二叉树哈希(hash)表二叉树查找的时间复杂度为 O(logN)，哈希表的时间复杂度大致为 O(1)。
二叉树也分红黑树，AVL树等。
哈希表的速度很快，很多语言内置的 dictionary 都使用哈希表来实现，但它通常会浪费一些存储空间。
这部分有兴趣去看数据结构的书。
hash_map 其实就是使用 hash 表实现的 map。
注意，二叉树，哈希表仅仅是 dictionary 的实现方式，不能说 hash 就等于 dictionary，实现方式可以有多种多样。比如上面线性存储的实现，可以调整一下。当数据都放进来之后，先根据 key 来排序，再使用二分查找，就可以很快速地从 key 找到 value, 这种实现简单快速，并省内存，有时会比 hash 的实现更好。适合于一些数据不会经常变动的情况。
C++ 11 的标准库中有个 unordered_map，就是采用哈希表使用的 map。在C++ 11之前，没有标准的哈希实现，很多第三方库实现了哈希字典，基本都叫做 hash_map, 并应用广泛。所以C++ 11的实现就不能叫hash_map了，因为会造成很多现存的程序名字冲突。哈希实现的字典是无序，也就取了个不算太好的名字，unordered_map。

#### Java集合框架

Java提供了一套比较完整的容器类，基本类型是：List、Set、Queue、Map，这些对象类型称为集合类。


```
  package java.lang;
  import java.util.Iterator;
  public interface Iterable<T> {
      /**
       * Returns an iterator over a set of elements of type T.
       *
       * @return an Iterator.
       */
      Iterator<T> iterator();
  }
```

```
package java.util;
public interface Collection<E> extends Iterable<E> {
    // Query Operations
    int size();
    boolean isEmpty();
    boolean contains(Object o);
    Iterator<E> iterator();
    Object[] toArray();
    <T> T[] toArray(T[] a);
    boolean add(E e);
    boolean remove(Object o);
    boolean containsAll(Collection<?> c);
    boolean addAll(Collection<? extends E> c);
    boolean removeAll(Collection<?> c);
    boolean retainAll(Collection<?> c);
    void clear();
    boolean equals(Object o);
    int hashCode();
}
```
```
package java.util;
public interface List<E> extends Collection<E> {
int size();
boolean isEmpty();
boolean contains(Object o);
Iterator<E> iterator();
....
List<E> subList(int fromIndex, int toIndex);
}
```





#### Java泛型

Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。
泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。

> 假定我们有这样一个需求：写一个排序方法，能够对整形数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？
> 答案是可以使用 **Java 泛型**。
> 使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。

#####**泛型方法**
你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。
下面是定义泛型方法的规则：
所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的<E>）。
每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。
类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。
泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等）。
```
public class GenericMethodTest
{
   // 泛型方法 printArray                         
   public static < E > void printArray( E[] inputArray )
   {
      // 输出数组元素            
         for ( E element : inputArray ){        
            System.out.printf( "%s ", element );
         }
         System.out.println();
    }
     public static void main( String args[] )
    {
        // 创建不同类型数组： Integer, Double 和 Character
        Integer[] intArray = { 1, 2, 3, 4, 5 };
        Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 };
        Character[] charArray = { 'H', 'E', 'L', 'L', 'O' };
        System.out.println( "整型数组元素为:" );
        printArray( intArray  ); // 传递一个整型数组
        System.out.println( "\n双精度型数组元素为:" );
        printArray( doubleArray ); // 传递一个双精度型数组
        System.out.println( "\n字符型数组元素为:" );
        printArray( charArray ); // 传递一个字符型数组
    } 
}

```
有界的类型参数:
可能有时候，你会想限制那些被允许传递到一个类型参数的类型种类范围。例如，一个操作数字的方法可能只希望接受Number或者Number子类的实例。这就是有界类型参数的目的。
要声明一个有界的类型参数，首先列出类型参数的名称，后跟extends关键字，最后紧跟它的上界。
下面的例子演示了"extends"如何使用在一般意义上的意思"extends"（类）或者"implements"（接口）。该例子中的泛型方法返回三个可比较对象的最大值。
```
public class MaximumTest
{
   // 比较三个值并返回最大值
   public static <T extends Comparable<T>> T maximum(T x, T y, T z)
   {                     
      T max = x; // 假设x是初始最大值
      if ( y.compareTo( max ) > 0 ){
         max = y; //y 更大
      }
      if ( z.compareTo( max ) > 0 ){
         max = z; // 现在 z 更大           
      }
      return max; // 返回最大对象
   }
   public static void main( String args[] )
   {
      System.out.printf( "%d, %d 和 %d 中最大的数为 %d\n\n",3, 4, 5, maximum( 3, 4, 5 ) ); 
      System.out.printf( "%.1f, %.1f 和 %.1f 中最大的数为 %.1f\n\n",6.6, 8.8, 7.7, maximum( 6.6, 8.8, 7.7 ) ); 
      System.out.printf( "%s, %s 和 %s 中最大的数为 %s\n","pear","apple", "orange", maximum( "pear", "apple", "orange" ));
   }
}
```
#####**泛型类**
泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。
和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。
```
public class Box<T> {
  private T t
  public void add(T t) {
    this.t = t;
  }
   public T get() {
    return t;
  }
   public static void main(String[] args) {
    Box<Integer> integerBox = new Box<Integer>();
    Box<String> stringBox = new Box<String>();
    integerBox.add(new Integer(10));
    stringBox.add(new String("菜鸟教程"));
    System.out.printf("整型值为 :%d\n\n", integerBox.get());
    System.out.printf("字符串为 :%s\n", stringBox.get());
  }
}
```
**类型通配符**
1、类型通配符一般是使用?代替具体的类型参数。例如 List<?> 在逻辑上是List<String>,List<Integer> 等所有List<具体类型实参>的父类。




## Baf-mysql.properties

Baf-mysql.properties 放置配置文件 与 xml文件关联。  （ctrl+shift+R：Baf-mysql.properties ）

bam 是一个项目的数据库：172.16.1.72:3306
> `database.schema=bam`
> `database.username=bam`
> `database.password=YJkkYRrPRqYJ`

sia9是farms项目的数据库：172.16.1.114:3306

> `database.farmsro.username=root`
> `database.farmsro.password=Hubin123`
> `database.farmsro.schema=sia9`

主表 分表 到李晗那边问一下 哪些是主表分表。
bam里边的表 不在 frams的分库分表计划里，都不属于分表。



# 20170519



## 对照着前面的java语法，在修改bam改造代码时，看了bam开发空间里的代码

	java.lang.Object
​	
	public interface Serializable {}
​	 
	public interface BObject extends Serializable {
	public Long getOid();
	public void setOid(Long oid);
	public boolean isNewObject();
	public boolean isNewObject();
	public void setNewObject(boolean newObject);
	public Map<String, Object> getBmfProperties();
	public void setBmfProperties(Map<String, Object> bmfProperties);
	public Object getBmfProperty(String property);
	public void setBmfProperty(String property, Object object);
	public String getBmfTitle();
	public void setBmfTitle(String title);
	public BObject getBeforeImage();
	public void setBeforeImage(BObject beforeImage);
	public Object getProperty(String p);
	public void setProperty(String p, Object v);
	public Long getBafTenantId();
	public void setBafTenantId(Long bafTenantId);
	public abstract boolean isActive();
	public abstract void setActive(boolean active);
	public abstract Date getCreatedOn();
	public abstract void setCreatedOn(Date created);
	public abstract BmfUser getCreatedBy();
	public abstract void setCreatedBy(BmfUser createdBy);
	public abstract Date getUpdatedOn();
	public abstract void setUpdatedOn(Date updated);
	public abstract BmfUser getUpdatedBy();
	public abstract void setUpdatedBy(BmfUser updatedBy);	
	public Long getCreatedById();
	public void setCreatedById(Long createdById);
	public Long getUpdatedById();
	public void setUpdatedById(Long updatedById);
	public Date getDeletedOn();
	public void setDeletedOn(Date deletedOn);
	public BmfUser getDeletedBy();
	public void setDeletedBy(BmfUser deletedBy);
	public abstract BmfUser getOwnedBy();
	public abstract void setOwnedBy(BmfUser owner);
	public void sendStateEvent(String event);
	}


	public interface SObject extends BObject {
	public String getUid();
	public void initOid();
	public void initOid(Long newOid);
	public Long getAid();
	.......
	}


	public interface TObject {
	SObject getSObject();
	void setSObject(SObject sobj);

}

## 鲲总、春茂、小刚开会讨论汽车爬虫



春茂跟小刚说了hadoop

春茂让小刚设计一下表格

鲲总等让爬一下汽车品牌--车标--

图片先扒下来

春茂说了后面可能会买

春茂用的网易汽车做参考。



## bam改造

```
public interface TObject {
	SObject getSObject();	
	void setSObject(SObject sobj);
}
```





1，搜索bmfAggrManager（菜单栏-->Seaarch--file search)，找到这些需要改写的地方
2，类似`Long fcCompanyId = bmfAggrManager.findOne("PasCompany", ImmutableMap.of("Code", "NFS")).getOid();`
（  在findone()函数上，鼠标点在上面，出现SObject，表明此函数返回的是SObject函数   ）
3，
`OrmUtilities.modifyBegin();`
`OrmUtilities.modifyEnd();`
在这两行代码之间改

4，两种方式
优先：
次要：
@Autowired 表示实例化，有这个就不需要 `new ***()`等

> @Autowired
> private BmfOrmAggrManager bmfOrmAggrManager;
> ClientOrmService clientOrmService = AiafContext.getBean(ClientOrmService.class);//TableNameOrmService表名后面加OrmService，监测是否存在

```
		优先
        
            OrmUtilities.modifyBegin();
     //	    SecurityUser user = bmfAggrManager.findOne(SecurityUser.class, ImmutableMap.of("ClinetId", clientId, "Mobile", mobile));
     //	    SecurityUser user = bmfAggrManager.findOne(SecurityUser.class, ImmutableMap.of("Mobile", mobile));
            SecurityUserOrmService securityUserOrmService = AiafContext.getBean(SecurityUserOrmService.class);
            SecurityUser user = securityUserOrmService.findOneByMobile(mobile);
            SecurityUser user = securityUserOrmService.findOneByClientId_Mobile(clientId, mobile);//如果ImmutableMap.of后有两个键值对。
            OrmUtilities.modifyEnd();
            
            -------------------------
            @Autowired
		   private SecurityUserOrmService securityUserOrmService
            OrmUtilities.modifyBegin();bmf
     //	    SecurityUser user = bmfAggrManager.findOne(SecurityUser.class, ImmutableMap.of("Mobile", mobile));
            
            SecurityUser user = securityUserOrmService.findOneByMobile(mobile);
            OrmUtilities.modifyEnd();
```

```
次要
@Autowired
private BmfOrmAggrManager bmfOrmAggrManager;
OrmUtilities.modifyBegin();
SObject prevTransFact = bmfAggrManager.findOne("FCTransFact", ImmutableMap.of("ReferenceDate", refDate.minusDays(1).toDate()));

SObject prevTransFact = bmfOrmAggrManager.findOne("FCTransFact", ImmutableMap.of("ReferenceDate", refDate.minusDays(1).toDate()));//次要
OrmUtilities.modifyEnd();
```

@Autowired
OrmUtilities.modifyBegin();
SecurityUser user = bmfAggrManager.findOne(SecurityUser.class, ImmutableMap.of("Mobile", mobile));
private ClientOrmService clientOrmService; //优先
OrmUtilities.modifyBegin();
OrmUtilities.modifyEnd();



@Autowired

private BmfOrmAggrManager bmfOrmAggrManager;



bmfOrmAggrManager
5,对于find()方法：查看分表，如果是分表，在方法的第一个参数加clientId
对于save()方法：分表与主表均要添加第一个参数，分表是clientId的变量，主表是`0L`。

6，如果未在**TableOrmCategory**中的分表里，且没有**优先**级接口（ctrl+shift+T //查找TableNameOrmService：表名后面加OrmService，监测是否存在（法一：ctrl+shift+T ，法二：TableNameOrmService，鼠标放上看有没有，import）），去询问李晗是不是分表。

7，根据ImmutableMap.of（）中的键值对确定
次要的那个原语句 
放一个文件中，一起发给唐超凡

save的那种需要 立即给唐超凡

AccountEntry  accountEntry;
AccountOrmService accountO	rmService = AiafContext.getBean(AccountOrmService.class);
Account account = accountOrmService.findOneByParentId(accountEntry.getParentId());
accountEntryOrmService.save(account.getClientId(), accountEntry);
accountOrmService.save(account);

```
   
   bmfOrmAggrManager.save(clientId, sobject);.save(fcTransFact);
    AccountOrmService accountOrmService = AiafContext.getBean(AccountOrmService.class);
    accountOrmService.save(account);       }
    
```



## bam改造新进展





DocItemServiceImpl.java
	public DocumentItem findDocItem(String code, DocItemStatusEnum status) {
	//默认查找富聪平台或者companyId为空的模板
		OrmUtilities.modifyBegin();
		//		Long fcCompanyId = bmfAggrManager.findOne("PasCompany", ImmutableMap.of("Code", "NFS")).getOid();
	//		PasCompanyOrmService pasCompanyOrmService = AiafContext.getBean(PasCompanyOrmService.class);
		PasCompany pasCompanyEntity = pasCompanyOrmService.findOneByCode("NFS");
		Long fcCompanyId = null;
		if(pasCompanyEntity != null)
			fcCompanyId = pasCompanyEntity.getSObject().getOid();
		OrmUtilities.modifyEnd();
		/** select * from DocumentItem where Code = ? and (CompanyID is null or CompanyID = ?) and Status = ? 
		 *  原sql语句  现因无CompanyID字段改成 select * from DocumentItem where Code = ? and Status = ?   */
		OrmUtilities.modifyBegin();
		//		DocumentItem documentItems = bmfAggrManager.findOneBySql("select * from DocumentItem where Code = ? and Status = ?", DocumentItem.class, code, status.getValue());
		DocumentItem documentItems = documentItemOrmService.findOneByCode_Status(code, status.getValue());
		OrmUtilities.modifyEnd();
		
		return documentItems;
	}



​	JobNotRunListener.java



			OrmUtilities.modifyBegin();
			//find AlertMethod
	//		Long alertMethodOid = getTableReconOid("AlertMethod", ImmutableMap.of("AlertMethod", AlertMethodEnum.SMS.getValue()));
			SObject sObject=bmfOrmAggrManager.findOne("AlertMethod", ImmutableMap.of("AlertMethod", AlertMethodEnum.SMS.getValue()));
			Long alertMethodOid=null;
			alertMethodOid=(sObject == null)? null : sObject.getOid();
			OrmUtilities.modifyEnd();
			
	private Long getTableReconOid(String table, Map<String, String> paramsMap) {
		SObject sObject = bmfAggrManager.findOne(table, paramsMap);
		return null == sObject ? null : sObject.getOid();
	}
​		

# 20170522



## CRUD
CRUD是指在做计算处理时的增加(Create)、读取查询(Retrieve)、更新(Update)和删除(Delete)几个单词的首字母简写。
主要被用在描述软件系统中数据库或者持久层的基本操作功能。
In computing, CRUD is an acronym for create, retrieve, update, and delete. It is used to refer to the basic functions of a database or persistence layer in a software system.
C reate new records
R etrieve existing records
U pdate existing records
D elete existing records.





## 大O记法

C++的大O记法是算法的时间复杂度表达公式。简单的说大O记法可以告诉你**一个算法耗费的时间长度**同**算法所处理的数据量大小**的关系。大O记法只是一个概念性的或定性的记号，不能通过它来真正计算一个算法所耗费的精确时长。

O(1) 算法只花费一个单位时间长度的时间。同所处理的数据量大小没有关系（常量时间）。
​       “一个单位时间长度”没有定义为1秒，1天，还是1微妙，完全随意指定。大约同处理一个数据项的时长相同。
​       考虑一个数组，按照数组下标的到一个元素的引用
​       int arr[100];
​       int x = arr[88]; //这个算法就是O(1)的
​       O(1)是最爽的，哪怕有1亿条数据还是1条数据，算法所费时间是常量。
O(N) 算法只花费N个单位时间长度的时间。数据量大小同算法所花费时长成正比例
​       考虑一个list链表
​       list.remove( 88 ); //把第88个元素删除。这个算法就是O(N)的
​       O(N)是最不爽的，假设有1亿条数据，算法就要花费1亿个时间单位的时长。
O(logN) 算法只花费logN个单位时间长度的时间。
​         logN是取对数，可以简单的理解为取以2为底数，N的对数。例如log65536=16 (因为2^16=65536)
​         对数是把一个天文数字般的整数映射成一个小小的整数的数学工具。
​         考虑一个已排序的数组，用“折半法”查找，算法的时间特性就是O(logN)的。
​         O(log(一个亿))约等于19个单位时间的时长。
​     O(logN)也不一定是以2为底的，也可能是以3为底的，这都无所谓。
算法在应用于局部小数据量时，可能因为内存的申请，释放，初始化等原因，观察者发现不符合大O记法表示的特性。
但是在长期的运行，经过大数据量的考验后，那些干扰因素逐渐沦为次要因素，观察者可以发现算法的却符合某种自己固有的时间特性。

## 红黑树（Red Black Tree）
红黑树是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。
1972年由Rudolf Bayer发明，当时被称为平衡二叉树（symmetric binary B-trees).
红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。
它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。

 

# 20170523



## git--gitbash中运行git log之后怎样终止这个命令

ctrl+c不管用
ctrl++z不管用

需要输入q键

## Git diff、log、reset



### git远程仓库版本回退方法

如果提交了一个错误的版本，怎么回退版本？
如果提交了一个错误的版本到远程分支，怎么回退远程分支版本？
如果提交了一个错误的版本到公共远程分支，又该怎么回退版本？
#### 本地分支版本回退的方法
- `HEAD`指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令`git reset --hard commit_id`。
- 穿梭前，用`git log`可以查看提交历史，以便确定要回退到哪个版本。
- 要重返未来，用`git reflog`查看命令历史，以便确定要回到未来的哪个版本。
  如果你在本地做了错误提交，那么回退版本的方法很简单 
  先用下面命令找到要回退的版本的commit id：```git reflog ```
  接着回退版本:```git reset --hard Obfafd```
  `0bfafd`就是你要回退的版本的commit id的前面几位
#### 自己的远程分支版本回退的方法
如果你的错误提交已经推送到自己的远程分支了，那么就需要回滚远程分支了。 
首先要回退本地分支：
> git reflog
> git reset --hard Obfafd
> 紧接着强制推送到远程分支：
> git push -f
> **注意：本地分支回滚后，版本将落后远程分支，必须使用强制推送覆盖远程分支，否则无法推送到远程分支**
#### 公共远程分支版本回退的问题
> A1–A2–B1
> 方法一：像自己的远程分支回退一样操作，但是这需要队友自己手动更改自己的本地分支
> 方法二：
> 使用git reset回退公共远程分支的版本后，需要其他所有人手动用远程master分支覆盖本地master分支，显然，这不是优雅的回退方法，下面我们使用另个一个命令来回退版本：
> git revert HEAD                     //撤销最近一次提交
> git revert HEAD~1                   //撤销上上次的提交，注意：数字从0开始
> git revert 0ffaacc                  //撤销0ffaacc这次提交
> git revert 命令意思是撤销某次提交。它会产生一个新的提交，虽然代码回退了，但是版本依然是向前的，所以，当你用revert回退之后，所有人pull之后，他们的代码也自动的回退了。 

#### 错的太远了直接将代码全部删掉，用正确代码替代

简单粗暴的办法，直接从那个错误的提交的前一次拉取一份代码放到其他目录，然后将master代码全部删除，把那份新代码方进去，然后提交，果然简单粗暴啊，虽然这种方法不入流，但是，实践中发现很好使啊，所以，实践是检验真理的唯一标准。遇到问题还是要灵活应对。 

### git diff

diff里面a表示前面那个变量，b表示第二个变量

HEAD     commit版本
Index     staged版本

a、查看尚未暂存的文件更新了哪些部分，不加参数直接输入
​    git diff
此命令比较的是工作目录(Working tree)和暂存区域快照(index)之间的差异
也就是修改之后还没有暂存起来的变化内容。

b、查看已经暂存起来的文件(staged)和上次提交时的快照之间(HEAD)的差异
​    git diff --cached
​    git diff --staged
显示的是下一次commit时会提交到HEAD的内容(不带-a情况下)


c、显示工作版本(Working tree)和HEAD的差别
​    git diff HEAD


d、直接将两个分支上最新的提交做diff
​    git diff topic master 或 git diff topic..master

e、输出自topic和master分别开发以来，master分支上的changed。
​    git diff topic...master
Changes that occurred on the master branch since when the topic
 branch was started off it
f、查看简单的diff结果，可以加上--stat参数
​    git diff --stat

g、查看当前目录和另外一个分支的差别
​    git diff test
显示当前目录和另一个叫'test'分支的差别
​    git diff HEAD -- ./lib
显示当前目录下的lib目录和上次提交之间的差别（更准确的说是在当前分支下）

h、比较上次提交commit和上上次提交
​    git diff HEAD^ HEAD

i、比较两个历史版本之间的差异
​    git diff SHA1 SHA2



## carCrawler

163car:`48 *48`, `64*64`, `128*128`

autohome:`50*50`

xcar:`160*120`

audi: ` 82*70`



### 爬到图片的URL，如何下载到本地？

方法一：

> ```
> for i in imgurl:
> 	content=urllib2.urlopen(i).read()
> 	with open("F:\\DownLoad\123.png",'wb') as f:
> 		f.write(content)
> ```

方法二：

> ```
> for i in iimgurl:
> 	name=1
> 	//llib.urlretrieve(i,u'C:\python 爬虫\picture\123.png')
> 	urllib.urlretrieve(i,u'C:\python 爬虫\picture\%s.ng'%name)
> ```





# 20170524





## python 抓取网易汽车上的汽车LOGO





## python图像处理库PIL（Python Imaging Library）
PIL已经是Python平台事实上的图像处理库了。PIL功能非常强大，但API却非常简单易用。
The Python Imaging Library (PIL) adds image processing capabilities to your Python interpreter. 
This library supports many file formats, and provides powerful image processing and graphics capabilities.


Pillow由PIL而来，所以该导入该库使用import PIL
Pillow 是 PIL的对Python3支持的另外一个分支，当然他对Python2也兼容，由于PIL安装起来比较烦，而使用pip可以很轻松的安装Pillow，所以我选择Pillow使用，但是其核心还是PIL库的。


Pillow 是 PIL 的替代版本，PIL 软件包提供了基本的图像处理功能，如：改变图像大小，旋转图像，图像格式转换，色场空间转换，图像增强，直方图处理，插值和滤波等等。
Pillow 为了解决 PIL 的两个问题：
1. 不兼容 setuptools 
2. 报告的问题太多，而更新太慢 




pillow中所有的图片处理方法都是基于Image.transform（）函数的，rotate等函数是一些常规的封装罢了，学会使用它才是正统。

`Image.transform(size, method, data=None, resample=0, fill=1)`

改变一张图片，这个方法会根据给定的尺寸生成一张与原图同样mode的图片，并根据给定的变化，从原图生的一个副本。说白了呢就是生成一张变换后的新图片。

这样介绍，这个函数是不是感觉很简单，分分钟都能实现，我也是这样觉得的，其实。

在介绍参数之前，我们默认已经打开了该图片：

from PIL import Image
img = Image.open("img/lyc.jpg")

下面说下这个函数的参数：

- size：尺寸，接受一个二值元组，格式：(width, height)。这个参数可以用来做缩放处理，比如原图(300, 300)大小，你可以指定新图片大小为(50, 50)
- data：这个参数是必须的，否则会报：ValueError异常。这个参数用于指定methond指定的变换方式说需要的额外的数据，这个会在下面说method参数时顺带说了。
- method：变换的方式，该值是给定，你只能从以下几个值当中选一个：
- Image.EXTENT（cut out a rectangular subregion[ 切出一个矩形区域 ]）：
- 该参数的data接受一个四值list，格式如：( x1, y1, x2, y2)，表示矩阵的起始点(x1, y1)，(x2, y2)。这个点坐标不要求一定要在图形大小表示的范围内，超过也可以，不过超过的部分默认使用黑色填充。

> `#`矩形剪切
>
> img.transform((100,100),Image.EXTENT ,[100,100,400,400]).show()



## bam改造测试

采用了这个版本 `<aiaf.version>6.5.64-SNAPSHOT</aiaf.version>`

http://127.0.0.1:8080/bam/
后加
/Baf/BafSqlCommand
Baf/BafConsole
bam项目默认bam库



`http://127.0.0.1:8080/bam/Baf/BafConsole`

```
import com.mdiaf.batch.domain.ClientInfo;
import com.mdiaf.batch.internal.ClientMapItemProcessor;  
ClientInfo client  = new ClientInfo();
client.setMobile("1221212");
client.setOid("27137");

// return client;

ClientMapItemProcessor cl = new ClientMapItemProcessor();
cl.process(client);
```

有些是通过 @auto 注入的 

也需要 通过类似 ClientInfo client  = new ClientInfo(); new进来



```
import com.mdiaf.batch.domain.ClientInfo;
import com.mdiaf.batch.internal.ClientMapItemProcessor;

ClientInfo client = new ClientInfo();
ClientMapItemProcessor cl = new ClientMapItemProcessor();

cl.process(client);
```



# 20170525





## spring eclipse

使用 Eclipse，Eclipse 是基于Java的可扩展平台，所以安装Eclipse前需要确保你的电脑已安装JDK。

第一次打开ZEclipse需要设置工作环境，可以指定工作目录或者使用默认的C盘工作环境。

创建一个项目：选择File--New--java Project

在项目基础上，new--class

![](.\imagenote\spring-eclipse.png)

![](.\imagenote\spring-eclipse-1.png)

maven项目右上角有个J是什么意思

大写的J表示的是项目为普通的java工程，S表示此项目使用了Spring框架

工程--项目--文件夹、文件









### Eclipse 修改字符集

默认情况下 Eclipse 字符集为 GBK，但现在很多项目采用的是 UTF-8，这是我们就需要设置我们的 Eclipse 开发环境字符集为 UTF-8， 设置步骤如下：

在菜单栏选择** Window -> Preferences -> General -> Workspace -> Text file encoding**，在 Text file encoding 中点击 Other，选择 UTF-8。











## 编码encoding

**ASCII**

在计算机内部，所有的信息最终都表示为一个**二进制的字符串**。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出**256种状态**，这被称为一个**字节**（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到11111111。
上个世纪60年代，美国制定了**一套字符编码**，对**英语字符与二进制位之间的关系**，做了统一规定。这被称为**ASCII码**，一直沿用至今。
ASCII码一共规定了**128个字符的编码**，比如**空格"SPACE"是32（二进制00100000）**，大写的**字母A是65（二进制01000001）**。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。

**Unicode**

世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。
可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。
Unicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字"严"。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。

**Unicode的问题**

Unicode只是一个符号集，它只规定了符号的**二进制代码**，却没有规定**这个二进制代码应该如何存储**。
比如，汉字"严"的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。
这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。
它们造成的结果是：
1）出现了Unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示Unicode。
2）Unicode在很长一段时间内无法推广，直到互联网的出现。

**UTF-8**

互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种Unicode的实现方式。其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。
UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。
UTF-8的编码规则很简单，只有二条：
1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。
2）对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。
下表总结了编码规则，字母x表示可用编码的位。

Unicode符号范围 | UTF-8编码方式
(十六进制) | （二进制）
--------------------+---------------------------------------------
0000 0000-0000 007F | 0xxxxxxx
0000 0080-0000 07FF | 110xxxxx 10xxxxxx
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

已知"严"的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此"严"的UTF-8编码需要三个字节，即格式是"1110xxxx 10xxxxxx 10xxxxxx"。然后，从"严"的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，"严"的UTF-8编码是"11100100 10111000 10100101"，转换成十六进制就是E4B8A5。



## python与编码

python在安装时，默认的编码是ascii，当程序中出现非ascii编码时，python的处理常常会报这样的错UnicodeDecodeError: 'ascii' codec can't decode byte 0x?? in position 1: ordinal not in range(128)，python没办法处理非ascii编码的，此时需要自己设置将python的默认编码，一般设置为utf8的编码格式。

查询系统默认编码可以在解释器中输入以下命令：sys.getdefaultencoding()

设置默认编码时使用：sys.setdefaultencoding('utf8')

可能会报AttributeError: 'module' object has no attribute 'setdefaultencoding'的错误，执行reload(sys)，在执行以上命令就可以顺利通过。

此时在执行sys.getdefaultencoding()就会发现编码已经被设置为utf8的了，但是在解释器里修改的编码只能保证当次有效，在重启解释器后，会发现，编码又被重置为默认的ascii了，那么有没有办法一次性修改程序或系统的默认编码呢。

有2种方法设置python的默认编码：

一个解决的方案在程序中加入以下代码：

> import sys   
> reload(sys)   
> sys.setdefaultencoding('utf8')   

另一个方案是在python的Lib\site-packages文件夹下新建一个**sitecustomize.py**，内容为：

> **\# encoding=utf8**   
> **import sys**   
> **reload(sys)**   
> **sys.setdefaultencoding('utf8')**   

此时重启python解释器，执行sys.getdefaultencoding()，发现编码已经被设置为utf8的了，多次重启之后，效果相同，这是因为系统在python启动的时候，自行调用该文件，设置系统的默认编码，而不需要每次都手动的加上解决代码，属于一劳永逸的解决方法。

另外有一种解决方案是在程序中所有涉及到编码的地方，强制编码为utf8，即**添加代码encode("utf8")**，这种方法并不推荐使用，因为一旦少写一个地方，将会导致大量的错误报告，我曾经遇到这种情况，错误日志压缩之后尚有70多K，全都是这一个问题，让人有很崩溃的感觉。





decode('utf-8')的作用是将utf8编码的字符串解码为unicode，而unicode是python最接受的字符串编码格式，不会因为各个工具库对字符编码处理不好而带来问题。

coding:utf-8的作用是指定当前这个python代码文件里面所有字符串的编码

python 3版本已经将默认编码格式ASCII改了

1. 保存文件时是否必要encode为utf-8

   这个两种都可以，纯粹看你的希望以哪种编码存储文件，以及那种编码后续处理更方便。 只不过write unicode字符串时，最好使用codes.open来打开文件并设置编码。

2. 源代码编码定义（# -*-coding:utf-8 -*-）的作用

   告诉python编译器如何解码代码文件，但并不能保证文件的实际编码一定与之匹配。
   实际文件的编码还是由编辑器决定的（有些编辑器可能会识别# -*-coding:utf-8 -*-，并进行相应的编码存储）。

   举个例子，我的vim的fileencoding设置为utf-8，但py文件编码设置为ascii（-*- coding:ascii -*-）。
   这时我的py文件的实际编码为utf-8，但python编译器会按ascii来解析源文件，如果遇到非ascii字符就会抛异常:
   SyntaxError: 'ascii' codec can't decode byte 0xe4 in position 5: ordinal not in range(128)

`encode`和`decode`提供 str 和 unicode 这两种的类型的互相转化。

- encode 把 unicode 转化成 str(byte string)
- decode 把 str(byte string) 转化成 unicode

Python获取系统默认字符编码的方法,涉及Python中sys模块getdefaultencoding方法的使用技巧

在Python代码中，普通字符串的编码方式与程序源文件编码方式一致的，而很多IDE在默认情况下，将程序源文件按照系统默认字符编码来保存的。

下面给出用Python获取系统默认编码的例子：

> ```
> #!/usr/bin/env python
> #coding=utf-8
> """
>   获取系统默认编码
> """
> import sys
> print sys.getdefaultencoding()
> ```





在 python 源代码文件中，**如果你有用到非ASCII字符，则需要在文件头部进行字符编码的声明**，声明如下：`# code :  UTF-8`

因为python 只检查 #、coding 和编码字符串，所以你可能回见到下面的声明方式，这是有些人为了美观等原因才这样写的：`# -*- coding:UTF-8-*-`

**常见编码介绍：**

> - ******GB2312编码：适用于汉字处理、汉字通信等系统之间的信息交换**
> - **GBK编码：是汉字编码标准之一，是在 GB2312-80 标准基础上的内码扩展规范，使用了双字节编码**
> - **ASCII编码：是对英语字符和二进制之间的关系做的统一规定**
> - **Unicode编码：这是一种世界上所有字符的编码。当然了它没有规定的存储方式。**
> - **UTF-8编码：是 Unicode Transformation Format - 8 bit 的缩写， UTF-8 是 Unicode 的一种实现方式。它是可变长的编码方式，可以使用 1~4 个字节表示一个字符，可根据不同的符号而变化字节长度。**



**编码转换：**

Python内部的字符串一般都是 Unicode编码。**代码中字符串的默认编码与代码文件本身的编码是一致的。**所以要做一些编码转换通常是要以Unicode作为中间编码进行转换的，即先将其他编码的字符串解码（decode）成 Unicode，再从 Unicode编码（encode）成另一种编码。

> - **decode **的作用是将其他编码的字符串转换成 Unicode 编码，eg name.decode(“GB2312”)，表示将GB2312编码的字符串name转换成Unicode编码
> - **encode **的作用是将Unicode编码转换成其他编码的字符串，eg name.encode(”GB2312“)，表示将GB2312编码的字符串name转换成GB2312编码

所以在进行编码转换的时候必须先知道 name 是那种编码，然后 decode 成 Unicode 编码，最后载 encode 成需要编码的编码。当然了，如果 name 已经就是 Unicode 编码了，那么就不需要进行 decode 进行解码转换了，直接用 encode 就可以编码成你所需要的编码。**值得注意的是：对 Unicode 进行编码和对 str 进行编码都是错误的。**

具体的说就是：如果在UTF-8文件中，则这个字符串就是 UTF-8编码的。它的编码取决于当前的文本编码。当然了，GB2312文本的编码就是GB2312。**要在同一个文本中进行两种编码的输出等操作就必须进行编码的转换**，先用decode将文本原来的编码转换成Unicode，再用encode将编码转换成需要转换成的编码。

eg：
由于内置函数 open() 打开文件时，read() 读取的是 str，读取后需要使用正确的编码格式进行 decode()。write() 写入时，如果参数是 Unicode，则需要使用你希望写入的编码进行 encode()，如果是其他编码格式的 str，则需要先用该 str 的编码进行 decode()，转成 Unicode 后再使用写入的编码进行 encode()。如果直接将 Unicode 作为参数传入 write() ，python 将先使用源代码文件声明的字符编码进行编码然后写入。

```
# coding: UTF-8
 
fp1 = open('test.txt', 'r')
info1 = fp1.read()
# 已知是 GBK 编码，解码成 Unicode
tmp = info1.decode('GBK')
 
fp2 = open('test.txt', 'w')
# 编码成 UTF-8 编码的 str
info2 = tmp.encode('UTF-8')
fp2.write(info2)
fp2.close()
```

**获取编码的方式：**判断是 s 字符串否为Unicode，如果是返回True，不是返回False ：`isinstance(s, unicode)`

下面代码可以获取系统默认编码：

```
#!/usr/bin/env python
#coding=utf-8
import sys
print sys.getdefaultencoding()
```

> 命令行控制台



![控制台编](.\imagenote\控制台编码.png)

## 

## python encode decode在 **codec**模块中

在Python中，可以对String调用decode和encode方法来实现转码。

比如，若要将某个String对象s从gbk内码转换为UTF-8，可以如下操作 
s.decode('gbk').encode('utf-8′) 
可是，在实际开发中，我发现，这种办法经常会出现异常： 
UnicodeDecodeError: ‘gbk' codec can't decode bytes in position 30664-30665: illegal multibyte sequence 
这 是因为遇到了非法字符——尤其是在某些用C/C++编写的程序中，全角空格往往有多种不同的实现方式，比如\xa3\xa0，或者\xa4\x57，这些 字符，看起来都是全角空格，但它们并不是“合法”的全角空格（真正的全角空格是\xa1\xa1），因此在转码的过程中出现了异常。 
这样的问题很让人头疼，因为只要字符串中出现了一个非法字符，整个字符串——有时候，就是整篇文章——就都无法转码。 

解决办法： 
s.decode('gbk', ‘ignore').encode('utf-8′) 
因为decode的函数原型是decode([encoding], [errors='strict'])，可以用第二个参数控制错误处理的策略，默认的参数就是strict，代表遇到非法字符时抛出异常； 
如果设置为ignore，则会忽略非法字符； 
如果设置为replace，则会用?取代非法字符； 
如果设置为xmlcharrefreplace，则使用XML的字符引用。 









































除了写网站代码的（因为可以自己再代码中指定编码格式），其他程序员在写代码之前都应该首先把项目的编码格式选择好，看到CSDN论坛上有些网友说“写代码不用utf-8编码的程序员不是好程序员”，一般来说大家都会选择utf-8这个编码方式（不要问我为什么），但是常常中国程序员使用的很多集成编辑环境大部分默认的编码方式是GBK或者GB2312，所以新建工程就需要注意了。



解决的办法就是在数据转换的两边需要转码，如果用的是XML传输数据，那么在服务器端打包推送数据之前需要转换为utf-8，经过网络传输到达客户端之后在读XML数据之前，又转换为utf-8。







# 20170601



## bam改造

先通过SourceTree：获取--拉取

有冲突 找到冲突文件 发现 是武刚的，武刚让丢弃

重新拉取，没有冲突，build之后 发现有错误 主要是pom错误，通过 maven--update之后可以build没有错误，再通过 tomcat server运行 可以登录 `http://127.0.0.1:8080/bam/Baf/BafConsole`



http://127.0.0.1:8080/bam/Baf/BafConsole

script language/Console：

Lanuage：Groovy与sigar（system info query）

一个开源工具包 SIGAR - System Information Gatherer And Reporter，即 系统信息收集和报告。





















## python 工厂函数

《head first python》
> 工厂函数：用于创建某种类型的新的数据项。例如，“set()” 就是一个工厂函数。因为它会创建一个新的集合。
> 在真实世界中，工厂会生产产品，这个概念因此而得名。







## Eclipse中ctrl+shift+r与ctrl+shift+t的区别

eclipse中的两个常用的快捷键可以大大提升查找文件的效率,分别是:

1. **ctrl+shift+r** : open resource, 打开资源. 
   它可以打开当前eclipse的工作区中所有(打开的)工程中所有类型的文件,但只限手动编写的文件,不含工程中引用到的jar包中的类、接口；
2. **ctrl+shift+t** : open type, 打开类型. 
   它可以打开当前eclipse的工作区中所有(打开的)工程中所有**java文件**,包括jar包中的类和接口.






## 共享盘、数据库主机密码

共享盘`\\172.16.1.119`

Baf-mysql.properties 放置配置文件 与 xml文件关联。  （ctrl+shift+R：Baf-mysql.properties ）





# 20170602

## Python Pandas ValueError Arrays Must be All Same Length

you can do this to avoid that error

```
a = {'Links' : lines ,'Titles' : titles , 'Singers': finalsingers , 'Albums':finalalbums , 'Years' : years}
df = pd.DataFrame.from_dict(a, orient='index')
df.transpose()
```



## 网易汽车Logo与品牌、车系爬取



问题：遇到 存到csv文件乱码问题，后来发现问题出在pycharm平台用的default encoding for  properties files 是 gbk，而变成用的是 utf-8. 



## bam改造 遗漏项



```
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:8:import org.springframework.jdbc.core.JdbcTemplate;
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:17:       private JdbcTemplate jdbcTemplateFarmsRO;
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:20:       private JdbcTemplate jdbcTemplateBssRO;
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:31:                       dataList = jdbcTemplateBssRO.queryForList(sql, queryParameter);
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:50:                       dataList = jdbcTemplateBssRO.queryForList(querySql, queryParameter);
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:67:                       dataList = jdbcTemplateFarmsRO.queryForList(sql, queryParameter);
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:86:                       dataList = jdbcTemplateFarmsRO.queryForList(querySql, queryParameter);
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:101:                      dataList = jdbcTemplateBssRO.queryForList(querySql, queryParameter);
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:117:                      dataList = jdbcTemplateBssRO.queryForList(querySql, queryParameter);
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:132:                      dataList = jdbcTemplateFarmsRO.queryForList(querySql, queryParameter);
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:148:                      dataList = jdbcTemplateFarmsRO.queryForList(querySql, queryParameter);
./bam-core/src/main/java/com/mdiaf/report/clientstatistics/FactHelperManagerImpl.java:166:                      dataList = jdbcTemplateFarmsRO.queryForList(querySql, queryParameter);


./bam-core/src/main/java/com/mdiaf/report/yqstatistics/ReportHelperManagerImpl.java:11:import org.springframework.jdbc.core.JdbcTemplate;
./bam-core/src/main/java/com/mdiaf/report/yqstatistics/ReportHelperManagerImpl.java:29: private JdbcTemplate jdbcTemplateFarmsRO;
./bam-core/src/main/java/com/mdiaf/report/yqstatistics/ReportHelperManagerImpl.java:41:                 dataList = jdbcTemplateFarmsRO.queryForList(sql, queryParameter);
./bam-core/src/main/java/com/mdiaf/report/yqstatistics/ReportHelperManagerImpl.java:59:                 dataList = jdbcTemplateFarmsRO.queryForList(querySql, queryParameter);
./bam-core/src/main/java/com/mdiaf/report/yqstatistics/ReportHelperManagerImpl.java:76:                 dataList = jdbcTemplateFarmsRO.queryForList(querySql, queryParameter);
./bam-core/src/main/java/com/mdiaf/report/yqstatistics/ReportHelperManagerImpl.java:246:                        dataList = jdbcTemplateFarmsRO.queryForList(sql, queryParameter);
```



# 20170605



sourceTree：zxcv

launch server:启动服务器

JDBC API是一个Java   API

## 打字空格 会把后边的字 覆盖掉 原因是按了insert键

原因：在打字时，不小心按到了Insert键。
Insert键：插入
功能：单击后，Windows系统默认是插入，意思是不影响后面的字符。Insert键的意思是插入覆盖，当按下Insert键后再输入，会覆盖掉光标以后的内容，再按下Insert键后还原为插入。
解决方法：按一下键盘上的Insert键就可以了，就是Delete上边那个键。

这是因为在WORD中编辑文本时开启了“改写”模式。
在WORD中编辑文本时有两种模式，一种为“插入”模式，一种为“改写”模式，当“改写“模式开启时，就会出现这种情况。
如果想避免这种情况，可以将当前编辑模式切换至”插入“模式，在”改写“与”插入“模式之间切换，最简单快捷的方法是按键盘上的“Insert”键进行切换。



## excel正则表达式

在 Excel 中，使用 Alt+F11 快捷键打开 VBA 项目窗口，在左侧的工作表名称上点右键，选择查看代码，即可出出现右侧的代码编辑窗口

在代码窗口中输入以下代码：  根据实际需要替换相应参数，点击 运行即可得到效果。

```
Private Sub RegExp_Replace()
    Dim RegExp As Object
    Dim SearchRange As Range, Cell As Range
    '此处定义正则表达式
    Set RegExp = CreateObject("vbscript.regexp")
    RegExp.Pattern = "[0-9]{5}"
    '此处指定查找范围
    Set SearchRange = ActiveSheet.Range("A1:A99")
    '遍历查找范围内的单元格
    For Each Cell In SearchRange
        Set Matches = RegExp.Execute(Cell.Value)
        If Matches.Count >= 1 Then
            Set Match = Matches(0)
            Cell.Value = RegExp.Replace(Cell.Value, "")
        End If
    Next
End Sub
```

合并两个表格，内容也合并： 只需使用 `&` 连接两个表格即可。

excel 同时显示多个窗口： 文件--->选项-->高级-->显示：勾选“在任务栏中显示所有窗口"  这个是管用的（但是不知道是否与我之前修改注册表有关”）

同时发现csv文件是不可以多窗口显示的。

## JDBC、JDBCTemplate

JDBC API是一个Java API可以访问任何类型的数据库的数据，尤其是存储在关系数据库中的数据。

JDBC（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。

有了JDBC，向各种关系数据发送SQL语句就是一件很容易的事。换言之，有了JDBC API，就不必为访问Sybase数据库专门写一个程序，为访问Oracle数据库又专门写一个程序，或为访问Informix数据库又编写另一个程序等等，程序员只需用JDBC API写一个程序就够了，它可向相应数据库发送SQL调用。同时，将Java语言和JDBC结合起来使程序员不必为不同的平台编写不同的应用程序，只须写一遍程序就可以让它在任何平台上运行，这也是Java语言“编写一次，处处运行”的优势。

简单地说，JDBC 可做三件事：与数据库建立连接、发送 操作数据库的语句并处理结果。下列代码段给出了以上三步的基本示例：

```
Connection con = DriverManager.getConnection("jdbc:odbc:wombat","login","password");
Statement stmt = con.createStatement();
ResultSet rs = stmt.executeQuery("SELECT a, b, c FROM Table1");
while (rs.next()) {
	int x = rs.getInt("a");
	String s = rs.getString("b");
	float f = rs.getFloat("c");
}
```



建立一个JDBC应用程序，本教程中以Java连接MySQL为一个示例，分六个步骤进行：



# 20170606



## JAVA文档

JAVA_API_1.7中文.chm
Spring Framework 开发者手册.chm
spring300_CN.chm
spring_framework-4-reference.epub



## eclipse快捷键

一个Eclipse骨灰级开发者总结了他认为最有用但又不太为人所知的快捷键组合。通过这些组合可以更加容易的浏览源代码，使得整体的开发效率和质量得到提升。

**1. ctrl+shift+r：打开资源**

这可能是所有快捷键组合中最省时间的了。这组快捷键可以让你打开你的工作区中任何一个文件，而你只需要按下文件名或mask名中的前几个字母，比如applic*.xml。美中不足的是这组快捷键并非在所有视图下都能用。

**2. ctrl+o：快速outline**

​    如果想要查看当前类的方法或某个特定方法，但又不想把代码拉上拉下，也不想使用查找功能的话，就用ctrl+o吧。它可以列出当前类中的所有方法及属性，你只需输入你想要查询的方法名，点击enter就能够直接跳转至你想去的位置。

**3. ctrl+e：快速转换编辑器**

​    这组快捷键将帮助你在打开的编辑器之间浏览。使用ctrl+page down或ctrl+page up可以浏览前后的选项卡，但是在很多文件打开的状态下，ctrl+e会更加有效率。

## sql语句中as的用法

在我的数据库中有user这个表，正常来说，想查询该表，那么sql语句如下`select * from user`

作为一个开发人员来说，自然是能看得懂的，但是假如，数据库不是你自己设计的，或者说给别人看，自然是需要很多的时间来理解和熟悉，那么as的作用就提现出来了。

```
select
     username as 账号 ,
     password as 密码,
     mingzi as 名字,
    zhengjianhao as 证件号,
    dianhua as 电话,
    zhuceriqi as 注册日期,
    zhuangtai as 状态,
    quanxian as 权限,
    shengyutianshu as 剩余天数
     from user
```

as是别名关键词，一般我们这么使用：

select 字段 as 别名

select 字段 别名

select 别名=字段

在sqlserver 中这三中显示结果一模一样，但是不推荐后两种写法，只推荐第一种写法。



## spring系统 工程问题

ctrl+左键 - 功能突然消失，解决方案：很可能你打开的文件不对，例如bam\bam-api, bam\bam-application, bam\bam-core, bam\bam-domain等而不是直接bam-api, bam-application。



## bam改造

分库 分表的sharding-key问题，是在文件中查找的，并不是在TableOrmCategory.class中， TableOrmCategory.class中没有shadingkey的分表指的是 在这个表格中没有shardingkey字段，但是可以从其他字段找其他表中推出shardingkey

shardingkey是一个确定表放在哪一个分库中国的键。



## java的循环语句

for(初始化; 布尔表达式; 更新) {
​    //代码语句
}

Java5 引入了一种主要用于数组的增强型 for 循环。
Java 增强 for 循环语法格式如下:

for(声明语句 : 表达式)
{
   //代码句子
}



## java V类型

```
Map.class
package java.util;
public interface Map<K,V> {
int size();
boolean isEmpty();
boolean containsKey(Object key);
boolean containsValue(Object value);
V get(Object key);
V put(K key, V value);	//这里的返回类型指的是V Value这个V类型
V put(K key, V value);	//这里的返回类型指的是V Value这个V类型
V remove(Object key);	//这里的返回类型指的是V Value这个V类型
void putAll(Map<? extends K, ? extends V> m);
void clear();
Set<K> keySet();
Collection<V> values();
Set<Map.Entry<K, V>> entrySet();
interface Entry<K,V> {
	K getKey();
	V getValue();
	V setValue(V value);
	boolean equals(Object o);
	int hashCode();
	}
boolean equals(Object o);
int hashCode();
}

```

在一般情况下返回类型要么是**范型**，要么就是**引用类型**、**基础类型**之类的数据。但是这些类型都是确切的返回类型，如果我想返回我传入的任意类型值，这个时候这些都做不到。

那怎么办呢，java已经考虑到这一点了，就是通过 <V> V 实现的。下面来看具体的案例介绍：



# 20170607



## bam改造

@Autowired 表示实例化，有这个就不需要 new ***()等
 @Autowired
private SecurityUserOrmService securityUserOrmService

SecurityUserOrmService securityUserOrmService = AiafContext.getBean(SecurityUserOrmService.class);

```

String FNDSql = "SELECT sum(n.price * m.currentShare) AS FNDBalance FROM 
( SELECT fa.assetNumber AS providerProductCode, ap.price, max(ap.startDate) AS startDate "
			+ "FROM financialasset fa INNER JOIN assetprice ap ON ap.parentId = fa.oid AND ap.priceType = 'fundNavVal' GROUP BY fa.oid ) n "
			+ "JOIN 
( SELECT sum(a.currentShare) currentShare, p.ProviderProductCode 
			FROM account a JOIN client c ON a.ClientId = c.oid "
			+ "JOIN agreement ag ON a.AgreementId = ag.oid JOIN productoffering p ON a.ProductOfferingId = p.oid "
			+ "WHERE ag.ProductCategoryCode NOT IN ('GAS') AND ag. STATUS IN ( 'Payed', 'Active', 'Active_Pending', 'Cancelled_Pending', 'PartCancelled_Pending' ) AND p.FinancialAssetType = 'Fund' "
			+ "AND p.ProviderProductCode <> '000719' GROUP BY p.ProviderProductCode ) m ON n.providerProductCode = m.providerProductCode;";
```

```
String sql_faap = "SELECT fa.assetNumber AS providerProductCode, ap.price, max(ap.startDate) AS startDate "
				+ "FROM financialasset fa INNER JOIN assetprice ap ON ap.parentId = fa.oid AND ap.priceType = 'fundNavVal' GROUP BY fa.oid";
List<Map<String, Object>> faapMapList = bmfOrmAggrManager.queryForList(sql_faap);

String sql_po = "SELECT * from ProductOffering p where p.FinancialAssetType = 'Fund' AND p.ProviderProductCode <> '000719' GROUP BY p.ProviderProductCode";
List<ProductOffering> productOfferingList = bmfOrmAggrManager.findAllTObjectBySql(sql_po, ProductOffering.class);
```

SQL语句里的问号？代表 参数的意思，也就是需要从外部传入参数。

```
String sql = "select c.oid as clientId, c.firstname as clientName, pr.ordernumber as orderNumber, " //
				+ " DATE_FORMAT(pr.starttime,'%Y%m%d') transactionDate, DATE_FORMAT(pr.starttime,'%H%i%s') transactionTime, " //
				+ " ce.AccountNumber as accountNumber, pr.orderamount as transAmount from paymentrequest pr " //
				+ " left join client c on pr.clientid=c.oid left join clientexternalaccount ce on ce.clientid=c.oid and ce.MerId=? " // 这里的  ？代表参数
				+ " left join agreementrequest ar on pr.agreementrequestid=ar.oid left join productoffering po on ar.targetproductofferingid=po.oid " //ProductOffering zhubiao
				+ " left join productprovider pp on po.ProductProviderId=pp.oid " // productprovider zhubiao
				+ " where pr.businesstype IN ('26','22') and pr.paymentstatus IN ('Active', 'Payed') and pp.MerchantCode=? and pr.starttime >= ? and pr.starttime < ? ";//这里的  ？代表参数
```

## [SQL中的多表查询，以及JOIN的顺序重要么](http://www.cnblogs.com/aguncn/p/6072606.html)



## ArrayList list = new ArrayList() 和List<String> list = new ArrayList<String>() 的区别

第一种形式用当前类作为引用类型，那么可以访问到ArrayList这个类中的所有公用方法。

第二种形式，用ArrayList实现的接口List作为引用类型，那么通过list引用可以访问到接口中定义的方法。也就是说ArrayList这个类实现了List接口，除了要必须实现接口List中声明的方法外，还可以实现额外的一些方法。但是，第二种形式就无法调用的List接口以外的方法。
使用上，设计模式中有：“代码尽量依赖于抽象，不依赖于具体”。

第一种形式就是依赖具体，第二种形式就是依赖于抽象。

因为List是接口。代码依赖于抽象的好处是，代码可以方便替换。例如，代码List list = new ArrayList();下面通过list来操作集合。代码编写后发现集合使用的不准确，应该使用LinkedList，那么只要修改一行代码List list = new LinkedList();就可以，这行以后的代码不需要修改，因为List接口保证了调用的都是接口中的方法，而ArrayList与LinkedList都实现了List接口。而如果当时用ArrayList list = new ArrayList()这种形式的话，那么list访问到的就可能是ArrayList里独有的方法而非List接口中的方法。这样替换成LinkedList的时候就有可能需要修改很多的代码。

ArrayList() 是ArrayList.java的构造方法

## java泛型



```
GenericTest.java
import java.util.List;
import java.util.ArrayList;
public class GenericTest {

    public static void main(String[] args) {
        List list = new ArrayList();
        list.add("qqyumidi");
        list.add("corn");
        list.add(100);

        for (int i = 0; i < list.size(); i++) {
            String name = (String) list.get(i); // 1
            System.out.println("name:" + name);
        }
    }
}
```

命令行编译： javac  GenericTest.java 	// 生成GenericTest.class文件，这里有提示：注: GenericTest.java使用了未经检查或不安全的操作。注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。

```
在jdk1.5后Java加入的泛型--用来对源代码的安全性检查
其中List和Vector类是有泛型的 当然指定List的类型也可以但是编译器会给警告提示你
解决办法：
1、给List和Vector都加上泛型
2、使用jdk1.4的便有一环境
List list = new Vector();改成List<Object> list = new Vector<Object>();
因为你没有指定类型，给你的警告，其实不影响运行的！
```

java GenericTest



```
public class GenericTest {
    public static void main(String[] args) {
        /*
        List list = new ArrayList();
        list.add("qqyumidi");
        list.add("corn");
        list.add(100);
        */
        List<String> list = new ArrayList<String>();
        list.add("qqyumidi");
        list.add("corn");
        //list.add(100);   // 1  提示编译错误
        for (int i = 0; i < list.size(); i++) {
            String name = list.get(i); // 2
            System.out.println("name:" + name);
        }
    }
}
```



 select * from a left join b on a.abid = b.baid left join  c  on c.cbid = b.bcid 
顺序是先a,b组合成一个虚拟表，然后虚拟表再和C表关联

```
String sql = "select c.oid as clientId, c.firstname as clientName, pr.ordernumber as orderNumber, " //
				+ " DATE_FORMAT(pr.starttime,'%Y%m%d') transactionDate, DATE_FORMAT(pr.starttime,'%H%i%s') transactionTime, " //
				+ " ce.AccountNumber as accountNumber, pr.orderamount as transAmount from paymentrequest pr " //
				+ " left join client c on pr.clientid=c.oid left join clientexternalaccount ce on ce.clientid=c.oid and ce.MerId=? " //
				+ " left join agreementrequest ar on pr.agreementrequestid=ar.oid left join productoffering po on ar.targetproductofferingid=po.oid " //ProductOffering zhubiao
				+ " left join productprovider pp on po.ProductProviderId=pp.oid " // productprovider zhubiao
				+ " where pr.businesstype IN ('26','22') and pr.paymentstatus IN ('Active', 'Payed') and pp.MerchantCode=? and pr.starttime >= ? and pr.starttime < ? ";
```

## SQL中的多表查询，以及JOIN的顺序重要么

一般来说，JOIN的顺序不重要，除非你要自己定制driving table。





## java泛型：？T K E V 代表的意思

平时看java源代码的时候，如果碰到泛型的话，我想? T K V E这些是经常出现的，但是有时想不起来代表什么意思，今天整理下： 

？ 表示不确定的java类型。 
T  表示java类型。 
K V 分别代表java键值中的Key Value。 
E 代表Element。 

Object跟这些东西代表的java类型有啥区别呢？ 
Object是所有类的根类，是具体的一个类，使用的时候可能是需要类型强制转换的，但是用T ？等这些的话，在实际用之前类型就已经确定了，不需要强制转换。



# 2017608



## 泛型：List<Map<String, Object>> 与 map<string，list>

Java语言是强类型（strongly typed）语言，意思是每个变量和每个表达式都有一个在编译时，就确定的额理性，所以，所有的变量必须显式声明类型，也就是说，所有的变量必须先声明，后使用。类型限制了一个变量能被赋的值，限制了一个表达式可以产生的值，限制了在这些值上可以进行的操作，并确定了这些操作的含义。

> 强-弱、静态-动态。 上面提到的强类型应该就是静态类型。java是弱类型（自动类型转换）与强制类型转换对应。

Java语言支持的类型分为两类：基本类型（primitive Type）和引用类型（Reference Type）

基本类型：Boolean类型和数值类型。数值类型有整数类型和浮点类型。整数类型包括byte、short、int、long、char，浮点类型包括float和double。

引用类型包括：类、接口和数组类型，还有一种特殊的null类型。

所谓**引用类型**就是对一个对象的引用，对象包括实例和数组两种。实际上**引用类型变量**就是一个**指针**，只是Java语言不再使用指针这个说法。

## JAVA数组类型

python类中的`__init__()`方法相当于java中的构造函数
python和java均可以省略构造函数。
在java类中，如果不显示声明构造函数，JVM 会给该类一个默认的构造函数。
一个类 可以有多个构造函数。
构造函数的主要作用
Java的数组要求所有的数组元素具有相同的数据类型。即一个数组里只能存储一种数据类型，而不能存储多种数据类型的数据。
一旦数组的初始化完成，数组在内存中所占的空间将被固定下来，因此数组的长度讲不可改变。
int[]是一种数据类型， 使用int[]类型来定义变量、进行类型转换时与使用其他普通类型没有任何区别。int[]类型是一种引用类型，创建int[]类型的对象也就是创建数组，需要使用创建数组的语法。

```
type[] arrayname
type arrayname[]
```


## 文件编码格式转换（utf-8、gbk）

使用notepad++打开文件： 格式-->转为***编码格式-->保存。

也有一些批量文件编码转换器，例如： 批量文件GBK-UTF8编码转换器.exe。

## Spring中的RowMapper接口作用

用来把数据库中的列字段和java bean中属性对应上，这样就可以赋值了。	
就像JDBC中的bean.setName(rs.getString("name")); 
Spring把这段代码抽象出来写成RowMapper。

RowMapper可以将数据中的每一行封装成用户定义的类，在数据库查询中，如果返回的类型是用户自定义的类型则需要包装，如果是Java自定义的类型，如：String则不需要，Spring最新的类SimpleJdbcTemplate使用更加简单了。    



# 20170609



## pycharm改变主题theme，以及字体颜色等

pycharm--->file--->settings： 

- Editor-->Colors&Fonts--->选择python，然后又可以点击具体的字体更改其颜色。
- Appearance&Behavior--->appearance可以找到UI Options：theme，override default fonts by （not recommended）：




更改STS的主题改了很久，没搞出啥来。

下一个改这个：

./bam-application/src/main/java/com/mdiaf/recon/service/RYBJobServiceImpl.java:106:             List<Map<String,Object>> RYBSurrenderList = jdbcTemplate.queryForList(sql, startDateString,endDateString);

# 20170611

## ORM 分库分表改造的一般原则

1. 首先shardingkey
2. 不允许全表查询的，效率太低。

## mysql下出现Unknown column 'id' in 'on clause'的解决方法：

原因：

MySQL5.0 Bug, 要把联合的表用括号包含起来才行:

Sql代码  
SELECT (c.id, a.id, b.id) FROM A a, B b LEFT JOIN C c ON c.a_id = a.a_id AND c.b_id = b.b_id  
这句话执行应该是没有错误的,但是Mysql 5 下执行则会出错。

因为mysql下有这样一个BUG,要把联合的表用括号包含起来才行：

Sql代码  
SELECT (c.id, a.id, b.id) FROM (A a, B b) LEFT JOIN C c ON c.a_id = a.a_id AND c.b_id = b.b_id  

# 20170612



## jdbcTemplate与hibernatetemplate

JDBCTemplate是Spring对jdbc的封装，但sql还是得自己写，一旦要写sql，则会增加灵活和复杂性，当然也不利于跨数据库（毕竟每个数据库的实现产品的sql也不竟相同）。
若使用hibernate则不用关心底层的数据库是哪个数据库，在编程方面，也更对象化了，比如
save(Object obj),我们操作的都是对象。hibernate也利用了缓存产生实现与数据库的读取操作，提高……







## git diff获取差异文件中文乱码的解决办法

通过git的diff命令对两个commit id的版本进行差异化的对比。中文文件时出现乱码。

执行如下命令，修改core.quotepath参数即可。

`git config --global core.quotepath false`





## bam改造新得

测试：http://127.0.0.1:8080/bam/Baf/BafConsole 系统控制台
127.0.0.1:8080/bam/富聪金融业务分析监控系统
return operationReconJob.loadChildRequest()



```
//测试武刚给的
import com.mdiaf.batch.domain.ClientInfo;
import com.mdiaf.batch.internal.ClientMapItemProcessor;

ClientInfo client = new ClientInfo();
ClientMapItemProcessor cl = new ClientMapItemProcessor();

cl.process(client);
```

```
自己的那个OperationReconJob文件
import com.mdiaf.recon.service.OperationReconJob;
OperationReconJob cl = new OperationReconJob();
return cl.getReconUpdates()
```



查看某个方法被调用了几次，可以通过在这个方法上面右键-->References-->workspace（ctrl-shift-G）



# 20100613



两个group by的问一下武刚，武刚说了 不用了



## sql语句 IFNULL(expr1,expr2),   case  when  then  else  end

case when then else end

SELECT            
​    case                   -------------如果
​    when sex='1' then '男' -------------sex='1'，则返回值'男'
​    when sex='2' then '女' -------------sex='2'，则返回值'女'  
​    else 0                 -------------其他的返回'其他’
​    end                    -------------结束
from   sys_user            --------整体理解： 在sys_user表中如果sex='1'，则返回值'男'如果sex='2'，则返回值'女' 否则返回'其他’



IFNULL(expr1,expr2)的用法：

假如expr1   不为   **NULL**，则   IFNULL()   的返回值为   expr1; 
否则其返回值为   expr2。IFNULL()的返回值是数字或是字符串，具体情况取决于其所使用的语境。
**mysql**>   SELECT   IFNULL(1,0);   
​                  ->   1   
**mysql**>   SELECT   IFNULL(**NULL**,10);   
   ->   10   
 **mysql**>   SELECT   IFNULL(1/0,10);   
​           ->   10   
**mysql**>   SELECT   IFNULL(1/0,'yes');   
​            ->   'yes'  



方法、类不用之后就@deprecated掉。

OrmUtilities.leftJoinListMap(clientBasicInfoList, clientBasicInfoSql_mainList, "companyid", "pcoid");

java字符串注意用双引号



# 20170614



## 匿名内部类

[]: http://www.cnblogs.com/nerxious/archive/2013/01/25/2876489.html



## 枚举类

在某些情况下，一个类的对象有限而且固定的，比如季节类，它只有四个对象；再比如行星类，目前只有9个对象。这种实例有限而且固定的类，在java里被称为枚举类。



# 20170619



第一次测试，实际是groovy

用 Groovy 更迅速地对 Java 代码进行单元测试

```

import com.mdiaf.fund.etl.AssembleFund03File;
import java.text.ParseException;
import java.text.SimpleDateFormat;
		String distributor="323";
        Date startDate = null;
		Date businessDate = null;
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

		try
		{
			startDate = sdf.parse("2000-11-04");
			businessDate = sdf.parse("3000-11-04");
		}
		catch(ParseException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
AssembleFund03File a1=new AssembleFund03File( distributor,  businessDate,  startDate);

return a1.loadData();
```



# 20170620





```
从 @Deprecated 到 使用下面这种方式

try {
			throw new Exception("this method ");
	} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
 }

2 quick fixes available:
	add throws declaration
	surround with try/catch


```



## eclipse注释

Ctrl+/快捷键：所选代码被“//”注释掉。当调试完后，可再次按住Ctrl+/快捷键打开注释。

Ctrl+Shift+C快捷键：所选代码被“//”注释掉。当调试完后，可再次按住Ctrl+Shift+C快捷键打开注释。

Ctrl+Shift+/快捷键：所选代码被“/*  */”注释掉。当调试完后，可按住Ctrl+Shift+\快捷键打开注释。



```

import com.mdiaf.recon.service.FarmsOperationManagerImpl;
import java.text.ParseException;
import java.text.SimpleDateFormat;
		String distributor="323";
        Date startDate = null;
		Date businessDate = null;
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

		try
		{
			startDate = sdf.parse("2000-11-04");
			businessDate = sdf.parse("3000-11-04");
		}
		catch(ParseException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
FarmsOperationManagerImpl fomi=new FarmsOperationManagerImpl();
return fomi.queryProcessLevelAgreementRequests(startDate,businessDate);
```

## java异常处理机制

java的一场机制主要依赖于try,catch,finally,throw和throws五个关键字，其中try关键字后紧跟一个花括号括起来的代码块，
throws关键字主要在方法签名中使用，用于声明该方法可能抛出的异常；
throw主要用于抛出一个实际的异常，throw可以单独作为语句使用，抛出一个具体的异常对象。
java.lang.Object
java.lang.Throwable
java把所有非正常情况分成两种：异常（exception），错误（Error），它们继承Throwable父类。

java7之前，每个catch块只能捕获一种类型的异常：但从Java7开始，一个catch块可以捕获多种类型的异常。不活多种类型的异常时，多种异常类型之间用使用竖线（|）隔开。异常变量有隐式，因此程序不能对异常变量重新赋值。

使用finally回收资源：有时候，程序在try块里打开了一些物理资源（例如数据块连接、网络连接和磁盘文件等），这些物理资源必须显式回收。

> java的垃圾回收机制不会回收任何物理资源，垃圾回收机制只能回收堆内存中对象所占的内存。

```
public class MultiExceptionTest
{
	public static void main(String[] args) 
	{
		try
		{
			int a = Integer.parseInt(args[0]);
			int b = Integer.parseInt(args[1]);
			int c = a / b;
			System.out.println("您输入的两个数相除的结果是：" + c );
		}
		catch (IndexOutOfBoundsException|NumberFormatException|ArithmeticException ie)
		{
			System.out.println("程序发生了数组越界、数字格式异常、算术异常之一");
			// 捕捉多异常时，异常变量默认有final修饰，
			// 所以下面代码有错：
			ie = new ArithmeticException("test");  //①
		}
		catch (Exception e)
		{
			System.out.println("未知异常");
			// 捕捉一个类型的异常时，异常变量没有final修饰
			// 所以下面代码完全正确。
			e = new RuntimeException("test");    //②
		}
	}
}
```

	|-Throwable
		|-Error
			|-AWTError
			|-IOError
			|-LinkageError
			|-ThreadDeath
		|-Exception
			|-RuntimeException
				|-NullPointerException
				|-IndexOutOfBoundsException
				|-ClassCastException
			|-IOException
			|-SQLException




```
try {
			throw new Exception("this method ");
	} 
	catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
	}
```



## java 在命令端运行 出现乱码

法一：在命令行客户端设置 character set为 gbk，java文件也保存为gbk格式。



> java中采用的是unicode标准字符集
> Java语言使用unicode标准字符集，最多可以识别65535个字符，unicode字符表的前128个字符刚好是ASCII表。每个国家的“字母表”的字母都是unicode表中的一个字符，比如汉字中的“你”字就是unicode表中的第20320字符。
> Java所谓的字母包括了世界上任何语言中的“字母表”，因此，Java所使用的字母不仅包括通常的拉丁字母，a,b,c等，也包括汉语中的汉字，日文里的片假名，平假名，朝鲜文以及其他许多语言中的文字。
> java平台的默认编码是Unicode码吧。
> 你是怎么判断编译器的默认编码方式的？

## 计算机编码



## 序列化



java中serializable
一个对象序列化的接口，一个类只有实现了Serializable接口，它的对象才是可序列化的。因此如果要序列化某些类的对象，这些类就必须实现Serializable接口。而实际上，Serializable是一个空接口，没有什么具体内容，它的目的只是简单的标识一个类的对象可以被序列化。
java.io.Serializable
什么情况下需要序列化 
a）当你想把的内存中的对象写入到硬盘的时候；
b）当你想用套接字在网络上传送对象的时候；
c）当你想通过RMI传输对象的时候；
再稍微解释一下:
a)比如说你的内存不够用了，那计算机就要将内存里面的一部分对象暂时的保存到硬盘中，等到要用的时候再读入到内存中，硬盘的那部分存储空间就是所谓的虚拟内存。在比如过你要将某个特定的对象保存到文件中，我隔几天在把它拿出来用，那么这时候就要实现Serializable接口；
b)在进行java的Socket编程的时候，你有时候可能要传输某一类的对象，那么也就要实现Serializable接口；最常见的你传输一个字符串，它是JDK里面的类，也实现了Serializable接口，所以可以在网络上传输。
c)如果要通过远程的方法调用（RMI）去调用一个远程对象的方法，如在计算机A中调用另一台计算机B的对象的方法，那么你需要通过JNDI服务获取计算机B目标对象的引用，将对象从B传送到A，就需要实现序列化接口。
没有人说的话能全部准确，批判性的参考。


python
在程序运行的过程中，所有的变量都是在内存中，比如，定义一个dict：`d = dict(name='Bob', age=20, score=88)`
可以随时修改变量，比如把`name`改成`'Bill'`，但是一旦程序结束，变量所占用的内存就被操作系统全部回收。如果没有把修改后的`'Bill'`存储到磁盘上，下次重新运行程序，变量又被初始化为`'Bob'`。
我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。
序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。
反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。
Python提供两个模块来实现序列化：cPickle和pickle。这两个模块功能是一样的，区别在于cPickle是C语言写的，速度快，pickle是纯Python写的，速度慢，跟cStringIO和StringIO一个道理。用的时候，先尝试导入cPickle，如果失败，再导入pickle：
```try:
    import cPickle as pickle
except ImportError:
    import pickle
 ````
如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。
JSON表示的对象就是标准的JavaScript语言的对象


## 远程访问

如果您回到家后想连接控制在学校或公司里自己的电脑，很多人会想到使用Windows远程桌面连接。一般情况下，它无疑是最好的方案了，但如果你要连接的电脑位于内网，即路由器（Router）或防火墙后方(电脑是内部IP)，那样就必须在路由器上做一些设定端口映射之类的设置才有办法连上，而网管也不太可能帮您设定的。

TeamViewer是一个能在任何防火墙和NAT代理的后台用于远程控制，桌面共享和文件传输的简单且快速的解决方案。为了连接到另一台计算机，只需要在两台计算机上同时运行 TeamViewer 即可，而不需要进行安装（也可以选择安装，安装后可以设置开机运行）。该软件第一次启动在两台计算机上自动生成伙伴 ID。只需要输入你的伙伴的ID到TeamViewer，然后就会立即建立起连接。

> 所谓防火墙指的是一个由软件和硬件设备组合而成、在内部网和外部网[之[间、专用网与公共网之间的界面上构造的保护屏障.是一种获取安全性方法的形象说法，它是一种计算机硬件和软件的[结合]0%88)，使[Internet与Intranet之间建立起一个安全网关（Security Gateway），从而保护内部网免受非法用[户的侵入，防火墙主要由服务访问规则、验证工具、[包过滤](http://baike.baidu.com/item/%E5%8C%85%E8%BF%87%E6%BB%A4)和[应用网关](http://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E7%BD%91%E5%85%B3)4个[部分](http://baike.baidu.com/item/%E9%83%A8%E5%88%86)组成，防火墙就是一个位于[计算机](http://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA)和它所连接的[网络](http://baike.baidu.com/item/%E7%BD%91%E7%BB%9C)之间的[软件](http://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6)或[硬件](http://baike.baidu.com/item/%E7%A1%AC%E4%BB%B6)。该计算机流入流出的所有[网络通信](http://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1)和[数据包](http://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8C%85)均要经过此防火墙。
>
> 在网络中，所谓“[防火墙](http://baike.baidu.com/item/%E9%98%B2%E7%81%AB%E5%A2%99)”，是指一种将[内部网](http://baike.baidu.com/item/%E5%86%85%E9%83%A8%E7%BD%91)和公众访问网（如Internet）分开的方法，它实际上是一种[隔离技术](http://baike.baidu.com/item/%E9%9A%94%E7%A6%BB%E6%8A%80%E6%9C%AF)。防火墙是在两个网络通讯时执行的一种[访问控制](http://baike.baidu.com/item/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6)尺度，它能允许你“同意”的人和数据进入你的网络，同时将你“不同意”的人和数据拒之门外，最大限度地阻止网络中的[黑客](http://baike.baidu.com/item/%E9%BB%91%E5%AE%A2)来访问你的网络。换句话说，如果不通过防火墙，公司内部的人就无法访问Internet，Internet上的人也无法和公司内部的人进行通信。
```



# 20170621



## 进程线程					[编程思想之多线程多进程java](http://blog.csdn.net/luoweifu/article/details/46673975)

进程一般由程序、数据集合和进程控制块三部分组成。

程序用于描述进程要完成的功能，是控制进程执行的指令集；
数据集合是程序在执行时所需要的数据和工作区；
程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。

@service 文件下边测试 不需要 new 直接小写 使用。

文件



## 注解

```
import com.mdiaf.recon.service.FarmsOperationManagerImpl;
import java.text.ParseException;
import java.text.SimpleDateFormat;
Date startDate = null;
Date businessDate = null;
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
		try
		{
			startDate = sdf.parse("2000-11-04");
			businessDate = sdf.parse("3000-11-04");
		}
		catch(ParseException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

//	FarmsOperationManagerImpl fomi=new FarmsOperationManagerImpl();
//	return fomi.queryProcessLevelAgreementRequests(startDate,businessDate);
return farmsOperationManager.queryProcessLevelAgreementRequests(startDate,businessDate).size();
```

```
import com.mdiaf.bmf.SObject;
import com.mdiaf.recon.service.FarmsOperationManagerImpl;
SObject requestSO;
farmsOperationManager.syncFarmsMasterData(requestSO);
```



分表里有 order by 的queryforlist（）必须要有shardingkey

ORMERROR, Order By clause is not support in this query method, please use   bmfOrmAggrManager.queryForList(long shardingId, String sql, Object... args)

[]
[FCLOG] 16:34:15.641 [quartzScheduler_Worker-2] ERROR c.a.druid.filter.stat.StatFilter T: U: - slow sql 10221 millis. 
call all_yq_daily_report('WYYQ',DATE_SUB(NOW(),INTERVAL 1 DAY))
[]
[FCLOG] 16:34:15.754 [quartzScheduler_Worker-1] ERROR c.a.druid.filter.stat.StatFilter T: U: - slow sql 10288 millis. 
call all_yq_weekly_report('WYYQ', DATE_SUB(NOW(),INTERVAL 7 DAY))
[]
[FCLOG] 16:34:42.759 [http-bio-8080-exec-10] ERROR com.mdiaf.orm T:f34366762e2b0970 U:18599 - ORMERROR, Order By clause is not support in this query method, please use   bmfOrmAggrManager.queryForList(long shardingId, String sql, Object... args)





```
OperationReconJob.java

```



# 20160622



## bam测试成功的第一个

```
package com.mdiaf.fund.etl;
public class AssembleFund03File extends BaseFundFile {}


public List<Map<String, Object>> loadData() {
		/* 这个方法使用的是bam库，这个库里边使用的是bam库，这个库里边pp.MerchantCode字段不存在，所以有错误，后边根据逻辑分库分表，这个方法可能暂时没人用了，要不早就报错了，先改了，后边再看	*/
		BmfAggrDao bmfAggrDao = (BmfAggrDao) AiafContext.getBean("bmfAggrDao");
		String sql = "select c.oid as clientId, c.firstname as clientName, pr.ordernumber as orderNumber, " //
				+ " DATE_FORMAT(pr.starttime,'%Y%m%d') transactionDate, DATE_FORMAT(pr.starttime,'%H%i%s') transactionTime, " //
				+ " ce.AccountNumber as accountNumber, pr.orderamount as transAmount from paymentrequest pr " //
				+ " left join client c on pr.clientid=c.oid left join clientexternalaccount ce on ce.clientid=c.oid and ce.MerId=? " //
				+ " left join agreementrequest ar on pr.agreementrequestid=ar.oid left join productoffering po on ar.targetproductofferingid=po.oid " //ProductOffering zhubiao po
				+ " left join productprovider pp on po.ProductProviderId=pp.oid " // productprovider zhubiao pp
				+ " where pr.businesstype IN ('26','22') and pr.paymentstatus IN ('Active', 'Payed') and pp.MerchantCode=? and pr.starttime >= ? and pr.starttime < ? ";

		String merchantId = getMerchantId();
			
		Date bizStartDate = (new DateTime(startDate)).plusHours(15).toDate();
		Date bizEndDate = (new DateTime(businessDate)).plusHours(15).toDate();
		OrmUtilities.modifyBegin();
//		return bmfAggrDao.getJdbcTemplate().queryForList(sql, merchantId, merchantId, bizStartDate, bizEndDate);
		BmfOrmAggrManager bmfOrmAggrManager = AiafContext.getBean(BmfOrmAggrManager.class);
		List<Map<String, Object>> objectMapList = new ArrayList<Map<String, Object>>(); 
		String mainSql="select po.oid as poId from productoffering po left join productprovider pp on po.ProductProviderId=pp.oid where pp.MerchantCode=? ";
		List<Map<String, Object>> rightListMap = bmfOrmAggrManager.queryForList(mainSql,merchantId);	
		if( rightListMap == null )
			   return null;
		if( rightListMap.size() == 0 )
			   return rightListMap;

		List<Long> poOidList = Lists.newArrayList();
		for (Map<String, Object> rightMap : rightListMap) {
			  if (rightMap == null)
			     continue;
			  Long poId = (Long) rightMap.get("poId");
			  if (poId == null)
			     continue;
			  poOidList.add(poId);
		}
		String inString = OrmUtilities.buildSqlInString(poOidList);
		List<Map<String, Object>> leftListMap;
		if(inString!=null) {
			String shardingSql="select c.oid as clientId, c.firstname as clientName, pr.ordernumber as orderNumber,ar.targetproductofferingid,"//
					+ " DATE_FORMAT(pr.starttime,'%Y%m%d') transactionDate, DATE_FORMAT(pr.starttime,'%H%i%s') transactionTime, " //
					+ " ce.AccountNumber as accountNumber, pr.orderamount as transAmount from paymentrequest pr " //
					+ " left join client c on pr.clientid=c.oid left join clientexternalaccount ce on ce.clientid=c.oid and ce.MerId=? " //
					+ " left join agreementrequest ar on pr.agreementrequestid=ar.oid"//
					+ " where pr.businesstype IN ('26','22') and pr.paymentstatus IN ('Active', 'Payed') and pr.starttime >= ? and pr.starttime < ? "
					+ " and ar.targetproductofferingid IN "+inString;
			leftListMap = bmfOrmAggrManager.queryForList(shardingSql, merchantId, bizStartDate, bizEndDate);
			OrmUtilities.leftJoinListMap(leftListMap, rightListMap, "targetproductofferingid", "poId");
		}else
			return null;
		OrmUtilities.modifyEnd();
		return leftListMap;
	}
	
	
------------------------------------------------------------------------------------
import com.mdiaf.fund.etl.AssembleFund03File;
import java.text.ParseException;
import java.text.SimpleDateFormat;
		String distributor="323";
        Date startDate = null;
		Date businessDate = null;
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

		try
		{
			startDate = sdf.parse("2000-11-04");
			businessDate = sdf.parse("3000-11-04");
		}
		catch(ParseException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
AssembleFund03File a1=new AssembleFund03File( distributor,  businessDate,  startDate);
return a1.loadData().size();
```

内存溢出JVM运行报错：GC overhead limit exceeded

断点没打 会一下子 下去 可能抱错

双击TomCate-----------open launch configuration--Arguments

# 20170623



##  JVM内存的设置（解决eclipse下out of memory问题）

Tomcat本身不能直接在计算机上运行，需要依赖于硬件基础之上的操作系统和一个Java虚拟机。Tomcat的内存溢出本质就是JVM内存溢出，所以在本文开始时，应该先对Java  JVM有关内存方面的知识进行详细介绍。
Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。
对于一个初学者来说，可以这样认为，**当在一台机器上配置好Apache 服务器，可利用它响应HTML（标准通用标记语言下的一个应用）页面的访问请求。**实际上Tomcat 部分是Apache 服务器的扩展，但它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。
诀窍是，当配置正确时，Apache 为HTML页面服务，而Tomcat 实际上运行JSP 页面和Servlet。另外，**Tomcat和IIS等Web服务器一样，具有处理HTML页面的功能，另外它还是一个Servlet和JSP容器，独立的Servlet容器是Tomcat的默认模式。**不过，Tomcat处理静态HTML的能力不如Apache服务器。目前Tomcat最新版本为9.0。
说了这么多，接下来我从实际应用和开发的角度来说说Tomcat，首先，你要知道，它是一个开源项目，既然开源，我们网上下载了一个Tomcat，就是可以免费使用的。OK，这都没有问题，在我们实际的开发过程中呢，一般都是用tomcat来进行项目测试的。简单来说，当我写一个web项目，就是一边写，一边部署到Tomcat上，然后看看效果，如果感觉不对，那么改，然后重启Tomcat，再看。大多数情况下，作为JavaWeb开发者的你，以后几乎每天都要和这只三条腿的猫打交道。

jvisualvm 在命令行端执行jvisualvm可以看到java tomcat 的jvm配置信息



一、java JVM内存介绍
JVM管理两种类型的内存，堆和非堆。
按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“
在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。
简单来说：
**堆**就是Java代码可及的内存，是留给开发人员使用的；
**非堆**就是JVM留给自己用的，
所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法的代码都在非堆内存中，它和堆不同，运行期内GC不会释放其空间。

**堆内存分配** :

**非堆内存分配** :也叫**永久保存的区域**，用于存放Class和Meta信息,Class在被Load的时候被放入该区域。它和存放类实例(Instance)的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理。JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。 GC不会对PermGen space进行清理，所以如果你的APP会LOAD很多CLASS的话,就很可能出现PermGen space错误。

```
-Xmx    Java Heap最大值，默认值为物理内存的1/4；
-Xms    Java Heap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发测试机JVM可以保留默认值；
-Xmn    Java Heap Young区大小，不熟悉最好保留默认值；
-Xss      每个线程的Stack大小，不熟悉最好保留默认值；
-XX:PermSize：设定内存的永久保存区域； 
-XX:MaxPermSize：设定最大内存的永久保存区域；
-XX:PermSize：设定内存的永久保存区域；
-XX:NewSize：设置JVM堆的‘新生代’的默认大小；
-XX:MaxNewSize：设置JVM堆的‘新生代’的最大大小；
```

在myeclipse下启动tomcat服务器有2个javaw.exe 
就是有两个javaw.exe的 你把占内存小的进程杀掉 你的tomcat就挂了，把占内存大的进程杀掉 myec..就挂了。



## spring 基本知识

annotation [ænə'teɪʃ(ə)n]  [ˌænəˈteʃən] An annotation is a note that is added to a text or diagram, often in order to explain it. 注释
Annotation是代码里的特殊标记，这些标记可以在编译、累加载、运行时被读取，并执行相应的处理。
通过使用Annotation，程序开发人员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充的信息。
代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。
Annotation提供了一种为程序元素设置元数据的方法，从某些方面看，Annotation就像修饰符一样，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被存储在Annotation的“name=value”对中。

Annotation是一个接口，程序可以通过反射来获取指定程序元素的Annotation对象，然后通过Annotation对象来取得注释里的元素


spring 2.5 中除了提供 @Component 注释外，还定义了几个拥有特殊语义的注释，它们分别是：@Repository、@Service 和 @Controller。在目前的 
Spring 版本中，这 3 个注释和 @Component 是等效的
@Repository、@Service 和 @Controller。
持久层、业务层和控制层（Web 层）相对应
这 3 个注释和 @Component 是等效的，但是从注释类的命名上，很容易看出这 3 个注释分别和持久层、业务层和控制层（Web 层）相对应。

如果 Web应用程序采用了经典的三层分层结构的话，最好在持久层、业务层和控制层分别采用 @Repository、@Service 和@Controller 对分层中的类进行注释，而用 @Component 对那些比较中立的类进行注释。
在一个稍大的项目中，通常会有上百个组件，如果这些组件采用xml的bean定义来配置，显然会增加配置文件的体积，查找以及维护起来也不太方便。 
Spring2.5为我们引入了组件自动扫描机制，他可以在类路径底下**标注了@Component,@Service,@Controller,@Repository注解的类，并把这些类纳入进spring容器中管理。**作用和在xml文件中使用bean节点配置组件时一样的。要使用自动扫描机制，我们需要打开以下配置信息：
```
<?xml version="1.0" encoding="UTF-8" ?> 
<beans
xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-nstance" 
xmlns:context="http://www.springframework.org/schema/context"
xsi:schemaLocation="http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context-2.5.xsd">
<context:component-scan base-package=”com.eric.spring”>   
</beans>  
```
其中base-package为需要扫描的包（含所有子包） 
@Service用于标注业务层组件， 
@Controller用于标注控制层组件（如struts中的action）, 
@Repository用于标注数据访问组件，即DAO组件，而 
@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。 
@Service public class VentorServiceImpl implements iVentorService{ } 
@Repository public class VentorDaoImpl implements iVentorDao { } getBean的默认名称是类名（头字母小写），如果想自定义，可以@Service(“aaaaa”)这样来指定，这种bean默认是单例的，如果想改变，可以使用@Service(“beanName”) 
@Scope(“prototype”)来改变。可以使用以下方式指定初始化方法和销毁方法（方法名任意）： @PostConstructpublic void init() { } 
@PreDestroy public void destory() { }


package org.springframework.stereotype;
import org.springframework.stereotype.Component;
@Component()



import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;



```
import com.mdiaf.recon.service.OperationReconJob;
return operationReconJob.loadAllProductInfo();
```

```
import com.mdiaf.recon.service.OperationReconJob;
long theRequestId= 34686036;
return operationReconJob.loadChildRequests(theRequestId);
```

```
import com.mdiaf.recon.service.OperationReconJob;
long agreementRequestId= 233471584;
return operationReconJob.loadRootRequestRecursively(agreementRequestId);
```

发现queryformap查询 有orderby的sql是可以的。上面几个差不多的queryforlist只测了一个。因为后面几个不太好测 需要有上面的关联。至此这个额文件已经测完。

```
String sql = "select AR.*,PY.OrderNumber,PY.CreatedOn as PayTime, PY.PaymentStatus from AgreementRequest AR left join PaymentRequest PY on PY.agreementrequestId = AR.oid  where AR.oid = ? order by PY.createdOn desc limit 1"; // and
		// ARS.ProductCategoryCode
		// = ?
		OrmUtilities.modifyBegin();
//		Map<String, Object> queryResult = jdbcTemplate.queryForMap(sql, agreementRequestId);
		Map<String, Object> queryResult = bmfOrmAggrManager.queryForMap(sql, agreementRequestId);
```



# 20170626



## 测试

```
import com.fc.bam.service.EtlManager;
final String path = "/NFS/attachment/bam/" + startDate + "月度统计" + nowDateStr + ".xls";
import java.text.ParseException;
import java.text.SimpleDateFormat;
		String distributor="323";
        Date startDate = null;
		Date businessDate = null;
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

		try
		{
			startDate = sdf.parse("2000-11-04");
			businessDate = sdf.parse("3000-11-04");
		}
		catch(ParseException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
etlManager.hyAssetsMouthLyExcel()
```



```
import com.mdiaf.report2.service.ClientReportManager2Impl;
//import com.mdiaf.bmf.SObject;
//SObject request=new SObject();
clientReportManager2.calcClientTransFact(null);
```







## 疯狂Java---- Java数组 ----- Object[ ]params=new Object[ ]{ };详细解释！！！

这是**Object类型的的数组定义构建初始化一体**的写法

但是里面没有初始化任何Object对象 params的index一个也没有

这写法跟 Object[] params = null；的唯一区别就是 前者非null 后者params是null

其实没什么意义，只有1个数组引用，连Object类型的引用都没有定义出来

正常的写法是
Object[] params;//定义
params = new Object[3];//构建,这时只有定义的4个引用，没有实际对象
params[0] = new Object();//初始化
params[1] = new Object();
params[2] = new Object();
后者一体的
Object[] params = new Object[]{ new Object(),new Object(),new Object()};



定义数组：

`type[] arrayName;`

`type arrayName[]`

数组的初始化：

1，静态初始化

arrayName = new type[] {element1,element2,element3,.....}

arrayNmae={element1,element2,element3,...}



2，动态初始化

arrayName=new type[length]

## 疯狂Java---- Java集合



## 疯狂Java---- Java泛型

## 

## java---null  默认给变量赋值

**一、null是代表不确定的对象**
Java中，null是一个关键字，用来标识一个不确定的对象。因此可以将null赋给**引用类型变量**，但**不可以将null赋给基本类型变量**。
比如：int a = null;是错误的。Ojbect o = null是正确的。
Java中，变量的使用都遵循一个原则，**先定义，并且初始化后，才可以使用**。我们不能int a后，不给a指定值，就去打印a的值。这条对对于引用类型变量也是适用的。
有时候，我们定义一个引用类型变量，在刚开始的时候，无法给出一个确定的值，但是不指定值，程序可能会在try语句块中初始化值。这时候，我们下面使用变量的时候就会报错。这时候，可以先给变量指定一个null值，问题就解决了。例如：
```
Connection conn = null;
try {
      conn = DriverManager.getConnection("url", "user", "password");
} catch (SQLException e) {
       e.printStackTrace();
}
String catalog = conn.getCatalog();
```
如果刚开始的时候不指定conn = null，则最后一句就会报错。
**二、null本身不是对象，也不是Objcet的实例**
null本身虽然能代表一个不确定的对象，但就null本身来说，它不是对象，也不知道什么类型，也不是java.lang.Object的实例。
可以做一个简单的例子：
```
//null是对象吗? 属于Object类型吗?
if (null instanceof java.lang.Object) {
    System.out.println("null属于java.lang.Object类型");
} else {
     System.out.println("null不属于java.lang.Object类型");
}
```
结果会输出：null不属于java.lang.Object类型
**三、Java默认给变量赋值**

在定义变量的时候，如果定义后没有给变量赋值，则Java在运行时会自动给变量赋值。
**赋值原则**是整数类型int、byte、short、long的自动赋值为0，带小数点的float、double自动赋值为0.0，boolean的自动赋值为false，其他各供引用类型变量自动赋值为null。
这个具体可以通过调试来看。

**四、容器类型与null**
List：允许重复元素，可以加入任意多个null。
Set：不允许重复元素，最多可以加入一个null。
Map：Map的key最多可以加入一个null，value字段没有限制。
数组：基本类型数组，定义后，如果不给定初始值，则java运行时会自动给定值。引用类型数组，不给定初始值，则所有的元素值为null。

**五、null的其他作用**
1、判断一个引用类型数据是否null。 用==来判断。
2、释放内存，让一个非null的引用类型变量指向null。这样这个对象就不再被任何对象应用了。等待JVM垃圾回收机制去回收。

## Java中的Null是什么？

null是Java中一个很重要的概念。null设计初衷是为了表示一些缺失的东西，例如缺失的用户、资源或其他东西。但是，一年后，令人头疼的空指针异常给Java程序员带来不少的骚扰。在这份材料中，我们将学习到Java中null关键字的基本细节，并且探索一些技术来尽可能的减少null的检查以及如何避免恶心的空指针异常。

1）首先，null是Java中的关键字，像public、static、final。它是大小写敏感的，你不能将null写成Null或NULL，编译器将不能识别它们然后报错。

`Object obj = NULL; ``// Not Ok`

``Object obj1 = ``null//Ok`

使用其他语言的程序员可能会有这个问题，但是现在IDE的使用已经使得这个问题变得微不足道。现在，当你敲代码的时候，IDE像Eclipse、Netbeans可以纠正这个错误。但是使用其他工具像notepad、Vim、Emacs，这个问题却会浪费你宝贵时间的。

2）就像每种原始类型都有默认值一样，如int默认值为0，boolean的默认值为false，null是任何引用类型的默认值，不严格的说是所有object类型的默认值。就像你创建了一个布尔类型的变量，它将false作为自己的默认值，Java中的任何引用变量都将null作为默认值。这对所有变量都是适用的，如[成员变量、局部变量](http://javarevisited.blogspot.sg/2012/02/difference-between-instance-class-and.html)、实例变量、静态变量（但当你使用一个没有初始化的局部变量，编译器会警告你）。为了证明这个事实，你可以通过创建一个变量然后打印它的值来观察这个引用变量，如下图代码所示：

```
private static Object myObj;
public static void main(String args[]){
    System.out.println("What is value of myObjc : " + myObj);
}
结果如下
What is value of myObjc : null
```

这对静态和非静态的object来说都是正确的。就像你在这里看到的这样，我将myObj定义为静态引用，所以我可以在主方法里直接使用它。注意主方法是静态方法，不可使用非静态变量。

 

## Spring注解@Component、@Repository、@Service、@Controller区别

这 3 个注释和 @Component 是等效的，但是从注释类的命名上，很容易看出这 3 个注释分别和持久层、业务层和控制层（Web 层）

在一个稍大的项目中，通常会有上百个组件，如果这些组件采用xml的bean定义来配置，显然会增加配置文件的体积，查找以及维护起来也不太方便。 
Spring2.5为我们引入了组件自动扫描机制，他可以在类路径底下寻找标注了@Component,@Service,@Controller,@Repository注解的类，并把这些类纳入进spring容器中管理。它的作用和在xml文件中使用bean节点配置组件时一样的。要使用**自动扫描机制**，我们需要打开以下配置信息：

```
<?xml version="1.0" encoding="UTF-8" ?> 
<beans 
xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema- nstance"
xmlns:context="http://www.springframework.org/schema/context"
xsi:schemaLocation="http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context-2.5.xsd"  > 
<context:component-scan base-package=”com.eric.spring”>   
</beans>
```

其中base-package为需要扫描的包（含所有子包） 
@Service用于标注业务层组件， 
@Controller用于标注控制层组件（如struts中的action）, 
@Repository用于标注数据访问组件，即DAO组件，而 
@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。 
@Service public class VentorServiceImpl implements iVentorService{ } 
@Repository public class VentorDaoImpl implements iVentorDao { } getBean的默认名称是类名（头字母小写），如果想自定义，可以@Service(“aaaaa”)这样来指定，这种bean默认是单例的，如果想改变，可以使用@Service(“beanName”) 
@Scope(“prototype”)来改变。可以使用以下方式指定初始化方法和销毁方法（方法名任意）： @PostConstructpublic void init() { } 
@PreDestroy public void destory() { }

注入方式： 
把DAO实现类注入到service实现类中，把service的接口(注意不要是service的实现类)注入到action中，注入时不要new 这个注入的类，因为spring会自动注入，如果手动再new的话会出现错误，然后属性加上 @Autowired后不需要getter()和setter()方法，Spring也会自动注入。至于更具体的内容，等对注入的方式更加熟练后会做个完整的例子上来。





JUnit是一个Java语言的单元测试框架。它由Kent Beck和Erich Gamma建立，逐渐成为源于Kent Beck的sUnit的xUnit家族中最为成功的一个。 JUnit有它自己的JUnit扩展生态圈。多数Java的开发环境都已经集成了JUnit作为单元测试的工具。

JUnit是由 Erich Gamma 和 Kent Beck 编写的一个回归测试框架（regression testing framework）。

**Junit测试是程序员测试，即所谓白盒测试**，因为程序员知道被测试的软件如何（How）完成功能和完成什么样（What）的功能。

Junit是一套框架，继承TestCase类，就可以用Junit进行自动测试了。





# 20170627



## Java类实现多个接口

java和C#一样，同样只能有一个基类，但可以有多个实现。
具有多个实现的一个好处就是，当实现多个接口时，如果两个接口有同样的方法，那么实现一次就可以了。

```
interface A
{
  public void show();
}
interface B
{
    public void show();
}
class C implements A,B
{
    public void show()
    {
        System.out.println("测试");
    }
}
class InterfaceDemo 
{
    public static void main(String[] args) 
    {
        C c=new C();
        c.show();
        System.out.println("Hello World!");
    }
}

由于接口没有方法体，所以接口可以实现多继承，例如：

interface AA
{
}
interface BB
{
}
interface CC extends AA,BB
{
}
class InterfaceExtentsDemo 
{
    public static void main(String[] args) 
    {
        System.out.println("Hello World!");
    }
}
以上代码可以实现编译，说明接口可以继承多个接口。
为什么不能实现类的多继承，主要是防止多个类有相同的方法名，
然而方法体不一样，子类就比较难选择了。所以java和C#不支持类的多继承

/A接口
interface A{
 public int getA();
}
//B接口
interface B{
 public int getB();
}
//实现了某个接口必须实现其全部的方法
public class ImpAB implements A,B{
 public int getA() {
  return 0;
 }
 public int getB() {
  return 0;
 }
}

```

## Java接口多个实现类

```
interface Test{
    public void print();//定义方法
}
class A implements Test{
    public void print(){
        System.out.println("Sub Class A");
    }
}
class B implements Test{
    public void print(){
        System.out.println("Sub Class B");
    }
}
public class TestClass{
    public static void main(){
    Test test = new A();
    test.print();//Sub Class A
    Test test = new B();
    test.print();//Sub Class B
}


// 定义一个接口
interface Person {  
    // 比如此接口定义了一个方法为吃东西。str表示要吃的东西。
    void eat(String str);
} 
// 第一个实现类
class FirstPerson implements Person { 
    private String name; 
    FirstPerson(String name) {
        this.name = name;
    } 
    // 实现了接口中定义的方法，必须用关键字public因为接口中定义的方法默认是public的。
    public void eat(String str) {
        System.out.println(name + "正在吃" + str);
    }
} 
// 第二个实现类
class SecondPerson implements Person {
    private String name; 
    SecondPerson(String name) {
        this.name = name;
    } 
    // 实现了接口中定义的方法，必须用关键字public因为接口中定义的方法默认是public的。
    public void eat(String str) {
        System.out.println(name + "正在吃" + str);
    }
} 
// 第三个实现类
class ThirdPerson implements Person {
    private String name; 
    ThirdPerson(String name) {
        this.name = name;
    } 
    // 实现了接口中定义的方法，必须用关键字public因为接口中定义的方法默认是public的。
    public void eat(String str) {
        System.out.println(name + "正在吃" + str);
    }
}
// 要通过接口实现类实现接口定义的方法的类
public class Test {
    public final static int FIRST = 0;
    public final static int SECOND = 1;
    public final static int THIRD = 2; 
    // 返回指定类型的接口
    public static Person printPerson(int kind) {
        Person p = null;
        switch (kind) {
            case FIRST: p = new FirstPerson("人1");break;
            case SECOND: p = new SecondPerson("人2");break;
            case THIRD: p = new ThirdPerson("人3");break;
        }
    }
    public static void main(String[] args) {
        // 可以通过工厂类决定要用的实现类。比如Test类是工厂。
         Test.printPerson(Test.FIRST);
    }
}
```



将两个类中相同的部分提取出来组成一个父类

子类拥有父类非private的属性，方法。

子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。

子类可以用自己的方式实现父类的方法。







# 20170628



http://127.0.0.1:8080/bam/AdminPanel/index#/index

SpiDashboardController.java

勋总今早跟我说的几点：

AIAF：Agile Internet APP Framework

FARMS：基于spring框架的再开发封装，bam与farms是上面的应用

transaction/trænˈzækʃən/：交易；事务；办理；会报，学报
N-COUNT A **transaction** is a piece of business, for example, an act of buying or selling something. 交易
例：
The transaction is completed by payment of the fee.
交易在支付费用之后就完成了。





## JSP

JSP全称Java Server Pages，是一种动态网页开发技术。它使用**JSP标签**在HTML网页中插入Java代码。**标签通常以<%开头以%>结束**。

JSP是一种Java servlet，主要用于**实现Java web应用程序的用户界面部分**&。网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。

JSP通过网页表单获取用户输入数据、访问数据库及其他数据源，然后**动态地创建网页**。

**JSP标签有多种功能**，比如**访问数据库、记录用户选择信息、访问JavaBeans组件等**，还可以在不同的网页中传递控制信息和共享信息。

## JSP的优势

- 与ASP相比：JSP有两大优势。首先，动态部分用Java编写，而不是VB或其他MS专用语言，所以更加强大与易用。第二点就是JSP易于移植到非MS平台上。
- 与纯 Servlets相比：JSP可以很方便的编写或者修改HTML网页而不用去面对大量的println语句。
- 与SSI相比：SSI无法使用表单数据、无法进行数据库链接。
- 与JavaScript相比：虽然JavaScript可以在客户端动态生成HTML，但是很难与服务器交互，因此不能提供复杂的服务，比如访问数据库和图像处理等等。
- 与静态HTML相比：静态HTML不包含动态信息。

elasticsearch



http://127.0.0.1:8080/bam/AdminPanel/index#/clientDashboard

http://localhost:8080/bam/Dashboard/SpiDashboard

http://localhost:8080/bam/Dashboard/SpiDashboard2



Tomcate配置

1，安装JDK 环境，Java 开发环境配置

首先我们需要下载java开发工具包JDK

下载后JDK的安装根据提示进行，还有安装JDK的时候也会安装JRE，一并安装就可以了。

配置环境变量

- 安装完成后，右击"我的电脑"，点击"属性"，选择"高级系统设置"；

- 选择"高级"选项卡，点击"环境变量"

- -在"系统变量"中设置3项属性，JAVA_HOME,PATH,CLASSPATH(大小写无所谓),若已存在则点击"编辑"，不存在则点击"新建"。

  变量设置参数如下：

  - 变量名：**JAVA_HOME**
  - 变量值：**C:\Program Files (x86)\Java\jdk1.8.0_91**        // 要根据自己的实际路径配置


  - 变量名：**CLASSPATH**
  - 变量值：**.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;**         //记得前面有个"."


  - 变量名：**Path**
  - 变量值：**%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;**

- 这是 Java 的环境配置，配置完成后，你可以启动 Eclipse 来编写代码，它会自动完成java环境的配置。

  > **注意：**如果使用1.5以上版本的JDK，不用设置CLASSPATH环境变量，也可以正常编译和运行Java程序。

  ​

Tomcat解压后的目录

注意目录名不能有中文和空格。目录介绍如下：

- bin：二进制执行文件。里面最常用的文件是**startup.bat**，如果是 Linux 或 Mac 系统启动文件为 **startup.sh**。
- conf:配置目录。里面最核心的文件是**server.xml**。可以在里面改端口号等。默认端口号是8080，也就是说，此端口号不能被其他应用程序占用。
- lib：库文件。tomcat运行时需要的jar包所在的目录
- logs：日志
- temp：临时产生的文件，即缓存
- webapps：web的应用程序。**web应用放置到此目录下浏览器可以直接访问**
- work：编译以后的class文件。

> XML 指可扩展标记语言（e**X**tensible **M**arkup **L**anguage）。XML 被设计用来传输和存储数据。XML 很重要，也很容易学习。

XML 和 HTML 为不同的目的而设计：

- XML 被设计用来传输和存储数据，其焦点是数据的内容。
- HTML 被设计用来显示数据，其焦点是数据的外观

XML 不会做任何事情

也许这有点难以理解，但是 XML 不会做任何事情。XML 被设计用来结构化、存储以及传输信息。

下面实例是 Jani 写给 Tove 的便签，存储为 XML：

```
<?xml version="1.0" encoding="UTF-8"?>			//第一行是 XML 声明。它定义 XML 的版本（1.0）和所使用的编码（UTF-8 : 万国码, 可显示各种语言）。
<note>										//描述文档的根元素（像在说："本文档是一个便签"）：
<to>Tove</to>							//描述根的 4 个子元素（to, from, heading 以及 body）
<from>Jani</from>
<heading>Reminder</heading>
<body>Don't forget me this weekend!</body>
</note>
XML 文档必须包含根元素。该元素是所有其他元素的父元素。
XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。
所有的元素都可以有子元素：

<bookstore>
    <book category="COOKING">
        <title lang="en">Everyday Italian</title>
        <author>Giada De Laurentiis</author>
        <year>2005</year>
        <price>30.00</price>
    </book>
    <book category="CHILDREN">
        <title lang="en">Harry Potter</title>
        <author>J K. Rowling</author>
        <year>2005</year>
        <price>29.99</price>
    </book>
        <book category="WEB">
        <title lang="en">Learning XML</title>
        <author>Erik T. Ray</author>
        <year>2003</year>
        <price>39.95</price>
    </book>
</bookstore>
所有的 XML 元素都必须有一个关闭标签
XML 标签对大小写敏感
XML 必须正确嵌套
XML 属性值必须加引号
在 XML 中编写注释的语法与 HTML 的语法很相似。<!-- This is a comment -->
在 XML 中，一些字符拥有特殊的意义。用实体引用来代替 "<" 字符：<message>if salary &lt; 1000 then</message>
在 Windows 应用程序中，换行通常以一对字符来存储：回车符（CR）和换行符（LF）。
在 Unix 和 Mac OSX 中，使用 LF 来存储新行。
在旧的 Mac 系统中，使用 CR 来存储新行。
XML 以 LF 存储换行。
```

上面的这条便签具有自我描述性。它包含了发送者和接受者的信息，同时拥有标题以及消息主体。

但是，这个 XML 文档仍然没有做任何事情。它仅仅是包装在 XML 标签中的纯粹的信息。我们需要编写软件或者程序，才能传送、接收和显示出这个文档。

## **JVM Java Virtual Machine（Java虚拟机）**

JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。

Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。

## Tomcat

Apache软件基金会下的一个项目——Apache HTTP Server Project；

Nginx同样也是一款开源的HTTP服务器软件（当然它也可以作为邮件代理服务器、通用的TCP代理服务器）。

**HTTP服务器本质上也是一种应用程序——它通常运行在服务器之上，绑定服务器的IP地址并监听某一个tcp端口来接收并处理HTTP请求，这样客户端（一般来说是IE, Firefox，Chrome这样的浏览器）就能够通过HTTP协议来获取服务器上的网页（HTML格式）、文档（PDF格式）、音频（MP4格式）、视频（MOV格式）等等资源。**下图描述的就是这一过程：

![](.\imagenote\http服务器.png)

不仅仅是Apache HTTP Server和Nginx，绝大多数编程语言所包含的类库中也都实现了简单的HTTP服务器方便开发者使用：

HttpServer (Java HTTP Server )
Python SimpleHTTPServer

使用这些类库能够非常容易的运行一个HTTP服务器，它们都能够通过绑定IP地址并监听tcp端口来提供HTTP服务。

Apache Tomcat则是Apache基金会下的另外一个项目，与Apache HTTP Server相比，Tomcat能够动态的生成资源并返回到客户端。Apache HTTP Server和Nginx都能够将某一个文本文件的内容通过HTTP协议返回到客户端，但是这个文本文件的内容是固定的——也就是说无论何时、任何人访问它得到的内容都是完全相同的，这样的资源我们称之为静态资源。动态资源则与之相反，在不同的时间、不同的客户端访问得到的内容是不同的，例如：

- 包含显示当前时间的页面
- 显示当前IP地址的页面

Apache HTTP Server和Nginx本身不支持生成动态页面，但它们可以通过其他模块来支持（例如通过Shell、PHP、Python脚本程序来动态生成内容）。
如果想要使用Java程序来动态生成资源内容，使用这一类HTTP服务器很难做到。Java Servlet技术以及衍生的Java Server Pages技术可以让Java程序也具有处理HTTP请求并且返回内容（由程序动态控制）的能力，Tomcat正是支持运行Servlet/JSP应用程序的容器（Container）:

![](.\imagenote\tomcat.png)





**Tomcat运行在JVM之上，它和HTTP服务器一样，绑定IP地址并监听TCP端口**，同时还包含以下指责：

- 管理Servlet程序的生命周期
- 将URL映射到指定的Servlet进行处理

与Servlet程序合作处理HTTP请求——根据HTTP请求生成HttpServletResponse对象并传递给Servlet进行处理，将Servlet中的HttpServletResponse对象生成的内容返回给浏览器

虽然Tomcat也可以认为是HTTP服务器，但通常它仍然会和Nginx配合在一起使用：
- 动静态资源分离——运用Nginx的反向代理功能分发请求：所有动态资源的请求交给Tomcat，而静态资源的请求（例如图片、视频、CSS、JavaScript文件等）则直接由Nginx返回到浏览器，这样能大大减轻Tomcat的压力。
- 负载均衡，当业务压力增大时，可能一个Tomcat的实例不足以处理，那么这时可以启动多个Tomcat实例进行水平扩展，而Nginx的负载均衡功能可以把请求通过算法分发到各个不同的实例进行处理




JSP 与 PHP、ASP、ASP.NET 等语言类似，运行在服务端的语言。

JSP（全称Java Server Pages）是由 Sun Microsystems 公司倡导和许多公司参与共同创建的一种使软件开发者可以响应客户端请求，而动态生成 HTML、XML 或其他格式文档的Web网页的技术标准。

JSP 技术是以 Java 语言作为脚本语言的，JSP 网页为整个服务器端的 Java 库单元提供了一个接口来服务于HTTP的应用程序。

JSP文件后缀名为 *.jsp 。

JSP开发的WEB应用可以跨平台使用，既可以运行在 Linux 上也能运行在 Windows 上。

JSP全称Java Server Pages，是一种动态网页开发技术。它使用**JSP标签**在HTML网页中插入Java代码。标签通常**以<%开头以%>结束**。



总的来说，JSP网页就是用另一种方式来编写servlet而不用成为Java编程高手。除了解释阶段外，JSP网页几乎可以被当成一个普通的servlet来对待。

echarts
grafana

echarts 
grafana

Angular
Bootstrap



# 20170630

Job任务的3种实现：java.util.Timer, spring Quartz,spring @scheduled

《ODPS权威指南 阿里大数据平台应用开发实践  》	ODPS（Open Data Processing Service）是阿里巴巴自主研发的海量数据处理和分析的服务平台，主要应用于数据分析、海量数据统计、数据挖掘、机器学习和商业智能等领域。目前，ODPS不仅在阿里内部得到广泛应用，享有很好的口碑，正逐步走向第三方开放市场。

全书共13章，主要内容包括：ODPS入门、整体架构、数据通道、MapReduce编程、SQL查询分析、安全，以及基于真实数据的各种场景分析实战。

第1章ODPS概述，这一章简单介绍了ODPS，以及一些基本概念、应用开发模式和典型场景。在后面的章节中，我们将说明如何通过ODPS实现一些典型大数据处理场景：收集数据、处理海量数据、迁移数据、使用机器学习算法生成模型等。本节为大家介绍任务（Task）、作业（Job）和作业实例（Instance）。

任务（Task）：单个SQL Query、命令和MapReduce程序统称为一个任务（Task）。

作业（Job）：一个作业可以包含一个或多个Task，以及表示其执行次序关系的工作流（Workflow）。工作流是个DAG图（有向无环图），描述了Job中各个Task之间的依赖关系和运行约束。每个作业对应一个DAG图，其每个Task对应DAG图的一个节点。实质上，作业是一个静态概念，一个作业对象即一个XML格式的文本文件。

作业实例（Instance）：当作业被提交到系统开始执行时，该作业就拥有一个作业实例（Instance）。和Job相反，Instance是个动态概念，每个Instance只能运行一次。一个Job多次运行就对应多个不同的Instance。Instance保存了Job在执行时的快照（snapshot）、返回状态等信息。

## Job

1定时器的作用 
在实际的开发中，如果项目中需要**定时执行或者需要重复执行一定的工作**，定时器显现的尤为重要。 

当然如果我们不了解定时器就会用线程去实现。

自己实现定时器的工作很复杂，如果实现不好占用内存过多，系统就此Over，所以处理定时执行或者重复执行的任务，定时器是很好的选择 

2.java中常见的定时器 
1）借助Java.util.Timer来实现 
2）OpenSymphony社区提供的Quartz来实现 

3.介绍Timer 
利用Timer开发定时任务是主要分为两个步骤： 
1）创建定时任务类。
示例代码： 
```
package org.lzstone.action 
import java.util.TimeTask 
public class LzstoneTimeTask extends TimeTask{ 
​       public void run(){ 
​              //执行的定时器任务 
​       } 
} 
```
2）运行定时任务，运行定时任务分为两种方式： 
- 2.1）程序直接启动 
  示例代码： 
```
package org.lzstone.action 
public class LzstoneMain{ 
       ....... 
       public void run(){ 
        //执行定时器的任务 
        //创建实例 
        Timer timer = new Timer(); 
        参数： 
        new LzstoneTimeTask()- 所要安排的任务。 
        0- 执行任务前的延迟时间，单位是毫秒。 
        1*1000- 执行各后续任务之间的时间间隔，单位是毫秒。 
        timer.schedule(new LzstoneTimeTask(),0,1*1000); 
       } 
} 
```
- 2.2）web监听方式 
  示例代码： 

```
package org.lzstone.action 
public class LzstoneMain implements ServletContextListener{ 
       private Timer timer = null; 
       //初始化监听器，创建实例，执行任务 
       public void contextInitialized(ServletContextEvent event){ 
               timer = new Timer(); 
               timer.schedule(new LzstoneTimeTask(),0,1*1000); 
       } 
       //销毁监听器，停止执行任务 
       public void contextDestroyed(ServletContextEvent event){ 
              //注意，在此计时器调用的计时器任务的 run 方法内调用此方法，就可以绝对确保正在执行的任务是此计时器所执行的最后一个任务。 
              timer.cancel(); 
        } 
} 
web.xml配置 
<listener> 
   <listener-class> 
        org.lzstone.action.LzstoneMain 
   </listener-class> 
</listener> 
```
4.介绍Quartz 
Quartz是OpenSymphony开源组织在Job scheduling领域又一个开源项目，可以用来创建简单或者复杂的定时任务，利用Quartz开发定时任务的步骤与Timer类似。

## JAVA事务基本概念

```
什么是事务？ 事务的概念最开始出现在关系型数据库中
A database transaction is a larger unit that frames multiple SQL statements. 
A transaction ensures that the action of the framed statements is atomic with respect to recovery.
事务是确保"同时成功则成功，任何一个失败则失败"的一种机制。一个事务往往包括三种动作行为：开始事务（Begin Transaction），提交事务（Commit）和回滚（Rollback）。从开始事务到提交事务过程中所发生的一切数据库修改要么同时成功（被Commit，固化在数据库中），要么一个失败，大家同时回复原有状态（Rollback，数据库回复到事务开始时的状态）。
简单的理解：它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。

随着IT技术的发展，事务的范畴也变大，又称之为交易，指一个程序或程序段，在一个或多个资源如 数据库 或文件上为完成某些功能的执行过程的集合。
事务基本属性： 
事务的ACID特点分别是指原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）。
- 原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。
- 一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。
- 隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
- 持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。
事务的分类：  
本地事务
本地（Local Transaction）事务指只有一个数据源参与的事务，比如只有数据库或者只有JMS；
分布式事务
分布式事务(Distributed Transaction)指有多个数据源同时参与的事务，比如一项操作需要同时访问数据库和通过JMS发送消息，或者一项操作需要同时访问两个不同数据库。对于分布式事务，Java提供了JTA规范，它的原理与本地事务存在不同。
Java事务的类型有三种： 
JDBC事务、JTA(Java Transaction API)事务、容器事务。
```



## Java

### Java数据结构

- 枚举（Enumeration）
- 位集合（BitSet）
- 向量（Vector）
- 栈（Stack）
- 字典（Dictionary）
- 哈希表（Hashtable）
- 属性（Properties）

以上这些类是传统遗留的，在Java2中引入了一种新的框架-集合框架(Collection)，我们后面再讨论。
早在Java 2中之前，Java就提供了特设类。比如：Dictionary, Vector, Stack, 和Properties这些类用来存储和操作对象组。
虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用Vector类的方式和使用Properties类的方式有着很大不同。

集合框架被设计成要满足以下几个目标。

- 该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。
- 该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。
- 对一个集合的扩展和适应必须是简单的。

为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： LinkedList, HashSet, 和 TreeSet等,除此之外你也可以通过这些接口实现自己的集合。

集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：
- **接口：**是代表集合的抽象数据类型。接口允许集合独立操纵其代表的细节。在面向对象的语言，接口通常形成一个层次。
- **实现（类）：**是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构。
- **算法：**是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。
  除了集合，该框架也定义了几个Map接口和类。Map里存储的是键/值对。尽管Map不是collections，但是它们完全整合在集合中。






## 日志类型

log4j.properties 配置

Log4J的配置文件(Configuration File)就是用来设置记录器的级别、存放器和布局的，它可接key=value格式的设置或xml格式的设置信息。通过配置，可以创建出Log4J的运行环境。

日志文件实际是分散在各个服务器，通过映射



# 20170703



## JAVA基础知识-JAR包介绍

archive ['ɑrkaɪv] 	

- N-COUNT **Archives** are a collection of documents and records that contain historical information. You can also use **archives** to refer to the place where archives are stored. 档案; 档案馆
- V-T If you **archive** material such as documents or data, you store it in an archive. 把…存档

JAR(Java Archive File) Java档案文件

CLASSPATH	.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
JAVA_HOME	C:\Program Files\Java\jdk1.7.0_80
MAVEN_HOME	E:\maven\apache-maven-3.3.9


JAR文件与zip文件的区别就是在JAR文件中默认包含了**一个名为 META-INF/MANIFEST.MF的清单文件**，这个清单文件是在生成JAR包时由系统自动创建的。

只要别人在系统的CLASSPATH环境变量中添加这个JAR文件，则Java虚拟机就可以自动在内存中解压这个JAR包，把这个JAR文件当成一个路径，在这个路径中查找所需要的类或者包层次对应的路径结构。
```
test
	|-a
		|-Test.class
		|-Test.java
	|-b
		|-Test.class
		|-Test.java

test.jar
	|-META-INF
		|-MANIFEST.MF
	|-a
		|-Test.class
		|-Test.javva
	|-b
		|-Test.class
		|-Test.java
```

JAR文件的好处
- 安全。能够对JAR文件进行数字签名，只让能够识别数字签名的用户使用里面的东西。
- 加快下载速度。 在网上使用Applet时，如果存在多个文件而不打包，为了能够把每个文件都下载到客户端，需要为每个文件单独建立一次HTTP连接，这是非常耗时的工作。将这些文件压缩成一个JAR包，只要建立一次HTTP连接就能够一次下载所有的文件。
- 压缩
- 包封装
- 可移植性。




## JAVA基础知识-注释 Annonation

　Annontation是Java5开始引入的新特征。中文名称一般叫注解。它提供了一种安全的类似注释的机制，用来**将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联**。
　更通俗的意思是**为程序的元素（类、方法、成员变量）加上更直观更明了的说明**，这些说明信息是与程序的业务逻辑无关，并且是供指定的工具或框架使用的。
  Annontation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。

应用场合：
annotation一般作为一种辅助途径，应用在软件框架或工具中，在这些工具类中**根据不同的 annontation注解信息采取不同的处理过程或改变相应程序元素（类、方法及成员变量等）的行为**。
例如：**Junit、Struts、Spring等**流行工具框架中均广泛使用了annontion。使代码的灵活性大提高。

从java5版本开始，自带了三种标准annontation类型,

（1）、Override

java.lang.Override 是一个marker annotation类型，它被用作标注方法。它说明了被标注的方法重载了父类的方法，起到了断言的作用。如果我们使用了这种annotation在一个没有覆盖父类方法的方法时，java**编译器将以一个编译错误来警示**。

这个annotaton常常在我们试图覆盖父类方法而确又写错了方法名时加一个保障性的校验过程。

（2）、Deprecated

　java.lang.Deprecated也是一种marker annotation。当一个类型或者类型成员使用@Deprecated修饰的话，编译器将不鼓励使用这个被标注的程序元素。所以使用这种修饰具有一定的 “延续性”：如果我们在代码中通过继承或者覆盖的方式使用了这个过时的类型或者成员，虽然继承或者覆盖后的类型或者成员并不是被声明为 @Deprecated，但**编译器仍然要报警**。
　注意：@Deprecated这个annotation类型和javadoc中的 @deprecated这个tag是有区别的：前者是java编译器识别的，而后者是被javadoc工具所识别用来生成文档（包含程序成员为什么已经过时、它应当如何被禁止或者替代的描述）。

（3）、SuppressWarnings
　　java.lang.SuppressWarnings此注解能告诉Java**编译器关闭对类、方法及成员变量的警告**。
　　有时编译时会提出一些警告，对于这些警告有的隐藏着Bug，有的是无法避免的，对于某些不想看到的警告信息，可以通过这个注解来屏蔽。
　　SuppressWarning不是一个marker annotation。它有一个类型为String[]的成员，这个成员的值为被禁止的警告名。对于javac编译器来讲，被-Xlint选项有效的警告名也同样对@SuppressWarings有效，同时编译器忽略掉无法识别的警告名。
　　
　　annotation语法允许在annotation名后跟括号，括号中是使用逗号分割的name=value对用于为annotation的成员赋值：
　　代码：
`@SuppressWarnings(value={&amp;quot;unchecked&amp;quot;,&amp;quot;fallthrough&amp;quot;})
public void lintTrap() { /* sloppy method body omitted */ }`
在这个例子中SuppressWarnings annotation类型只定义了一个单一的成员，所以只有一个简单的value={...}作为name=value对。又由于成员值是一个数组，故使用大括号来声明数组值。
注意：我们可以在下面的情况中缩写annotation：当annotation只有单一成员，并成员命名为"value="。这时可以省去"value="。比如将上面的SuppressWarnings annotation进行缩写：
代码：
`@SuppressWarnings({"unchecked","fallthrough"})`
如果SuppressWarnings所声明的被禁止警告个数为一个时，可以省去大括号：
`@SuppressWarnings("unchecked")`



JDK除了在java.lang下提供了4个基本的Annotation之外，还在java.lang.annotation包下提供了4个meta Annotation，这四个meta annotation都用于修饰其他的Annotation定义。

java.lang.annotation.Retention; 

```
import java.lang.annotation.Documented;用于指定被修饰的Annotation类将被javadoc工具提取成文档。
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention; 只能用于修饰一个Annotation定义，用于指定被修饰的Annotation可以保留多长时间，
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;只能用于修饰一个Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序单元
import java.lang.annotation.Inherited;指定被它修饰的Annotation将具有继承性。
```



springframewotk的注释

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

POJO（Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称。

POJO 和JavaBean是我们常见的两个关键字，一般容易混淆，POJO全称是Plain Ordinary Java Object / Pure Old Java Object，中文可以翻译成：普通Java类，具有一部分getter/setter方法的那种类就可以称作POJO，但是JavaBean则比 POJO复杂很多， Java Bean 是可复用的组件，对 Java Bean 并没有严格的规范，理论上讲，任何一个 Java 类都可以是一个 Bean 。但通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat) 的，所以 Java Bean 应具有一个无参的构造器，另外，通常 Java Bean 还要实现 Serializable 接口用于实现 Bean 的持久性。 Java Bean 是不能被跨进程访问的。JavaBean是一种组件技术，就好像你做了一个扳子，而这个扳子会在很多地方被拿去用，这个扳子也提供多种功能(你可以拿这个扳子扳、锤、撬等等)，而这个扳子就是一个组件。一般在web应用程序中建立一个数据库的映射对象时，我们只能称它为POJO。POJO(Plain Old Java Object)这个名字用来强调它是一个普通java对象，而不是一个特殊的对象，其主要用来指代那些没有遵从特定的Java对象模型、约定或框架（如EJB）的Java对象。理想地讲，一个POJO是一个不受任何限制的Java对象（除了Java语言规范）



## Maven

其作用是用来管理jar 包的。

1. 在开发中，为了保证编译通过，我们会到处去寻找jar包，当编译通过了，运行的时候，却发现"ClassNotFoundException"，我们想到的是，难道还差jar包？
2. 每个Java项目的目录结构都没有一个统一的标准，配置文件到处都是，单元测试代码到底应该放在那里也没有一个权威的规范。
3. 因此，我们就要用到Maven（使用Ant也可以，不过编写Ant的xml脚本比较麻烦）----一个**项目管理工具**。
4. Maven主要做了两件事：

- 统一开发规范与工具
- 统一管理jar包

对比一下，首先建立一个普通的Java工程，是这样的：
这个我们都很熟悉，src下建包写代码，那么配置文件放在哪里？单元测试代码放在哪里？没有一个统一标准，更多时候都是开发者的自由发挥，每个人有自己的风格，这并不十分适合团队协作。接下来，看一下使用maven构建一个普通Java项目之后的目录结构：
target: 默认的build目录
src:保存所有的项目文件（静态文件、java文件等）
src/main/java: 所有的java代码
src/main/webapp: web相关的资源文件（js、CSS等）
src/main/resources: 所有不需要compile的文件（配置文件）
src/test/java: 所有java测试代码
src/test/resources: 所有不需要compile的文件（配置文件）
看到使用Maven构建的普通Java项目，对源代码、单元测试代码、资源乃至后续需要的文件都有专门的目录规划。
上面的最后有一个pom.xml，这是Maven的核心配置文件，pom称为Project Object Model（项目对象模型），它用于描述整个Maven项目，所以也称为Maven描述文件。
打开pom.xml，最基础的是这样的：
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">     
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.xrq.withmaven</groupId>
  <artifactId>withmaven</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <build/>
</project>
1、modelVersion
　　指定了当前Maven模型的版本号，对于Maven2和Maven3来说，它只能是4.0.0
2、groupId
　　顾名思义，这个应该是公司名或是组织名。一般来说groupId是由三个部分组成，每个部分之间以"."分隔，第一部分是项目用途，比如用于商业的就是"com"，用于非营利性组织的就　　是"org"；第二部分是公司名，比如"tengxun"、"baidu"、"alibaba"；第三部分是你的项目名
3、artifactId
　　可以认为是Maven构建的项目名，比如你的项目中有子项目，就可以使用"项目名-子项目名"的命名方式
4、version
　　版本号，SNAPSHOT意为快照，说明该项目还在开发中，是不稳定的版本。在Maven中很重要的一点是，groupId、artifactId、version三个元素生成了一个Maven项目的基本坐标，这非常重要，我在使用和研究Maven的时候多次感受到了这点。
在上面的这些元素之外，还有一些元素，同样罗列一下：
1、packing
　　项目打包的类型，可以使jar、war、rar、ear、pom，默认是jar
2、dependencies和dependency
　　前者包含后者。前面说了，Maven的一个重要作用就是统一管理jar包，为了一个项目可以build或运行，项目中不可避免的，会依赖很多其他的jar包，在Maven中，这些依赖就被称为dependency。
　　说到这里，就有一个本地仓库和远程仓库的概念了。官方下载的本地仓库的配置在"%MAVEN_HOME%\conf\settings.xml"里面，找一下"localRepository"就可以了；MyEclipse默认的本地仓库的地址在"{user.home}/.m2/repository"路径下，同样找一下"localRepository"就可以找到MyEclipse默认的本地仓库了。
　　本地仓库和远程仓库是这样的，Maven工程首先会从本地仓库中获取jar包，当无法获取指定jar包时，本地仓库会从远程仓库（中央仓库）中下载jar包，并放入本地仓库以备将来使用。
3、properties
　　properties是用来定义一些配置属性的，例如project.build.sourceEncoding（项目构建源码编码方式），可以设置为UTF-8，防止中文乱码，也可定义相关构建版本号，便于日后统一升级。
4、build
　　build表示与构建相关的配置，比如build下有finalName，表示的就是最终构建之后的名称。
接着解释一下Maven的目录结构：
main目录下是项目的主要代码，test目录下存放测试相关的代码
编译输出后的代码会放在target目录下
src/main/java下存放Java代码，src/main/resources下存放配置文件
这里没有webapp，Web项目会有webapp目录，webapp下存放Web应用相关代码
pom.xml是Maven项目的配置文件
三.Maven环境配置
常用的开发工具Idea、MyEclipse里面都已经集成了Maven了，不过最好是从官网下一个配置到自己电脑里，开发工具里的可能有少许的Bug。




## JAVA基础知识-Applet


