[TOC]

# 富聪笔记

# 20170401

pandas dataframe

dataframe.apply()

lambda

secfunc=lambda x: math.floor

dataframe.apply(secfunc)

这样比写循环结构快多了

从mongoDB拉出的时间数据 daatetime 可以直接加减，后 转换为秒，total_sec()







# 20170505

## 桌面远程链接

[win7远程桌面连接设置](https://jingyan.baidu.com/article/49711c612a025cfa451b7c54.html)

win7远程桌面连接[地址][10]

[10]: https://jingyan.baidu.com/article/49711c612a025cfa451b7c54.html	"win7远程桌面连接设置"
![mstsc远程桌面连接](.\imagenote\mstsc远程桌面连接.png)

![远程桌面连接设置](.\imagenote\远程桌面连接.png)





1. 首先要设置好被远程电脑的用户名密码，打开**“控制面板”**

2. 点击“用户账户和家庭安全”

3. 点击“更改密码”

4. 点击“为您的账户创建密码”

5. 输入你要的密码，点击“创建密码”就可以了。

6. 接着打开计算机属性，选择**“远程设置”**

7. 把“允许远程协助连接这台计算机”打钩，下面的“允许运行任意版本远程桌面的计算机连接（较不安全）”选中，其他的不用管它。至此，被远程的计算机已经设置好了，就坐等别人远程就可以了。

8. 先查看被远程的计算机的IP地址（我这里演示的是局域网，注意事项里再说下要注意什么的），我的地址就是172.168.2.101

9. 打开操作电脑的远程程序(`win+R: mstsc`)，填写被远程的IP地址，然后点击“连接”

   ![网络连接详情](.\imagenote\网络连接详情.png)

## markdown的11种基本语法

1. 标题设置（让字体变大，和word的标题意思一样）

2. 块注释（blockquote）:通过在文字开头添加“>”表示块注释。

3. 斜体:将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来

4. 粗体.将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来

5. 无序列表。

   在文字开头添加(`*`, `+`, and `-`)实现无序列表。但是要注意在(`*`, `+`, and `-`)和文字之间需要添加空格。

   （建议：一个文档中只是用一种无序列表的表示方式）

6. 有序列表

   使用数字后面跟上句号。（还要有空格）

7. 链接（Links）。

   Markdown中有两种方式，实现链接，分别为内联方式和引用方式。
   `内联方式：This is an [example link](http://example.com/).`

   `引用方式：I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. `

   ` [1]: http://google.com/        "Google" ` 

   `[2]: http://search.yahoo.com/  "Yahoo Search" `

   `[3]: http://search.msn.com/    "MSN Search"`

8. 图片（Images）。

   图片的处理方式和链接的处理方式，非常的类似。
   `内联方式：``![alt text](/path/to/img.jpg "Title")`

   `引用方式：``![alt text][id] [id]: /path/to/img.jpg "Title"`

9. 代码（HTML中所谓的Code）。

   实现方式有两种：
   第一种：简单文字出现一个代码框。使用`<blockquote>`。（`不是单引号而是左上角的ESC下面~中的`）
   第二种：大片文字需要实现代码框。使用Tab和四个空格。

10. 脚注（footnote）。

  实现方式如下：

  hello[^hello]

[^hello]: hi

11. 下划线。在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题）



## java开发环境搭建完成

spring tool suite



tomcat v7.0 server at localhost

127.0.0.1:8080/bam





![富聪金融业务分析监控系统](.\imagenote\富聪金融业务分析监控系统.PNG)



![富聪金融业务分析监控系统2](.\imagenote\富聪金融业务分析监控系统2.PNG)

### ETL（ Extract-Transform-Load）

#### ETL是什么

ETL是Extract Transform Load三个英文单词的缩写 中文意思就是抽取、转换、加载。说到ETL就必须提到数据仓库。

#### 背景知识

信息是现代企业的重要资源，是企业运用科学管理、决策分析的基础。目前，大多数企业花费大量的资金和时间来构建**联机事务处理OLTP的业务系统**和办公自动化系统（例如电信行业的各种运营支撑系统、购物网站系统），用来记录事务处理的各种相关数据。据统计，数据量每2～3年时间就会成倍增长，这些数据蕴含着巨大的商业价值，而企业所关注的通常只占在总数据量的2%～4%左右。因此，企业仍然没有最大化地利用已存在的数据资源，以致于浪费了更多的时间和资金，也失去制定关键商业决策的最佳契机。

在这个背景下，能够给企业所有级别的决策制定过程提供支持的所有类型数据的战略集合应运而生，他就是**数据仓库**。数据仓库的英文简写是**Data Warehouse**。**数据仓库**就是把**OLTP系统**产生的数据 整合到一起 发掘其中的商业价值和提供决策支持用。**举个电信行业的例子** 电信有系统每天会有客户投诉的信息、宽带群体性障碍、客户号码的停机恢复时间记录等等。这些数据都在各自的生产环境系统里面。**他们每个月会把这些数据整合到一起处理加工到数据仓库里面形成报表** 其中有一个功能是可以对哪些用户有离网销号的倾向做出大概的判断。这就是数据仓库的价值所在。

> #### OLTP(On_line Transaction Processing联机事务处理)，OLAP(On_line Analytical Processing联机分析处理)
>
> OLTP：On_line Transaction Processing **联机事务处理** 
> OLAP：On_line Analytical Processing  **联机分析处理**
> OLTP 顾名思义，以业务处理为主。
>
> OLAP则是专门为支持复杂的分析操作而设计的，侧重于对决策人员和高层管理人员的决策支持，可以应分析人员的要求快速、灵活地进行[大数据](http://lib.csdn.net/base/hadoop)量的复杂查询处理，并以一直直观的形式把查询结果提供。
>
> OLTP与OLAP 的主要区别有以下几点：
>
> 1. 所面向的用户和系统：OLTP是面向**客户**的，由职员或客户进行事务处理或者查询处理。OLAp是向向**市场**的，由经理、主管和分析人员进行数据分析和决策的。
>
> 2. 数据内容：OLTP系统管理当前数据，这些数据通常很琐碎，难以用于决策。OLAP系统管理大量历史数据，提供汇总和聚集机制，并在不同的粒度级别上存储和管理信息，这些特点使得数据适合于决策分析。
>
> 3. [数据库](http://lib.csdn.net/base/mysql)设计：通常，OLTP采用ER模型和面向应用的数据库设计，而OLAP系统通常采用星型模式或雪花模式和面向主题的数据库设计。
>
> 4. 视图：OLTP系统主要关注一个企业或部门的当前数据，而不涉及历史数据或不同组织的数据。与之相反，OLAP系统常常跨越一个企业的数据库模式的多个版本，OLAP系统也处理来自不同组织的信息，由多个数据源集成的信息。
>
> 5. 访问模式：OLTP系统的访问主要由短的原子事务组成，这种系统需要并发控制和恢复机制。而OLAP系统的访问大部份是只读操作，其中大部份是复杂查询。
>
> 6. 度量：OLTP专注于日常时实操作，所以以事务吞吐量为度量，OLAP以查询吞吐量和响应时间来度量。
>
>    | --------------------- | ------------------------------------ | --------------------------------------------------- |
>    | --------------------- | :----------------------------------: | :--------------------------------------: |
>    |                       |                 OLTP                 |                   OLAP                   |
>    | 用户                    |             操作人员,低层管理人员              |               决策人员,高级管理人员                |
>    | 功能                    |                日常操作处理                |                   分析决策                   |
>    | DB 设计                 |                 面向应用                 |                   面向主题                   |
>    | 数据                    |         当前的, 最新的细节的, 二维的分立的          |          历史的, 聚集的, 多维的集成的, 统一的           |
>    | 存取                    |               读/写数十条记录               |                 读上百万条记录                  |
>    | 工作单位                  |                简单的事务                 |                  复杂的查询                   |
>    | 用户数                   |                 上千个                  |                   上百个                    |
>    | DB 大小                 |               100MB-GB               |                 100GB-TB                 |
>
>    | --------------------------------- | ----------------------------------- |
>    | :-------------------------------: | :---------------------------------: |
>    |              OLTP数据               |               OLAP数据                |
>    |               原始数据                |                导出数据                 |
>    |               细节性数据               |              综合性和提炼性数据              |
>    |               当前值数据               |                历史数据                 |
>    |                可更新                |             不可更新，但周期性刷新             |
>    |             一次处理的数据量小             |              一次处理的数据量大              |
>    |             面向应用，事务驱动             |              面向分析，分析驱动              |
>    |           面向操作人员，支持日常操作           |            面向决策人员，支持管理需要            |
>
>    ​

*那么怎么把数据弄到数据仓库里去呢，其中用道德一个技术就是ETL。*

#### 给下ETL的详细解释定义

ETL(Extract-Transform-Load的缩写，即数据抽取、转换、装载的过程)作为DW的核心和灵魂，能够按照统一的规则集成并提高数据的价值，是负责完成**数据从数据源向目标数据仓库转化的过程**，是实施数据仓库的重要步骤。如果说**数据仓库的模型设计是一座大厦的设计蓝图，数据是砖瓦的话，那么ETL就是建设大厦的过程。**在整个项目中最难部分是用户需求分析和模型设计，而ETL规则设计和实施则是工作量最大的，约占整个项目的60%～80%，这是国内外从众多实践中得到的普遍共识。
ETL是数据抽取（Extract）、清洗（Cleaning）、转换（Transform）、装载（Load）的过程。是构建数据仓库的重要一环，用户从数据源抽取出所需的数据，经过数据清洗,最终按照预先定义好的数据仓库模型，将数据加载到数据仓库中去。
于是，企业如何通过各种技术手段，并把数据转换为信息、知识，已经成了提高其核心竞争力的主要瓶颈。而ETL则是主要的一个技术手段。

做数据仓库系统，ETL是关键的一环。说大了，ETL是数据整合解决方案，说小了，就是倒数据的工具。

现在来说说**ETL技术用到的工具，常用的有Informatica、Datastage、Beeload、Kettle等**。目前只用过kettle，所以这里只对kettle做描述。

kettle是一款国外开源的ETL工具，纯[Java](http://lib.csdn.net/base/javase)编写，可以在Window、[Linux](http://lib.csdn.net/base/linux)、Unix上运行，kettle 3版本需要安装 3以上都是绿色版无需安装。

*提醒的是kettle运行 需要机器有JRE环境*

Kettle这个ETL工具集，它允许你管理来自不同[数据库](http://lib.csdn.net/base/mysql)的数据，通过提供一个图形化的用户环境来描述你想做什么。
Kettle中有两种脚本文件，transformation和job，transformation完成针对数据的基础转换，job则完成整个工作流的控制。

**商务智能（BI）**

不同的瞎子对大象的认识不同，因为他们只认识了自己摸到的地方。而企业如果要避免重犯这样的错误，那就离不开商务[智能](http://lib.csdn.net/base/aiplanning)（BI）。专家认为，BI对于企业的重要性就像聪明才智对于个人的重要性。欧美企业的经验也证明，企业避免无知和一知半解危险的有效手段就是商务智能。商务智能旨在充分利用企业在日常经营过程中收集的大量数据和资料，并将它们转化为信息和知识来免除各种无知状态和瞎猜行为。

确切地讲，BI并不是一项新技术，它将数据仓库(DW)、联机分析处理(OLAP)、数据挖掘(DM)等技术与客户关系管理（CRM）等结合起来应用于商业活动实际过程当中，实现了技术服务于决策的目的；Mark Hammond从管理的角度看待BI，认为BI是从“根本上帮助你把公司的运营数据转化成为高价值的可以获取的信息（或者知识），并且在恰当的时间通过恰当的手段把恰当的信息传递给恰当的人”。 

**ETL** 
ETL即数据抽取（Extract）、转换（Transform）、装载（Load）的过程。它是构建数据仓库的重要环节。数据仓库是面向主题的、集成的、稳定的且随时间不断变化的数据集合，用以支持经营管理中的决策制定过程。数据仓库系统中有可能存在着大量的噪声数据,引起的主要原因有：滥用缩写词、惯用语、数据输入错误、重复记录、丢失值、拼写变化等。即便是一个设计和规划良好的[数据库](http://lib.csdn.net/base/mysql)系统，如果其中存在着大量的噪声数据，那么这个系统也是没有任何意义的，因为“垃圾进，垃圾出”（garbage in, garbage out），系统根本就不可能为决策分析系统提供任何支持。为了清除噪声数据，必须在数据库系统中进行数据清洗。目前有不少数据清洗研究和ETL研究，但是如何在ETL过程中进行有效的数据清洗并使这个过程可视化，此方面研究不多。本文主要从两个方面阐述ETL和数据清洗的实现过程：ETL的处理方式[19]和数据清洗的实现方法。 

ETL，是英文Extract-Transform-Load的缩写，即填充、更新数据仓库的数据抽取、转换、装载的过程。这是实现[商业智能](http://www.chinabi.net/)之前的数据采集步骤。这一步骤完成之后，对库中数据的数据挖掘、分析处理才可以进行。

对于ETL而言，“是什么”是很容易理解的，也就是将分散的、不易利用的数据进行整理，变成规则清晰的、易于利用的、（可能同时还是）集中的数据。在ETL过程之外，就可以基于报表分析系统、多维分析系统和数据挖掘系统等，进行进一步的数据分析利用。

这一过程可以通过Hard Codding，即编写程序实现，也可以通过各种ETL工具实现。

当今的数据处理大致可以分成两大类：联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Processing）。OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。 
OLAP是使分析人员、管理人员或执行人员能够从多角度对信息进行快速、一致、交互地存取,从而获得对数据的更深入了解的一类软件技术。OLAP的目标是满足决策支持或者满足在多维环境下特定的查询和报表需求,它的技术核心是"维"这个概念。

@  BI 就是[智能](http://lib.csdn.net/base/aiplanning)决策分析工具。Power-BI 就是一个典型的例子。
@  TL分别是Extract（数据抽取）、 Transform（转换）、 Loading（装载）三个英文单词的首字母缩写。
@  线上分析处理（On-Line Analytical Processing,简称OLAP），是一套以多维度方式分析资料，而能弹性地提供积存(Roll-up)、下钻(Drill-down)、和枢纽分析(pivot)等操作，呈现整合性决策资讯的方法，多用于决策支持系统、商务智能或数据仓库。其主要的功能，在于方便大规模数据分析及统计计算，对决策提供参考和支持。与之相区别的是线上交易处理(OLTP)。

OLAP技术联机分析处理(OLAP)的概念最早是由关系数据库之父E.F.Codd于1993年提出的。当时，Codd认为联机事务处理(OLTP)已不能满足终端用户对数据库查询分析的需要，SQL对[大数据](http://lib.csdn.net/base/hadoop)库进行的简单查询也不能满足用户分析的需求。用户的决策分析需要对关系数据库进行大量计算才能得到结果，而查询的结果并不能满足决策者提出的需求。因此Codd提出了多维数据库和多维分析的概念，即OLAP。

#### 商业智能BI体系结构



![商业智能BI体系结构](.\imagenote\商业智能BI体系结构.jpg)

在此大概用口水话简单叙述一下他们几个概念：

（1）**DB/Database/数据库**——这里一般指的就是OLTP数据库，在线事物数据库，用来支持生产的，比如超市的买卖系统。DB保留的是数据信息的最新状态，只有一个状态！比如，每天早上起床洗脸照镜子，看到的就是当时的状态，至于之前的每天的状态，不会出现的你的眼前，这个眼前就是db。

（2）**DW/Data Warehouse/数据仓库**——这里保存的是DB中的不同时间点的状态，比如，每天早上洗完照镜子时，都拍一张照片，天天这样，这些照片放入到一个相册中，之后就可以查看每一天的状态了，这个相册就是数据仓库，他保存的是数据在不同时间点的状态，对同一个数据信息，保留不同时间点的状态，就便于我们做统计分析了。

（3）**ETL/Extraction-Transformation-Loading**——用于完成DB到DW的数据转存，它将DB中的某一个时间点的状态，“抽取”出来，根据DW的存储模型要求，“转换”一下数据格式，然后再“加载”到DW的一个过程，这里需要强调的是，DB的模型是ER模型，遵从范式化设计原则，而DW的数据模型是雪花型结构或者星型结构，用的是面向主题，面向问题的设计思路，所以DB和DW的模型结构不同，需要进行转换。 
（4）**OLAP——在线分析系统**，简单说就是报表系统，销售报表，统计报表，等等，这个大家都熟悉，当然，OLAP的统计要更复杂更丰富一些，比如切面，钻取等等。 
（5）**DM/Data Mining/数据挖掘**——这个挖掘，不是简单的统计了，他是根据概率论的或者其他的统计学原理，将DW中的大数据量进行分析，找出我们不能直观发现的规律，比如，如果我们每天早上照相，量身材的时候，还记录下头一天吃的东西，黄瓜，猪腿，烤鸭，以及心情，如果记录上10年，形成了3650天的相貌和饮食心情的数据，我们每个人都记录，有20万人记录了，那么，我们也许通过这些记录，可以分析出，身材相貌和饮食的客观规律；再说一个典型的实例，就是英国的超市，在积累了大量数据之后，对数据分析挖掘之后，得到了一个规律：将小孩的尿布和啤酒放在一起，销量会更好——业务专家在得到该结论之后，仔细分析，知道了原因，因为英国男人喜欢看足球的多，老婆把小孩介绍男人看管，小孩尿尿需要尿布，而男人看足球喜欢喝酒，所以两样商品有密切的关系，放在一起销售会更好！

（6）**BI/Business Intelligence/商业智能**——领导，决策者，在获取了OLAP的统计信息，和DM得到的科学规律之后，对生产进行适当的调整，比如，命令超市人员将啤酒喝尿布放在一起销售，这就反作用于DB修改存货数据了——这就是整个BI的作用！

信息技术经过近20年的大力发展，很多行业积累了很多珍贵的数据，真正的大数据时代到来了，也逐渐体现出 DB-ETL-DW-OLAP-DM-BI这条线路的重要性，希望大家能懂得这个大数据时代的价值，把握住机遇，有更加美好的未来！

### eclipse 查看原始类出现The jar file rt.jar has no source attachment

作为一名菜鸟，查看[Java](http://lib.csdn.net/base/javase) 源码非常重要。而在eclipse中查看一个类的源码是非常方便的，直接**按住 ctrl** + **鼠标点击的那个类或方法**，**那么这个类或方法的源码就会出现。**不过在此之前，需要先在eclipse中导入源码 src.zip.

这个源码src.zip不需要下载，只要你安装了jdk，那么在jdk安装的目录下就会有src.zip，无需解压，下面看一下怎么把源码导入eclipse中。

1.进入eclipse界面，依次点击 Window -- Preferences -- Java -- Installed JREs

![Eclipse_javasourcecode1](.\imagenote\Eclipse_javasourcecode1.png)

2.选中 D:\java\lib\rt.jar ，然后选择 Source Attachment

![Eclipse_javasourcecode2](.\imagenote\Eclipse_javasourcecode2.png)

3.选择 External location ，点击 External File 浏览安装jdk的目录，找到src.zip，一次点击ok，finish 即可

![](.\imagenote\Eclipse_javasourcecode3.png)



# 20170509

## 查看电脑硬件配置信息

DirectX诊断工具
win+R-->dxdiag
或者 计算机-->管理-->设备管理器

CPU-Z是一款家喻户晓的CPU检测软件，是检测CPU使用程度最高的一款软件，除了使用Intel或AMD自己的检测软件之外，我们平时使
用最多的此类软件就数它了。
CPU-Z is a freeware that gathers information on some of the main devices of your system.

SPD是内存模组上面的一个可擦写的ROM，里面记录了该内存的许多重要信息，诸如内存的芯片及模组厂商、工作频率、工作电压、速
度、容量、电压与行、列地址带宽等参数。SPD信息一般都是在出厂前，由内存模组制造商根据内存芯片的实际性能写入到ROM芯片中
。



## 用ETL组件实现和sql相比哪个效率高

我现在正在做BI相关的东西。如果ETL和SQL来说，肯定是SQL效率高的多。但是双方各有优势，

先说ETL，ETL主要面向的是建立数据仓库来使用的。ETL更偏向数据清洗，多数据源数据整合，获取增量，转换加载到数据仓库所使用的工具。比如我有两个数据源，一个是数据库的表，另外一个是excel数据，而我需要合并这两个数据，通常这种东西在SQL语句中比较难实现。但是ETL却有很多现成的组件和驱动，几个组件就搞定了。还有比如跨服务器，并且服务器之间不能建立连接的数据源，比如我们公司系统分为一期和二期，存放的数据库是不同的，数据结构也不相同，数据库之间也不能建立连接，这种情况下，ETL就显得尤为重要和突出。通过固定的抽取，转换，加载到数据仓库中，即可很容易。

那么SQL呢？SQL事实上只是固定的脚本语言，但是执行效率高，速度快。不过灵活性不高，很难跨服务器整合数据。所以SQL更适合在固定数据库中执行大范围的查询和数据更改，由于脚本语言可以随便编写，所以在固定数据库中能够实现的功能就相当强大，不像ETL中功能只能受组件限制，组件有什么功能，才能实现什么功能。

所以具体我们在什么时候使用ETL和SQL就很明显了，当我们需要多数据源整合建立数据仓库，并进行数据分析的时候，我们使用ETL。如果是固定单一数据库的数据层次处理，我们就使用SQL。当然，ETL也是离不开SQL的。

## elasticsearch

ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于[云计算](http://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97)中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。

## ETL的实现

ETL的实现有多种方法，常用的有三种。一种是借助ETL工具（如Oracle的 OWB、SQLServer2000的DTS、SQLServer2005的SSIS服务、Informatic等）实现，一种是SQL方式实现，另外一种是ETL工具和SQL相结合。前两种方法各有各的优缺点，借助工具可以快速的建立起ETL工程，屏蔽了复杂的编码任务，提高了速度，降低了难度，但是缺少灵活性。SQL的方法优点是灵活，提高ETL运行效率，但是编码复杂，对技术要求比较高。第三种是综合了前面二种的优点，会极大地提高ETL的开发速度和效率。

通过ETL，我们可以基于源系统中的数据来生成数据仓库。ETL为我们搭建了OLTP系统和OLAP系统之间的桥梁，是数据从源系统流入数据仓库的通道。在数据仓库的项目实施中，它关系到整个项目的数据质量，所以马虎不得，必须将其摆到重要位置，将数据仓库这一大厦的根基筑牢!

ETL的设计分三部分：数据抽取、数据的清洗转换、数据的加载。

在设计ETL的时候我们也是从这三部分出发。

**数据的抽取**是**从各个不同的数据源抽取到ODS（OperationalDataStore，操作型数据存储） 中**——这个过程也可以做一些数据的清洗和转换），在抽取的过程中需要挑选不同的抽取方法，尽可能的提高ETL的运行效率。ETL三个部分中，花费时间最长的是“T”（Transform，清洗、转换）的部分，一般情况下这部分工作量是整个ETL的2/3。数据的加载一般在数据清洗完了之后直接写入DW （DataWarehousing，数据仓库）中去。

ETL的实现有多种方法，常用的有三种。

1. 一种是借助ETL工具（如Oracle的 OWB、SQLServer2000的DTS、SQLServer2005的SSIS服务、Informatic等）实现，
2. 一种是SQL方式实现，
3. 另外一种是ETL工具和SQL相结合。

前两种方法各有各的优缺点，借助工具可以快速的建立起ETL工程，屏蔽了复杂的编码任务，提高了速度，降低了难度，但是缺少灵活性。SQL的方法优点是灵活，提高ETL运行效率，但是编码复杂，对技术要求比较高。第三种是综合了前面二种的优点，会极大地提高ETL的开发速度和效率。



数据抽取（Extract）、转换（Transform）、装载（Load）的过程，它是构建数据仓库的重要环节。







### 一，数据抽取(Extract)

这一部分需要在调研阶段做大量的工作，首先要搞清楚**数据是从几个业务系统中来**,**各个业务系统的数据库服务器运行什么DBMS**，**是否存在手工数据，手工数据量有多大****，**是否存在非结构化的数据等等**，当收集完这些信息之后才可以进行数据抽取的设计。

　　1、对于**与存放DW的数据库系统相同的数据源**处理方法

　　这一类数据源在设计上比较容易。一般情况下，DBMS（SQLServer、Oracle）都会提供**数据库链接功能**，在DW数据库服务器和原业务系统之间建立直接的链接关系就可以写Select语句直接访问。

　　2、对于**与DW数据库系统不同的数据源**的处理方法

　　对于这一类数据源，一般情况下也可以通过ODBC的方式建立数据库链接——如 SQLServer和Oracle之间。**如果不能建立数据库链接，可以有两种方式完成**，**一种是**通过工具将源数据导出成.txt或者是.xls文件，然后再将这些源系统文件导入到ODS中。另外一种方法是通过程序接口来完成。

> 操作数据存储ODS（Operational Data Store）是数据仓库体系结构中的一个可选部分，ODS具备数据仓库的部分特征和[OLTP](http://baike.baidu.com/item/OLTP)系统的部分特征，它是“面向主题的、集成的、当前或接近当前的、不断变化的”数据。是一个面向主题的、集成的、可变的、当前的细节数据集合，用于支持企业对于即时性的、操作性的、集成的全体信息的需求。
>
> ods是短期的实时的数据，供产品或者运营人员日常使用，而数据仓库是供战略决策使用的数据；ods是可以更新的数据，数据仓库是基本不更新的反应历史变化的数据，还有很多，这里就不一一列举了。
>
> 如何能搭建一个体系，既能支持战略决策使用的数据仓库数据，又能兼容业务快速的变化和运营产品人员日常需求的ODS数据哪？
>
> 经过调研，发现大体上有三种解法：
>
> 1、业务数据 － ODS － 数据仓库
>
> ![ODS_DW](.\imagenote\ODS_DW.png)
>
> 优点：这样做的好处是ODS的数据与数据仓库的数据高度统一；开发成本低，至少开发一次并应用到ODS即可；可见ODS是发挥承上启下的作用，调研阿里巴巴的数据部门也是这么实现的。缺点：数据仓库需要的所有数据都需要走ODS，那么ODS的灵活性必然受到影响，甚至不利于扩展、系统的灵活性差.
>
> 2、OB － ODS
>
> 优点：结构简单。一般的初创数据分析团队都是类似的结构，比如我们部门就应该归结到这一范畴
>
> 缺点：这样所有数据都归结到ODS，长期数据决策分析能力差，软硬件成本高，模块划分不清晰，通用性差
>
> 3、数据仓库和ODS并行
>
> 可见这个模型兼顾了上面提高的各自优点，且便于扩展，ODS和数据仓库各做各的，形成优势互补！可以解决现在互联网公司遇到的快速变化、快速开发等特点！特别是对于那些刚刚创建数据团队，数据开发人员紧缺的公司，可以尝试使用这个数据架构解决问题！
>
> ![](.\imagenote\ODS_DW2.png)



　　3、对于文件类型数据源（.txt,.xls），可以培训业务人员利用数据库工具将这些数据导入到指定的数据库，然后从指定的数据库中抽取。或者还可以借助工具实现，如SQLServer2005的SSIS服务的平面数据源和平面目标等组件导入ODS中去。

　　4、增量更新的问题

　　对于数据量大的系统，必须考虑增量抽取。一般情况下，业务系统会记录业务发生的时间，我们可以用来做增量的标志,每次抽取之前首先判断ODS中记录最大的时间，然后根据这个时间去业务系统取大于这个时间所有的记录。利用业务系统的时间戳，一般情况下，业务系统没有或者部分有时间戳。

### 二、数据的清洗转换

　　一般情况下，数据仓库分为ODS、DW两部分。通常的做法是从业务系统到ODS做清洗，将脏数据和不完整数据过滤掉，在从ODS到DW的过程中转换，进行一些业务规则的计算和聚合。

1、数据清洗

　　数据清洗的任务是过滤那些不符合要求的数据，将过滤的结果交给业务主管部门，确认是否过滤掉还是由业务单位修正之后再进行抽取。不符合要求的数据主要是有不完整的数据、错误的数据、重复的数据三大类。

　　（1）不完整的数据：这一类数据主要是一些应该有的信息缺失，如供应商的名称、分公司的名称、客户的区域信息缺失、业务系统中主表与明细表不能匹配等。对于这一类数据过滤出来，按缺失的内容分别写入不同Excel文件向客户提交，要求在规定的时间内补全。补全后才写入数据仓库。

　　（2）错误的数据：这一类错误产生的原因是业务系统不够健全，在接收输入后没有进行判断直接写入后台数据库造成的，比如数值数据输成全角数字字符、字符串数据后面有一个回车操作、日期格式不正确、日期越界等。这一类数据也要分类，对于类似于全角字符、数据前后有不可见字符的问题，只能通过写SQL语句的方式找出来，然后要求客户在业务系统修正之后抽取。日期格式不正确的或者是日期越界的这一类错误会导致ETL运行失败，这一类错误需要去业务系统数据库用SQL的方式挑出来，交给业务主管部门要求限期修正，修正之后再抽取。

　　（3）重复的数据：对于这一类数据——特别是维表中会出现这种情况——将重复数据记录的所有字段导出来，让客户确认并整理。

　　数据清洗是一个反复的过程，不可能在几天内完成，只有不断的发现问题，解决问题。对于是否过滤，是否修正一般要求客户确认，对于过滤掉的数据，写入Excel文件或者将过滤数据写入数据表，在ETL开发的初期可以每天向业务单位发送过滤数据的邮件，促使他们尽快地修正错误,同时也可以做为将来验证数据的依据。数据清洗需要注意的是不要将有用的数据过滤掉，对于每个过滤规则认真进行验证，并要用户确认。

2、数据转换

　　数据转换的任务主要进行不一致的数据转换、数据粒度的转换，以及一些商务规则的计算。

　　（1）不一致数据转换：这个过程是一个整合的过程，将不同业务系统的相同类型的数据统一，比如同一个供应商在结算系统的编码是XX0001,而在CRM中编码是YY0001，这样在抽取过来之后统一转换成一个编码。

　　（2）数据粒度的转换：业务系统一般存储非常明细的数据，而数据仓库中数据是用来分析的，不需要非常明细的数据。一般情况下，会将业务系统数据按照数据仓库粒度进行聚合。

　　（3）商务规则的计算：不同的企业有不同的业务规则、不同的数据指标，这些指标有的时候不是简单的加加减减就能完成，这个时候需要在ETL中将这些数据指标计算好了之后存储在数据仓库中，以供分析使用。



## 网易金融业务分析监控系统sql

navicat是测试数据库

https://www.fc18.com.cn/bam/Baf/BafSqlCommand是生产库

navicat不加分号`；`也可以运行

但是生产库必须要加上分号`；`

`select client.oid,IdNumber from client where IdNumber REGEXP '371323199.*';`



# 20170510



`INNER JOIN`     等价于   `JOIN`
你可以理解为  `JOIN` 　　是  `INNER JOIN`   的缩写。
`LEFT JOIN`  等价于   `LEFT  OUTER   JOIN`
`RIGHT JOIN`  等价于   `RIGHT OUTER   JOIN`

## sql例子

> 注册时间超过3个月 并且 历史投资金额累计超过5万或者现金存款仍大于一万客户名单（姓名，手机号，客户ID）
>

`SELECT c.oid,c.FirstName,sum(ac.CurrentBalance),sum(ar.TransAmount)`
`FROM 	client c`
`JOIN agreement ag ON ag.ClientId = c.oid and ag.AgreementLevel ='Root' and ag.ProductCategoryCode not in ('TYJ','JXQ')`
`JOIN account ac ON ac.AgreementId = ag.oid`
`JOIN agreementrequest ar ON ar.AgreementId = ag.oid AND ar.TransType IN ('Deposit', 'AddDeposit') and ar.TransStatus ='Active'`
`WHERE CURRENT_DATE - date(c.createdOn) >100` 
`GROUP BY c.oid HAVING (sum(ac.CurrentBalance)>=10000) OR (sum(ar.TransAmount)>=50000)` 
`ORDER BY sum(ar.TransAmount);`





## sql语句顺序



SQL 不同于与其他编程语言的最明显特征是处理代码的顺序。在大数编程语言中，代码按编码顺序被处理，但是在SQL语言中，第一个被处理的子句是FROM子句，尽管SELECT语句第一个出现，但是几乎总是最后被处理。

每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者（客户端应用程序或者外部查询）不可用。只是最后一步生成的表才会返回 给调用者。如果没有在查询中指定某一子句，将跳过相应的步骤。

select子句及其顺序**

| 子句       | 说明        | 是否必须使用      |
| -------- | --------- | ----------- |
| select   | 要返回的列或表达式 | 是           |
| from     | 从中检索数据的表  | 仅在从表选择数据时使用 |
| where    | 行级过滤      | 否           |
| group by | 分组说明      | 仅在按组计算聚集时使用 |
| having   | 组级过滤      | 否           |
| order by | 输出排序顺序    | 否           |
| limit    | 要检索的行数    | 否           |
|          |           |             |





> `(8)SELECT (9)DISTINCT  (11)<Top Num> <select list>`
> `(1)FROM [left_table]`
> `(3)<join_type> JOIN <right_table>`
> `(2)ON <join_condition>`
> `(4)WHERE <where_condition>`
> `(5)GROUP BY <group_by_list>`
> `(6)WITH <CUBE | RollUP>`
> `(7)HAVING <having_condition>`
> `(10)ORDER BY <order_by_list>`



**逻辑查询处理阶段简介**

1. **FROM：**对FROM子句中的前两个表执行笛卡尔积（Cartesian product)(交叉联接），生成虚拟表VT1
2. **ON：**对VT1应用ON筛选器。只有那些使<join_condition>为真的行才被插入VT2。
3. **OUTER(JOIN)：**如 果指定了OUTER JOIN（相对于CROSS JOIN 或(INNER JOIN),保留表（preserved table：左外部联接把左表标记为保留表，右外部联接把右表标记为保留表，完全外部联接把两个表都标记为保留表）中未找到匹配的行将作为外部行添加到 VT2,生成VT3.如果FROM子句包含两个以上的表，则对上一个联接生成的结果表和下一个表重复执行步骤1到步骤3，直到处理完所有的表为止。
4. **WHERE：**对VT3应用WHERE筛选器。只有使<where_condition>为true的行才被插入VT4.
5. **GROUP BY：**按GROUP BY子句中的列列表对VT4中的行分组，生成VT5.
6. **CUBE|ROLLUP：**把超组(Suppergroups)插入VT5,生成VT6.
7. **HAVING：**对VT6应用HAVING筛选器。只有使<having_condition>为true的组才会被插入VT7.
8. **SELECT：**处理SELECT列表，产生VT8.
9. **DISTINCT：**将重复的行从VT8中移除，产生VT9.
10. **ORDER BY：**将VT9中的行按ORDER BY 子句中的列列表排序，生成游标（VC10).
11. **TOP：**从VC10的开始处选择指定数量或比例的行，生成表VT11,并返回调用者。



# 20170511



sourcetree：命令行模式，是 sourcetree本身的git，不是 gitbash那个



git账户:shidexiao sswsdx@163.com



sourcetree: 武刚建了分支，我需要先从远程 origin找到 分支 检出（checkout），然后获取分支。



maven：Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。

Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。

spring tool suite:

JAR包：jar包就是别人已经**写好的一些类**，然后**将这些类进行打包**，你可以**将这些jar包引入你的项目中**，然后就可以**直接使用这些jar包中的类和属性以及方法**。
**JAR（Java ARchive）**是**将一系列文件合并到单个压缩文件里，就象Zip那样**。然而，同Java中其他任何东西一样，JAR文件是跨平台的，所以不必关心涉及具体平台的问题。

涉及因特网应用时，JAR文件显得特别有用。在JAR文件之前，Web浏览器必须重复多次请求Web服务器，以便下载完构成一个“程序片”（Applet）的所有文件。除此以外，每个文件都是未经压缩的。但在将所有这些文件合并到一个JAR文件里以后，只需向远程服务器发出一次请求即可。同时，由于采用了压缩技术，所以可在更短的时间里获得全部数据。



# 20170512



内网IP地址 192.~.~.~

公司内网需要使用vpn

艳茹的IP地址是193.168.1.9

内网IP地址只是内部使用，其他内网可能也有相同的IP地址。

外网IP地址

我的公网IP地址（百度到的）58.247.2.58

内网IP地址：192.168.1.206

ping一下




## java变量：成员变量、类变量、局部变量

变量名首字母使用小写，如果由多个单词组成，从第2个单词开始的其他单词的首字母使用大写。

如果局部变量的名字和成员变量的名字相同，要想在该方法中使用成员变量，必须使用关键字`this`

source-->add block comment :ctrl+shift+/

source-->remove block comment: ctrl+shift+/







## 内网IP、外网IP

内网IP地址、外网IP地址这个概念并不是固定的，而是相对的。如果用私有IP、公网IP或者局域网IP、互联网IP来理解就容易多了。

Address Block                    Name                              RFC                       
0.0.0.0/8                        "This host on this network"       [RFC1122], section 3.2.1.3
10.0.0.0/8                       Private-Use                       [RFC1918]                 
100.64.0.0/10                    Shared Address Space              [RFC6598]                 
127.0.0.0/8                      Loopback                          [RFC1122], section 3.2.1.3
169.254.0.0/16                   Link Local                        [RFC3927]                 
172.16.0.0/12                    Private-Use                       [RFC1918]                 
192.0.0.0/24[2]                  IETF Protocol Assignments         [RFC6890], section 2.1    
192.0.0.0/29                     IPv4 Service Continuity Prefix    [RFC7335]                 
192.0.0.8/32                     IPv4 dummy address                [RFC7600]                 
192.0.0.9/32                     Port Control Protocol Anycast     [RFC-ietf-pcp-anycast-08] 
192.0.0.170/32, 192.0.0.171/32   NAT64/DNS64 Discovery             [RFC7050], section 2.2    
192.0.2.0/24                     Documentation (TEST-NET-1)        [RFC5737]                 
192.31.196.0/24                  AS112-v4                          [RFC7535]                 
192.52.193.0/24                  AMT                               [RFC7450]                 
192.88.99.0/24                   Deprecated (6to4 Relay Anycast)   [RFC7526]                
192.168.0.0/16                   Private-Use                       [RFC1918]                 
192.175.48.0/24                  Direct Delegation AS112 Service   [RFC7534]                 
198.18.0.0/15                    Benchmarking                      [RFC2544]                 
198.51.100.0/24                  Documentation (TEST-NET-2)        [RFC5737]                 
203.0.113.0/24                   Documentation (TEST-NET-3)        [RFC5737]                 
240.0.0.0/4                      Reserved                          [RFC1112], section 4      
255.255.255.255/32               Limited Broadcast                 [RFC919], section 7 

如上表，运营商给你的100.64.*.*也是私有地址（因为地主家也没有余量啊，以前大家大家共享一个地址池，有随机的公网地址，现在公网地址更加紧张，运营商只给客户分配私网地址，然后nat后大家共享一个公网地址），《盗梦空间》看过吧，二重梦境，你用路由器上网也就是二重局域网。也就是说：如果内网、外网是指**私有地址与公网地址的话，那么100.64.0.30和192.168.1.101都是内网IP**，你没有外网IP。如果内网、外网是**相对你路由器来讲，那么100.64.0.30是外网IP，192.168.1.101是内网IP**。

问题1：不用家庭路由器，直接电脑分配到100.64.0.30，那么理论上100.64.0.1-100.64.0.254的确可以直接通讯，无需运营商路由。但实际上是通过各种技术做了隔离的。你无法访问他们。

问题2：因为你路由器获取的地址仍然是私网地址，所以你在外部连路由器都无法访问。除非在运营商的设备上做端口映射才能访问到路由器。



## FC ORM API用户手册

随着公司业务增长的和产品开发迭代的需求，现有的api和数据库架构需要迁移到适应水平分库的架构中来。新的ORM API实现的分库的访问，需要开发人员在后续的开发中掌握和使用。

> 对象关系映射（object relation mapping，简称ORM）是一种程序技术，用于实现**面向对象编程语言**里**不同类型系统的数据之间的转换**。
>
> 面向对象是从软件工程基本原则（如耦合、聚合、封装）的基础上发展起来的，
>
>       内聚（本题的聚合）：内聚是指一个模块内部各个部分之间的关联程度
>       耦合：耦合指各个模块之前的关联程度      
>       封装原则：隐藏对象的属性和实现细节，仅对外公开借口，并且控制访问级别
>       在面向对象方法中，用类来实现上面的要求。用类实现封装，用封装来实现高内聚，低耦合。
> 而关系数据库则是从数学理论发展而来的，
>
> > **高内聚低耦合**：其实就是为了更好的代码重用。把握好代码重用这关就好了，其它的概念都是扯淡











# 20170515



`<span>` 在CSS定义中属于一个行内元素,在行内定义一个区域，也就是一行内可以被` <span>` 划分成好几个区域，从而实现某种特定效果。

` <span> `本身没有任何属性。

` <div> `在CSS定义中属于一个块级元素 `<div>` 可以包含段落、标题、表格甚至其它部分。这使DIV便于建立不同集成的类，如章节、摘要或备注。

在页面效果上，使用` <div> `会自动换行，使用 `<span>` 就会保持同行。

span是行内元素；div是块级元素；他们都是容器！

> <p><span>some text.</span>some other text.</p>
> p.tip span {
> font-weight:bold;
> color:#ff9955;
> }
> <p class="tip"><span>提示：</span>... ... ...</p>



使用 <span> 元素对文本中的一部分进行着色：

<p>我的母亲有 <span style="color:blue">蓝色</span> 的眼睛。</p>

## 三层架构

三层架构(3-tier architecture) 通常意义上的三层架构就是将整个业务应用划分为：

1. 界面层（User Interface layer）、
2. 业务逻辑层（Business Logic Layer）、
3. 数据访问层（Data access layer）。



1. 数据访问层：有时候也称为是**持久层**，其功能主要是**负责数据库的访问**，可以访问数据库系统、二进制文件、文本文档或是XML文档。主要看数据层里面有没有包含逻辑处理，实际上它的各个函数主要完成各个对数据文件的操作。而不必管其他操作。
2. 业务逻辑层：它的关注点主要集中在业务规则的制定、业务流程的实现等与业务需求有关的系统设计，也即是说它是与系统所应对的领域（Domain）逻辑有关，很多时候，也将业务逻辑层称为**领域层**。主要负责对数据层的操作。也就是说把一些数据层的操作进行组合。
3. 表示层：主要对用户的请求接受，以及数据的返回，为客户端提供应用程序的访问。

区分层次的目的即为了**高内聚低耦合**的思想。

在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。

微软推荐的分层式结构一般分为三层，从下至上分别为：**数据访问层、业务逻辑层（又或称为领域层）、表示层**。

![](.\imagenote\三层架构.jpg)

![](.\imagenote\三层架构2.jpg)

**持久层Persistence**

持久层只是一个逻辑概念而已，主要任务是负责把数据保存起来，一般是指保存至数据库或者文件，也可以负责完成与之相关的行为。

持久层指的是把数据长期保存起来，如数据库把数据长期保存在硬盘里，XML也可以长期保存数据，还有如果把数据存放到指定文件中，也可以成为持久层。

持久化可以理解为动词。Java中的**Hibernate**做的就是持久化的操作，主要是对数据库底层的OR映射，这样我们就不必关心讨厌的关系映射了，直接操作对象就可以了。

**DAL  Data Access Layer，数据访问层**

**DAL**是三层架构(表现层，业务逻辑层，数据访问层)中的数据访问层，是一个概念或者说是一个方案，它由许多**DAO**(**DAO data access object，数据访问对象**)组成，或者说由**DAO**具体实现，是把和数据库相关的代码封装起来，这样当我们执行分库时，便只用调整**DAO**的代码了，模型根本不用关心它使用的数据是放在A库还是B库。

设计数据访问层接口的目的是让业务逻辑层不去调用具体的数据访问层的实现（不依赖于数据访问层具体的实现技术），这样的好处是，业务逻辑不必管数据访问层具体是什么技术来实现的，接口是不变的。

业务逻辑不必管数据访问层具体是什么技术来实现的，接口是不变的，数据访问层可以用jdbc来实现，也可以用hibernate来实现，而且更换起来不是非常麻烦，这样耦合就降低了.

**DAO data access object，数据访问对象**

**DAO**是一个软件设计的指导原则，在核心[J2EE](http://baike.baidu.com/view/1507.htm)模式中是这样介绍**DAO**模式的：为了建立一个健壮的J2EE应用，应该将所有对数据源的访问操作抽象封装在一个公共API中。用程序设计的语言来说，就是建立一个接口，接口中定义了此[应用程序](http://baike.baidu.com/view/330120.htm)中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口在逻辑上对应这个特定的数据存储。

顾名思义就是与数据库打交道，夹在业务逻辑与数据库资源中间，是**DAL**的具体实现。

简单的说 **dao**层 就是对数据库中数据的增删改查等操作封装在专门的类里面，在业务逻辑层中如果要访问数据的时候，直接调用该**dao**类（包括了如何访问数据库和数据的增删改查等等代码），就可以返回数据，而不需要再在业务逻辑层中写这些代码。



## MVC架构

MVC（模型Model-视图View-控制器Controller）是一种架构模式，可以用它来创建在域对象和UI表示层对象之间的区分。

同样是架构级别的，相同的地方在于他们都有一个表现层，但是他们不同的地方在于其他的两个层。

在三层架构中没有定义Controller的概念。这是最不同的地方。而MVC也没有把业务的逻辑访问看成两个层，这是采用三层架构或MVC搭建程序最主要的区别。当然了。在三层中也提到了Model，但是三层架构中Model的概念与MVC中Model的概念是不一样的，“三层”中典型的Model层是以实体类构成的，而MVC里，则是由业务逻辑与访问数据组成的。

![](.\imagenote\MVC1.jpg)

![](.\imagenote\MVC2.jpg)

**模型 Model**

模型是MVC中的概念，指的是读取数据和改变数据的操作（业务逻辑）。一开始我们直接把和数据库相关的代码放在模型里(sql直接写在代码中)，这样就会导致以后的维护相当麻烦。业务逻辑的修改都需要开发者重新写sql，如果项目需要分库，需要将sql语句抽出来，放到单独的一层。这一层就是**DAL**(数据访问层Data Access Layer)。









## ORM框架



ORM也是一种对数据库访问的封装，然而ORM不像**DAO**只是一种软件设计的指导原则，强调的是系统应该层次分明，更像是一种工具，有着成熟的产品，比如JAVA界非常有名的**Hibernate**，以及很多PHP框架里自带的ORM库。他们的好处在于能将你程序中的数据对象自动地转化为关系型数据库中对应的表和列，数据对象间的引用也可以通过这个工具转化为表之间的JOIN。使用ORM的好处就是使得你的开发几乎不用接触到SQL语句。创建一张表，声明一个对应的类，然后你就只用和这个类的实例进行交互了，至于这个对象里的数据该怎么存储又该怎么获取，通通不用关心。

![](.\imagenote\ORM.jpg)

**Hibernate**是全自动ORM框架，而**Mybatis**是半自动的。

1. hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。
2. 而mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理..

hibernate数据库移植性远大于mybatis。 hibernate通过它强大的映射结构和hql语言，大大降低了对象与数据库（oracle、mysql等）的耦合性，而mybatis由于需要手写sql，因此与数据库的耦合性直接取决于[程序](http://www.xuebuyuan.com/)员写sql的方法，如果sql不具通用性而用了很多某数据库特性的sql语句的话，移植性也会随之降低很多，成本很高。

系统数据处理量巨大，性能要求极为苛刻，这往往意味着我们必须通过经过高度优化的sql语句（或存储过程）才能达到系统性能设计指标，在这种情况下Mybatis会有更好的可控性和表现，可以进行细粒度的优化。





## DUBBO

DUBBO是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，是阿里巴巴SOA服务化治理方案的核心框架，每天为2,000+个服务提供3,000,000,000+次访问量支持，并被广泛应用于阿里巴巴集团的各成员站点。

随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。

![](.\imagenote\dubbo-architecture-roadmap.jpg)

- 单一应用架构
  - 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。
  - 此时，用于简化增删改查工作量的 **数据访问框架(ORM)** 是关键。
- 垂直应用架构
  - 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。
  - 此时，用于加速前端页面开发的 **Web框架(MVC)** 是关键。
- 分布式服务架构
  - 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。
  - 此时，用于提高业务复用及整合的 **分布式服务框架(RPC)** 是关键。
- 流动计算架构
  - 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。
  - 此时，用于提高机器利用率的 **资源调度和治理中心(SOA)** 是关键。



## bam改造

```

public interface TObject {
	SObject getSObject();	
	void setSObject(SObject sobj);
}

```





1，搜索bmfAggrManager（菜单栏-->Seaarch--file search)，找到这些需要改写的地方
2，类似`Long fcCompanyId = bmfAggrManager.findOne("PasCompany", ImmutableMap.of("Code", "NFS")).getOid();`
（  在findone()函数上，鼠标点在上面，出现SObject，表明此函数返回的是SObject函数   ）
3，
`OrmUtilities.modifyBegin();`
`OrmUtilities.modifyEnd();`
在这两行代码之间改

4，两种方式
优先：
次要：
@Autowired 表示实例化，有这个就不需要 `new ***()`等
> @Autowired
> private BmfOrmAggrManager bmfOrmAggrManager;
> ClientOrmService clientOrmService = AiafContext.getBean(ClientOrmService.class);//TableNameOrmService表名后面加OrmService，监测是否存在
```
		优先
        
            OrmUtilities.modifyBegin();
     //	    SecurityUser user = bmfAggrManager.findOne(SecurityUser.class, ImmutableMap.of("ClinetId", clientId, "Mobile", mobile));
     //	    SecurityUser user = bmfAggrManager.findOne(SecurityUser.class, ImmutableMap.of("Mobile", mobile));
            SecurityUserOrmService securityUserOrmService = AiafContext.getBean(SecurityUserOrmService.class);
            SecurityUser user = securityUserOrmService.findOneByMobile(mobile);
            SecurityUser user = securityUserOrmService.findOneByClientId_Mobile(clientId, mobile);//如果ImmutableMap.of后有两个键值对。
            OrmUtilities.modifyEnd();
            
            -------------------------
            @Autowired
		   private SecurityUserOrmService securityUserOrmService
            OrmUtilities.modifyBegin();bmf
     //	    SecurityUser user = bmfAggrManager.findOne(SecurityUser.class, ImmutableMap.of("Mobile", mobile));
            
            SecurityUser user = securityUserOrmService.findOneByMobile(mobile);
            OrmUtilities.modifyEnd();
```

```
次要
@Autowired
private BmfOrmAggrManager bmfOrmAggrManager;
OrmUtilities.modifyBegin();
SObject prevTransFact = bmfAggrManager.findOne("FCTransFact", ImmutableMap.of("ReferenceDate", refDate.minusDays(1).toDate()));

SObject prevTransFact = bmfOrmAggrManager.findOne("FCTransFact", ImmutableMap.of("ReferenceDate", refDate.minusDays(1).toDate()));//次要
OrmUtilities.modifyEnd();
```

@Autowired
OrmUtilities.modifyBegin();
SecurityUser user = bmfAggrManager.findOne(SecurityUser.class, ImmutableMap.of("Mobile", mobile));
private ClientOrmService clientOrmService; //优先
OrmUtilities.modifyBegin();
OrmUtilities.modifyEnd();
bmfOrmAggrManager
5,对于find()方法：查看分表，如果是分表，在方法的第一个参数加clientId
对于save()方法：分表与主表均要添加第一个参数，分表是clientId的变量，主表是`0L`。

6，如果未在**TableOrmCategory**中的分表里，且没有**优先**级接口（ctrl+shift+T //查找TableNameOrmService：表名后面加OrmService，监测是否存在（法一：ctrl+shift+T ，法二：TableNameOrmService，鼠标放上看有没有，import）），去询问李晗是不是分表。

7，根据ImmutableMap.of（）中的键值对确定
次要的那个原语句 
放一个文件中，一起发给唐超凡

save的那种需要 立即给唐超凡

AccountEntry  accountEntry;
AccountOrmService accountO	rmService = AiafContext.getBean(AccountOrmService.class);
Account account = accountOrmService.findOneByParentId(accountEntry.getParentId());
accountEntryOrmService.save(account.getClientId(), accountEntry);
accountOrmService.save(account);

		bmfOrmAggrManager.save(clientId, sobject);.save(fcTransFact);
				AccountOrmService accountOrmService = AiafContext.getBean(AccountOrmService.class);
				accountOrmService.save(account);
			}


# 20170516

### 基本语法

#### java三目运算符---条件运算符（?:）

条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。

**variable x = (expression) ? value if true : value if false**

> variable x = (expression) ? value if true : value if false
>
> 这里expression是判断语句（例如：null==sobject）
>
> public class Test {
>    public static void main(String args[]){
> ​      int a , b;
> ​      a = 10;
> ​      // 如果 a 等于 1 成立，则设置 b 为 20，否则为 30
> ​      b = (a == 1) ? 20 : 30;
> ​      System.out.println( "Value of b is : " +  b );
>
> ​      // 如果 a 等于 10 成立，则设置 b 为 20，否则为 30
> ​      b = (a == 10) ? 20 : 30;
> ​      System.out.println( "Value of b is : " + b );
>    }
> }



#### 编写Java程序时，应注意以下几点：

- **大小写敏感**：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。
- **类名**：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。
- **方法名**：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。
- **源文件名**：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。
- **主方法入口**：所有的Java 程序由**public static void main(String []args)**方法开始执行。

#### Java 对象和类

Java作为一种面向对象语言。支持以下基本概念：

- 多态
- 继承
- 封装
- 抽象
- 类
- 对象
- 实例
- 方法
- 重载

#### 构造方法

##### java的构造函数其实很简单。
一个类 被实例化 也就是被new的时候 最先执行的是 构造函数，如果你有留心。你会发现很多类里面根本没有写构造函数。
在java类中，如果不显示声明构造函数，JVM 会给该类一个默认的构造函数。
一个类 可以有多个构造函数。
构造函数的主要作用
	一是用来实例化该类。
	二是 让该类实例化的时候执行哪些方法，初始化哪些属性。
当一个类声明了构造函数以后，JVM 是不会再给该类分配默认的构造函数。
比如一个实体类
	public class entity{
	  	private int id;
	  	private String userName;
	  	get...set..方法
	}
如果这样写该类就是默认的构造函数。该类实例化的时候 id 和 username 就是默认值 即 id=0,username=null.
如果在里面加入这样一个方法
	public entity(int id,String userName){
	 	调用get..set..
	}
如果这样写 该类实例化的时候 必须给出 id  和username参数。 JVM不会再给这个类默认构造函数
你也可以理解成 在没有给构造函数的时候 JVM 给你的类加了一个这样的函数
    public entity(){
    	this.id=0;
    	this.userName=null;
    }
其实构造函数是用来对一个类以及变量进行实例化。
##### 一个简单的类，一共有四个构造方法
构造方法，在new对象的时候就会自己调用，也是对象的初始方法，如果你自己不写构造方法默认的会自动加上一个无参的构造。如果不存在构造方法那也就创建不了类的实例。
    public class Test {
    private String name;
    private String sex;
    private String age;
    public Test(){
    super();
    }
    public Test(String name){
    this.name=name;
    }
    public Test(String name,String sex){
    this.name=name;
    this.sex=sex;
    }
    public Test(String name,String sex,String age){
    this.name=name;
    this.sex=sex;
    this.age=age;
    }
    }
上面写了一个简单的类，一共有四个构造方法，这样你就有四种方法构造类实例（对象）
    new Test();
    new Test("张三");
    new Test("张三","男");
    new Test("张三","男","16");
有了构造，也就相应提供了初始方法

##### 每个类都有构造方法。
每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。
在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。
> `public class Puppy{`
> ​    public Puppy(){
> ​    }
>
> ​    public Puppy(String name){
> ​        // 这个构造器仅有一个参数：name
> ​    }
> `}`

#### java语法--java修饰符
##### 访问控制修饰符
Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java支持4种不同的访问权限。
1. 默认的，也称为 **default**，在同一包内可见，不使用任何修饰符。
2. 私有的，以 **private** 修饰符指定，在同一类内可见。
3. 共有的，以 **public** 修饰符指定，对所有类可见。
4. 受保护的，以 **protected** 修饰符指定，对同一包内的类和所有子类可见。

##### 非访问修饰符

为了实现一些其他的功能，Java 也提供了许多非访问修饰符。

1. static 修饰符，用来创建类方法和类变量。
   **静态变量：**
   static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。
   静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。
   **静态方法：**
   static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。
2. final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。final用于常量的声明，规范要求常量的变量名是大写的。
   **final 变量：**
   final 变量能被显式地初始化并且只能初始化一次。
   **final 方法：**
   类中的 final 方法可以被子类继承，但是不能被子类修改。
   **final 类：**
   final 类不能被继承，没有类能够继承 final 类的任何特性。
3. abstract 修饰符，用来创建抽象类和抽象方法。
4. synchronized 和 volatile 修饰符，主要用于线程的编程。
#### java语法--java变量类型
Java语言支持的变量类型有：
成员变量：类变量、实例变量
- 类变量：（也称为静态变量）独立于方法之外的变量，用 static 修饰。
- 实例变量：（也称为成员变量）独立于方法之外的变量，不过没有 static 修饰。
- 局部变量：类的方法中的变量。

> `package com.test;`
> `//LOL里面的英雄类`
> `public class Hero {`
> ​	`int age;//成员变量`
> ​	`String name;//成员变量`
> ​	`static int age1;//类变量（静态变量）`
> ​	`static String name2;//类变量（静态变量）`
> ​	`public void run(){`
> ​		`String name3;//局部变量`
> ​		`int age3;//局部变量`
> ​	`}`
> `}`



### Java面向对象

我们可以把JAVA中的类分为以下三种：
- 类：使用class定义且不含有抽象方法的类。
- 抽象类：使用abstract class定义的类，它可以含有，也可以不含有抽象方法。
- 接口：使用interface定义的类。
  继承规律
- 类可以继承（extends）类，可以继承（extends）抽象类，可以继承（implements）接口。
- 抽象类可以继承（extends）类，可以继承（extends）抽象类，可以继承（implements）接口。
- 接口只能继承（extends）接口。
  一个普通类继承一个接口后，必须实现这个接口中定义的所有方法，否则就只能被定义为抽象类。
  我在这里之所以没有对implements关键字使用“实现”这种说法是因为从概念上来说它也是表示一种继承关系，而且**对于抽象类implements接口**的情况下，它并不是一定要实现这个接口定义的任何方法，因此使用继承的说法更为合理一些。
- 类和抽象类都只能最多继承一个类，或者最多继承一个抽象类，并且这两种情况是互斥的，也就是说它们要么继承一个类，要么继承一个抽象类。
- 类、抽象类和接口在继承接口时，不受数量的约束，理论上可以继承无限多个接口。当然，对于类来说，它必须实现**它所继承的所有接口**中定义的全部方法。
- 抽象类继承抽象类，或者实现接口时，可以部分、全部或者完全不实现父类抽象类的抽象（abstract）方法，或者父类接口中定义的接口。
- 类继承抽象类，或者实现接口时，必须全部实现父类抽象类的全部抽象（abstract）方法，或者父类接口中定义的全部接口。
#### Java继承（inheritance）

简单的说，继承就是在一个现有类型的基础上，通过**增加新的方法或者重定义已有方法**（下面会讲到，这种方式叫重写）的方式，产生一个新的类型。
继承是面向对象的三个基本特征--**封装、继承、多态**的其中之一，我们在使用JAVA时编写的每一个类都是在继承，
因为在JAVA语言中，**java.lang.Object类**是所有类最根本的基类（或者叫父类、超类），如果我们新定义的一个类没有明确地指定继承自哪个基类，那么JAVA就会默认为它是继承自Object类的。

继承给我们的编程带来的好处就是**对原有类的复用（重用）**。**就像模块的复用一样**，**类的复用**可以提高我们的开发效率，实际上，**模块的复用是大量类的复用叠加后的效果。**除了继承之外，我们还可以使用组合的方式来复用类。所谓组合就是把原有类定义为新类的一个属性，通过在新类中调用原有类的方法来实现复用。如果新定义的类型与原有类型之间不存在被包含的关系，也就是说，从抽象概念上来讲，新定义类型所代表的事物并不是原有类型所代表事物的一种，比如黄种人是人类的一种，它们之间存在包含与被包含的关系，那么这时组合就是实现复用更好的选择。下面这个例子就是组合方式的一个简单示例：


#### Java 重写Override/重载Overload

重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。**即外壳不变，核心重写！**

重载和重写都是针对方法的概念，在弄清楚这两个概念之前，我们先来了解一下什么叫方法的型构（英文名是signature，有的译作“签名”，虽然它被使用的较为广泛，但是这个翻译不准确的）。型构就是指方法的组成结构，具体包括方法的名称和参数，涵盖参数的数量、类型以及出现的顺序，但是不包括方法的返回值类型，访问权限修饰符，以及abstract、static、final等修饰符。比如下面两个就是具有相同型构的方法：

Java代码
public void method(int i, String s) {   
​    // do something   
}   

public String method(int i, String s) {   
​    // do something   
}

而这两个就是具有不同型构的方法：
Java代码
public void method(int i, String s) {   
​    // do something   
}   

public void method(String s, int i) {   
​    // do something   
}

- 重写，英文名是overriding，是指在继承情况下，子类中定义了与其基类中方法具有**相同型构**的新方法，就叫做子类把基类的方法重写了。这是实现**多态**必须的步骤。
- 重载，英文名是overloading，是指在同一个类中定义了一个以上具有相同名称，但是**型构不同**的方法。在同一个类中，是不允许定义多于一个的具有相同型构的方法的。

我们来考虑一个有趣的问题：构造器可以被重载吗？答案当然是可以的，我们在实际的编程中也经常这么做。实际上构造器也是一个方法，构造器名就是方法名，构造器参数就是方法参数，而它的返回值就是新创建的类的实例。但是构造器却不可以被子类重写，因为子类无法定义与基类具有相同型构的构造器。

#### Java 多态（Polymorphism）



#### Java 抽象类（abstract class）

在Java语言中使用abstract class来定义抽象类。



#### Java 封装（Encapsulation）

实现Java封装的步骤:

1. 修改属性的可见性来限制对属性的访问（一般限制为private），例如：

   public class Person {
   ​    private String name;
   ​    private int age;
   }

   这段代码中，将 **name** 和 **age** 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。

2. 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如：

public class Person{
​    private String name;
​    private int age;
​    public int getAge(){
​      return age;
​    }
​    public String getName(){
​      return name;
​    }
​    public void setAge(int age){
​      this.age = age;
​    }
​    public void setName(String name){
​      this.name = name;
​    }
}
以上实例中public方法是外部类访问该类成员变量的入口。
通常情况下，这些方法被称为getter和setter方法。
因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。

    public class RunEncap{
    public static void main(String args[]){
        EncapTest encap = new EncapTest();
        encap.setName("James");
        encap.setAge(20);
        encap.setIdNum("12343ms"); 
        System.out.print("Name : " + encap.getName()+ 
                               " Age : "+ encap.getAge());
      }

#### Java接口（Interface）



#### Java 包（package）

ava 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。

### Java 高级教程



#### Java数据结构

Java工具包提供了强大的数据结构。在Java中的数据结构主要包括以下几种接口和类：

- 枚举（Enumeration）：枚举（Enumeration）接口虽然它本身不属于数据结构,但它在其他数据结构的范畴里应用很广。 枚举（The Enumeration）接口定义了一种从数据结构中取回连续元素的方式。

- 位集合（BitSet）：

- 向量（Vector）：向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。和数组一样，Vector对象的元素也能通过索引访问。使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。

- 栈（Stack）：栈（Stack）实现了一个后进先出（LIFO）的数据结构。

- 字典（Dictionary）：字典（Dictionary） 类是一个抽象类，它定义了键映射到值的数据结构。由于Dictionary类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现。

- 哈希表（Hashtable）：Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。

- 属性（Properties）：Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。

  Properties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。

以上这些类是传统遗留的，在Java2中引入了一种新的框架-集合框架(Collection)，我们后面再讨论。

哈希方法在“键- 值对”的存储位置与它的键之间建立一个确定的对应函数关系 hash() ，使得每一个键与结构中的一个唯一的存储位置相对应：存储位置=hash( 键 )

在搜索时，首先对键进行hash 运算，把求得的值当做“键 - 值对”的存储位置，在结构中按照此位置取“键 - 值对”，若键相等，则表示搜索成功。在存储“键 - 值对”的时候，依照相同的 **hash 函数**计算存储位置，并按此位置存放，这种方法就叫做**哈希方法，也叫做散列方法**。
**在哈希方法中使用的转换函数 hash 被称作哈希函数 ( 或者散列函数 ) 。按照此算法构造出来的表叫做哈希表 ( 或者散列表 ) 。**
哈希函数建立了从“键- 值对”到哈希表地址集合的一个映射，有了哈希函数，我们就可以根据键来确定“键 - 值对”在哈希表中的位置的地址。使用这种方法由于不必进行多次键的比较，所以其搜索速度非常快，很多系统都使用这种方法进行数据的组织和检索。

dictionary 跟 map 其实是同一个东西，只是在不同场合叫法不同。
dictionary 的中文是字典，map 在中文是映射，也有地图的意思。查字典，查地图，都是通过某个信息，去找到另一个信息。比如通过单词的拼写找到单词的具体含义。
类比查字典过程，单词的拼写为 key, 单词的具体含义为 value。dictionary 就是通过key，找到value，有时也将 dictionary 说成是 key-value 结构。只要达到查找目的，都可以叫做 dictionary。具体怎么找，可以有不同实现。
比如，最简单是将 key，value 放在一起，线性排。
>k1, k2, k3, k4, k4 ....
>v1, v2, v3, v4, v5 ....

当需要从 key 找到对应的 value 时，就从头到尾遍历过去。依次判断 k1, k2, k3, k4 是不是等于key, 当等于的时候，就找到 key 的具体位置，从而也就找到了value。
但这样从头到尾遍历，速度就太慢了，时间复杂度为 O(N)。N为数据的大小。
为了快速从key找到value。dictionary(或者说map)的通常有两种实现方式。
二叉树哈希(hash)表二叉树查找的时间复杂度为 O(logN)，哈希表的时间复杂度大致为 O(1)。
二叉树也分红黑树，AVL树等。
哈希表的速度很快，很多语言内置的 dictionary 都使用哈希表来实现，但它通常会浪费一些存储空间。
这部分有兴趣去看数据结构的书。
hash_map 其实就是使用 hash 表实现的 map。
注意，二叉树，哈希表仅仅是 dictionary 的实现方式，不能说 hash 就等于 dictionary，实现方式可以有多种多样。比如上面线性存储的实现，可以调整一下。当数据都放进来之后，先根据 key 来排序，再使用二分查找，就可以很快速地从 key 找到 value, 这种实现简单快速，并省内存，有时会比 hash 的实现更好。适合于一些数据不会经常变动的情况。
C++ 11 的标准库中有个 unordered_map，就是采用哈希表使用的 map。在C++ 11之前，没有标准的哈希实现，很多第三方库实现了哈希字典，基本都叫做 hash_map, 并应用广泛。所以C++ 11的实现就不能叫hash_map了，因为会造成很多现存的程序名字冲突。哈希实现的字典是无序，也就取了个不算太好的名字，unordered_map。






## Baf-mysql.properties

Baf-mysql.properties 放置配置文件 与 xml文件关联。  （ctrl+shift+R：Baf-mysql.properties ）

bam 是一个项目的数据库：172.16.1.72:3306
> `database.schema=bam`
> `database.username=bam`
> `database.password=YJkkYRrPRqYJ`

sia9是farms项目的数据库：172.16.1.114:3306

> `database.farmsro.username=root`
> `database.farmsro.password=Hubin123`
> `database.farmsro.schema=sia9`

主表 分表 到李晗那边问一下 哪些是主表分表。
bam里边的表 不在 frams的分库分表计划里，都不属于分表。



# 20170519



## 对照着前面的java语法，在修改bam改造代码时，看了bam开发空间里的代码

	java.lang.Object
​	

	public interface Serializable {}
​	 

	public interface BObject extends Serializable {
	public Long getOid();
	public void setOid(Long oid);
	public boolean isNewObject();
	public boolean isNewObject();
	public void setNewObject(boolean newObject);
	public Map<String, Object> getBmfProperties();
	public void setBmfProperties(Map<String, Object> bmfProperties);
	public Object getBmfProperty(String property);
	public void setBmfProperty(String property, Object object);
	public String getBmfTitle();
	public void setBmfTitle(String title);
	public BObject getBeforeImage();
	public void setBeforeImage(BObject beforeImage);
	public Object getProperty(String p);
	public void setProperty(String p, Object v);
	public Long getBafTenantId();
	public void setBafTenantId(Long bafTenantId);
	public abstract boolean isActive();
	public abstract void setActive(boolean active);
	public abstract Date getCreatedOn();
	public abstract void setCreatedOn(Date created);
	public abstract BmfUser getCreatedBy();
	public abstract void setCreatedBy(BmfUser createdBy);
	public abstract Date getUpdatedOn();
	public abstract void setUpdatedOn(Date updated);
	public abstract BmfUser getUpdatedBy();
	public abstract void setUpdatedBy(BmfUser updatedBy);	
	public Long getCreatedById();
	public void setCreatedById(Long createdById);
	public Long getUpdatedById();
	public void setUpdatedById(Long updatedById);
	public Date getDeletedOn();
	public void setDeletedOn(Date deletedOn);
	public BmfUser getDeletedBy();
	public void setDeletedBy(BmfUser deletedBy);
	public abstract BmfUser getOwnedBy();
	public abstract void setOwnedBy(BmfUser owner);
	public void sendStateEvent(String event);
	}


	public interface SObject extends BObject {
	public String getUid();
	public void initOid();
	public void initOid(Long newOid);
	public Long getAid();
	.......
	}


	public interface TObject {
	SObject getSObject();
	void setSObject(SObject sobj);

}

## 鲲总、春茂、小刚开会讨论汽车爬虫



春茂跟小刚说了hadoop

春茂让小刚设计一下表格

鲲总等让爬一下汽车品牌--车标--

图片先扒下来

春茂说了后面可能会买

春茂用的网易汽车做参考。



## bam改造新进展





DocItemServiceImpl.java
	public DocumentItem findDocItem(String code, DocItemStatusEnum status) {
	//默认查找富聪平台或者companyId为空的模板
		OrmUtilities.modifyBegin();
		//		Long fcCompanyId = bmfAggrManager.findOne("PasCompany", ImmutableMap.of("Code", "NFS")).getOid();
	//		PasCompanyOrmService pasCompanyOrmService = AiafContext.getBean(PasCompanyOrmService.class);
		PasCompany pasCompanyEntity = pasCompanyOrmService.findOneByCode("NFS");
		Long fcCompanyId = null;
		if(pasCompanyEntity != null)
			fcCompanyId = pasCompanyEntity.getSObject().getOid();
		OrmUtilities.modifyEnd();
		/** select * from DocumentItem where Code = ? and (CompanyID is null or CompanyID = ?) and Status = ? 
		 *  原sql语句  现因无CompanyID字段改成 select * from DocumentItem where Code = ? and Status = ?   */
		OrmUtilities.modifyBegin();
		//		DocumentItem documentItems = bmfAggrManager.findOneBySql("select * from DocumentItem where Code = ? and Status = ?", DocumentItem.class, code, status.getValue());
		DocumentItem documentItems = documentItemOrmService.findOneByCode_Status(code, status.getValue());
		OrmUtilities.modifyEnd();
		
		return documentItems;
	}



​	JobNotRunListener.java



			OrmUtilities.modifyBegin();
			//find AlertMethod
	//		Long alertMethodOid = getTableReconOid("AlertMethod", ImmutableMap.of("AlertMethod", AlertMethodEnum.SMS.getValue()));
			SObject sObject=bmfOrmAggrManager.findOne("AlertMethod", ImmutableMap.of("AlertMethod", AlertMethodEnum.SMS.getValue()));
			Long alertMethodOid=null;
			alertMethodOid=(sObject == null)? null : sObject.getOid();
			OrmUtilities.modifyEnd();
			
	private Long getTableReconOid(String table, Map<String, String> paramsMap) {
		SObject sObject = bmfAggrManager.findOne(table, paramsMap);
		return null == sObject ? null : sObject.getOid();
	}
​		

